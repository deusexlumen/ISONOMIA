<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISONOMIA | Projekt Kronos</title>
    
    <!-- ================================================================== -->
    <!-- CSS: DESIGN TOKENS & LAYOUT                                        -->
    <!-- ================================================================== -->
    <style>
        /* ------------------------------------------------------------------ */
        /* 1. Design Tokens (Custom Properties)                               */
        /* ------------------------------------------------------------------ */
        :root {
            --bg: #050505;
            --cyan: #00FFCC;
            --magenta: #FF3366;
            --white: #FFFFFF;
            --text: #ffffff;
            --dim-text: rgba(255, 255, 255, 0.4);
            --font-main: 'Inter', -apple-system, sans-serif;
        }

        /* ------------------------------------------------------------------ */
        /* 2. Reset & Base Styles                                             */
        /* ------------------------------------------------------------------ */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body, html {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* ------------------------------------------------------------------ */
        /* 3. Particle System (Background Layer)                              */
        /* ------------------------------------------------------------------ */
        #particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--cyan);
            border-radius: 50%;
            opacity: 0.4;
            box-shadow: 0 0 10px var(--cyan);
            will-change: transform, opacity;
            transform: translateZ(0); /* Hardware acceleration */
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
        }

        .dot:hover {
            opacity: 1;
            transform: scale(2);
            box-shadow: 0 0 20px var(--cyan), 0 0 40px var(--cyan);
        }

        .dot.active {
            opacity: 1;
            transform: scale(2.5);
            background: var(--white);
            box-shadow: 0 0 30px var(--white), 0 0 60px var(--cyan);
        }

        /* Connection lines between particles */
        .connection-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, var(--cyan), transparent);
            transform-origin: left center;
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* ------------------------------------------------------------------ */
        /* 4. Stage & Content Layer                                           */
        /* ------------------------------------------------------------------ */
        #stage {
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }

        .message-box {
            max-width: 850px;
            padding: 3rem;
            text-align: center;
        }

        /* ------------------------------------------------------------------ */
        /* 5. Typography                                                      */
        /* ------------------------------------------------------------------ */
        .gandalf-voice h1 {
            font-weight: 300;
            font-size: 2.2rem;
            line-height: 1.4;
            letter-spacing: -0.5px;
            margin-bottom: 3.5rem;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.1);
        }
        
        /* Animated text characters */
        .animated-text {
            will-change: opacity, transform;
        }
        
        .text-char {
            display: inline-block;
            will-change: opacity, transform;
        }
        
        /* Enhanced button animations */
        .option-btn {
            will-change: opacity, transform;
            position: relative;
            overflow: hidden;
        }
        
        .option-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .option-btn:hover::before {
            left: 100%;
        }

        /* ------------------------------------------------------------------ */
        /* 6. Interactive Elements (Buttons)                                  */
        /* ------------------------------------------------------------------ */
        .button-group {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .haptic-btn {
            background: rgba(0, 255, 204, 0.03);
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 1.2rem 2.8rem;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            position: relative;
        }

        .haptic-btn:hover {
            background: var(--cyan);
            color: var(--bg);
            box-shadow: 0 0 50px var(--cyan);
            transform: translateY(-5px);
        }

        .haptic-btn:focus-visible {
            outline: 2px solid var(--cyan);
            outline-offset: 4px;
            background: var(--cyan);
            color: var(--bg);
        }

        .btn-small {
            padding: 0.8rem 1.5rem;
            font-size: 0.75rem;
        }

        /* ------------------------------------------------------------------ */
        /* 7. Navigation & Progress                                           */
        /* ------------------------------------------------------------------ */
        .nav-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid rgba(0, 255, 204, 0.1);
        }

        .progress-indicator {
            font-size: 0.75rem;
            color: var(--dim-text);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* ------------------------------------------------------------------ */
        /* 8. Resource Vault                                                  */
        /* ------------------------------------------------------------------ */
        .vault-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 2rem;
        }

        .vault-item {
            border: 1px solid var(--dim-text);
            padding: 1.5rem;
            color: white;
            text-decoration: none;
            transition: 0.3s;
            background: rgba(255, 255, 255, 0.02);
            text-align: left;
        }

        .vault-item:hover {
            border-color: var(--cyan);
            background: rgba(0, 255, 204, 0.1);
        }

        .vault-item:focus-visible {
            outline: 2px solid var(--cyan);
            outline-offset: 2px;
        }

        .vault-item span {
            display: block;
            font-size: 0.7rem;
            color: var(--dim-text);
            margin-top: 0.5rem;
        }

        /* ------------------------------------------------------------------ */
        /* 9. Accessibility: Reduced Motion                                   */
        /* ------------------------------------------------------------------ */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            .dot {
                opacity: 0.2 !important;
            }
        }

        /* ------------------------------------------------------------------ */
        /* 10. Share Dialog                                                   */
        /* ------------------------------------------------------------------ */
        .share-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .share-dialog-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        .share-dialog-content {
            position: relative;
            background: var(--bg);
            border: 1px solid var(--cyan);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
            z-index: 101;
        }

        .share-dialog-content h3 {
            color: var(--cyan);
            font-weight: 300;
            margin-bottom: 1.5rem;
        }

        .share-dialog-content textarea {
            width: 100%;
            height: 100px;
            background: rgba(0, 255, 204, 0.05);
            border: 1px solid rgba(0, 255, 204, 0.3);
            color: var(--text);
            padding: 1rem;
            font-family: var(--font-main);
            font-size: 0.9rem;
            resize: none;
            margin-bottom: 1.5rem;
        }

        .share-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .share-buttons button {
            background: transparent;
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 0.6rem 1.2rem;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        .share-buttons button:hover {
            background: var(--cyan);
            color: var(--bg);
        }

        .share-dialog-content .close-btn {
            background: transparent;
            border: none;
            color: var(--dim-text);
            cursor: pointer;
            font-size: 0.8rem;
        }

        .share-dialog-content .close-btn:hover {
            color: var(--cyan);
        }

        /* ------------------------------------------------------------------ */
        /* 11. Lottery Simulation                                             */
        /* ------------------------------------------------------------------ */
        .lottery-card {
            border: 2px solid var(--cyan);
            padding: 2rem;
            background: rgba(0, 255, 204, 0.03);
            max-width: 400px;
            margin: 0 auto;
        }

        .lottery-card.shuffling {
            opacity: 0.7;
            transform: scale(0.95);
        }

        .lottery-card.winner {
            border-color: var(--white);
            box-shadow: 0 0 40px rgba(0, 255, 204, 0.2);
        }

        .lottery-winner-badge {
            background: var(--cyan);
            color: var(--bg);
            padding: 0.3rem 1rem;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: inline-block;
            margin-bottom: 1rem;
        }

        .lottery-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .lottery-name {
            font-size: 1.3rem;
            margin-bottom: 0.3rem;
        }

        .lottery-job {
            color: var(--dim-text);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .lottery-bio {
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text);
        }

        @keyframes lotteryReveal {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* ------------------------------------------------------------------ */
        /* 12. System Check Animation (Priming)                               */
        /* ------------------------------------------------------------------ */
        .system-check-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
        }

        .system-check-container {
            text-align: center;
            max-width: 600px;
            padding: 2rem;
        }

        .system-check-title {
            font-size: 1.2rem;
            color: var(--cyan);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 3rem;
            opacity: 0;
            animation: fadeInOut 2s ease-in-out forwards;
        }

        .interval-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 3rem;
        }

        .interval-node {
            width: 60px;
            height: 60px;
            border: 1px solid var(--dim-text);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: var(--dim-text);
            position: relative;
            opacity: 0;
            transform: scale(0.8);
        }

        .interval-node.active {
            border-color: var(--cyan);
            color: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
            opacity: 1;
            transform: scale(1);
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .interval-node.checking {
            animation: pulseCheck 0.6s ease-in-out;
        }

        .interval-node.verified {
            border-color: var(--cyan);
            background: rgba(0, 255, 204, 0.1);
        }

        .interval-node.verified::after {
            content: '✓';
            position: absolute;
            color: var(--cyan);
            font-size: 1.2rem;
        }

        @keyframes pulseCheck {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 rgba(0, 255, 204, 0); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px rgba(0, 255, 204, 0.5); }
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(10px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        .system-check-status {
            font-size: 0.9rem;
            color: var(--dim-text);
            min-height: 2rem;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .system-check-status.visible {
            opacity: 1;
        }

        .system-check-complete {
            font-size: 1.5rem;
            color: var(--cyan);
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .system-check-complete.visible {
            opacity: 1;
            transform: scale(1);
        }

        /* ------------------------------------------------------------------ */
        /* 13. Patch Counter (Soziale Validierung)                            */
        /* ------------------------------------------------------------------ */
        .patch-counter {
            background: rgba(0, 255, 204, 0.05);
            border: 1px solid var(--cyan);
            padding: 1.5rem;
            text-align: center;
            margin: 2rem 0;
        }

        .patch-counter-number {
            font-size: 3rem;
            font-weight: 300;
            color: var(--cyan);
            line-height: 1;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }

        .patch-counter-label {
            font-size: 0.75rem;
            color: var(--dim-text);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .patch-counter-live {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
            font-size: 0.8rem;
            color: var(--dim-text);
        }

        .live-indicator {
            width: 8px;
            height: 8px;
            background: var(--cyan);
            border-radius: 50%;
            animation: livePulse 2s ease-in-out infinite;
        }

        @keyframes livePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        /* ------------------------------------------------------------------ */
        /* 14. System Check Progress Bar                                      */
        /* ------------------------------------------------------------------ */
        .system-check-progress {
            width: 100%;
            max-width: 400px;
            height: 2px;
            background: rgba(0, 255, 204, 0.1);
            margin: 2rem auto;
            position: relative;
            overflow: hidden;
        }

        .system-check-progress-bar {
            height: 100%;
            background: var(--cyan);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--cyan);
        }

        .system-check-progress-text {
            font-size: 0.75rem;
            color: var(--dim-text);
            text-align: center;
            margin-top: 0.5rem;
            letter-spacing: 1px;
        }

        /* ------------------------------------------------------------------ */
        /* 15. Responsive Adjustments                                         */
        /* ------------------------------------------------------------------ */
        @media (max-width: 768px) {
            .message-box {
                padding: 1.5rem;
            }
            .gandalf-voice h1 {
                font-size: 1.6rem;
                margin-bottom: 2rem;
            }
            .vault-grid {
                grid-template-columns: 1fr;
            }
            .haptic-btn {
                padding: 1rem 2rem;
                font-size: 0.8rem;
            }
            .interval-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.5rem;
            }
            .interval-node {
                width: 40px;
                height: 40px;
                font-size: 0.6rem;
            }
            .patch-counter-number {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Background: Particle System -->
    <div id="particle-container"></div>
    
    <!-- Foreground: Content Stage -->
    <main id="stage" role="main" aria-live="polite" aria-atomic="true">
        <div id="content-layer" class="message-box"></div>
    </main>

    <!-- Animation Library -->
    <script src="anime.umd.min.js"></script>
    
    <!-- 3D Engine (Three.js) -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <!-- Application Logic -->
    <script>
        // ==================================================================
        // SECTION 1: NARRATIVE DATA
        // ==================================================================
        
        /**
         * NARRATIVE DATASET: PROJEKT KRONOS
         * Dialektische Knotenpunkte basierend auf der Systemdiagnose.
         * 
         * Structure:
         *   - key: Unique identifier for the narrative node
         *   - text: The narrative content displayed to the user
         *   - options: Array of choices leading to next nodes
         *   - visual: Particle animation mode triggered on this node
         */

        // ==================================================================
        // EVENT SYSTEM (Loose Coupling Architecture)
        // ==================================================================
        
        const EventBus = {
            events: {},
            
            on(event, callback) {
                if (!this.events[event]) this.events[event] = [];
                this.events[event].push(callback);
                return () => this.off(event, callback);
            },
            
            off(event, callback) {
                if (!this.events[event]) return;
                this.events[event] = this.events[event].filter(cb => cb !== callback);
            },
            
            emit(event, data) {
                if (!this.events[event]) return;
                this.events[event].forEach(callback => {
                    try {
                        callback(data);
                    } catch (err) {
                        console.error(`[EventBus] Error in handler for ${event}:`, err);
                    }
                });
            }
        };

        // Animation Controller for proper cleanup
        const AnimationController = {
            activeAnimations: new Map(),
            
            register(id, animation) {
                this.cancel(id);
                this.activeAnimations.set(id, animation);
            },
            
            cancel(id) {
                const anim = this.activeAnimations.get(id);
                if (anim && anim.pause) {
                    anim.pause();
                }
                this.activeAnimations.delete(id);
            },
            
            cancelAll() {
                this.activeAnimations.forEach(anim => {
                    if (anim && anim.pause) anim.pause();
                });
                this.activeAnimations.clear();
            }
        };

        // XSS Sanitization utility
        const Sanitizer = {
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            sanitizeTemplate(strings, ...values) {
                return strings.reduce((result, string, i) => {
                    const value = values[i];
                    if (value === undefined) return result + string;
                    return result + string + this.escapeHtml(String(value));
                }, '');
            }
        };

        // ==================================================================
        // PSYCHOLOGISCHES JUDO - USER PROFILING SYSTEM
        // ==================================================================
        
        const UserProfile = {
            // Dimension 1: Politisches Interesse
            engagementLevel: null, // 'engaged' | 'casual' | 'avoidant'
            
            // Dimension 2: Skepsis-Ausrichtung
            skepticismType: null, // 'system' | 'trust' | 'agency'
            
            // Dimension 3: Werteorientierung
            valueAnchor: null, // 'patriot' | 'pragmatist' | 'idealist' | 'skeptic'
            
            // Dimension 4: Commitment-History (Micro-Commits)
            commitments: [],
            commitmentScore: 0,
            
            // Dimension 5: Einwände (Objektionen)
            raisedObjections: [],
            resolvedObjections: [],
            
            // Dimension 6: Interaktions-Muster
            nodeVisitTimes: {},
            backtrackCount: 0,
            pathTaken: [],
            totalTime: 0,
            
            // Session Start
            sessionStart: Date.now(),
            
            /**
             * Setzt ein Profil-Attribut
             */
            set(attribute, value) {
                if (this.hasOwnProperty(attribute)) {
                    this[attribute] = value;
                    this._persist();
                }
            },
            
            /**
             * Fügt einen Commitment hinzu
             */
            addCommitment(nodeId, agreed, context = '') {
                this.commitments.push({
                    nodeId,
                    agreed,
                    context,
                    timestamp: Date.now()
                });
                
                // Berechne Commitment-Score (0-100)
                const yesCommits = this.commitments.filter(c => c.agreed).length;
                this.commitmentScore = Math.min((yesCommits / 5) * 100, 100);
                
                this._persist();
            },
            
            /**
             * Verzeichnet einen Knoten-Besuch mit Zeit
             */
            recordNodeVisit(nodeId) {
                this.pathTaken.push(nodeId);
                this.nodeVisitTimes[nodeId] = Date.now();
                this._persist();
            },
            
            /**
             * Erfasst einen Einwand
             */
            recordObjection(objectionType) {
                if (!this.raisedObjections.includes(objectionType)) {
                    this.raisedObjections.push(objectionType);
                    this._persist();
                }
            },
            
            /**
             * Markiert einen Einwand als gelöst
             */
            resolveObjection(objectionType) {
                if (!this.resolvedObjections.includes(objectionType)) {
                    this.resolvedObjections.push(objectionType);
                }
                this._persist();
            },
            
            /**
             * Prüft, ob ein Einwand bereits gelöst wurde
             */
            isObjectionResolved(objectionType) {
                return this.resolvedObjections.includes(objectionType);
            },
            
            /**
             * Liefert ein Profil-Summary für dynamische Texte
             */
            getSummary() {
                const timeSpent = Math.floor((Date.now() - this.sessionStart) / 1000);
                return {
                    engagementLevel: this.engagementLevel,
                    valueAnchor: this.valueAnchor,
                    commitmentScore: this.commitmentScore,
                    commitmentsCount: this.commitments.filter(c => c.agreed).length,
                    pathLength: this.pathTaken.length,
                    timeSpent,
                    objectionsRaised: this.raisedObjections.length,
                    objectionsResolved: this.resolvedObjections.length
                };
            },
            
            /**
             * Bestimmt den optimalen Pfad basierend auf Profil
             */
            getRecommendedPath() {
                const paths = {
                    'engaged-patriot': ['patriot_hook', 'patriot_crisis', 'patriot_solution'],
                    'engaged-skeptic': ['skeptic_data', 'skeptic_proof', 'skeptic_convert'],
                    'casual-pragmatist': ['pragmatist_problem', 'pragmatist_benefit', 'pragmatist_action'],
                    'avoidant-idealist': ['idealist_vision', 'idealist_principle', 'idealist_join'],
                    'default': ['hook', 'path_parties_start', 'path_expert_logic']
                };
                
                const key = `${this.engagementLevel}-${this.valueAnchor}`;
                return paths[key] || paths['default'];
            },
            
            /**
             * Persistiert Profil in SessionStorage
             */
            _persist() {
                try {
                    const data = {
                        engagementLevel: this.engagementLevel,
                        skepticismType: this.skepticismType,
                        valueAnchor: this.valueAnchor,
                        commitments: this.commitments,
                        commitmentScore: this.commitmentScore,
                        raisedObjections: this.raisedObjections,
                        resolvedObjections: this.resolvedObjections,
                        pathTaken: this.pathTaken,
                        backtrackCount: this.backtrackCount
                    };
                    sessionStorage.setItem('isonomia_profile', JSON.stringify(data));
                } catch (e) {
                    console.warn('[UserProfile] Could not persist:', e);
                }
            },
            
            /**
             * Lädt Profil aus SessionStorage
             */
            load() {
                try {
                    const data = JSON.parse(sessionStorage.getItem('isonomia_profile'));
                    if (data) {
                        Object.assign(this, data);
                    }
                } catch (e) {
                    console.warn('[UserProfile] Could not load:', e);
                }
            },
            
            /**
             * Löscht Profil
             */
            clear() {
                this.engagementLevel = null;
                this.skepticismType = null;
                this.valueAnchor = null;
                this.commitments = [];
                this.commitmentScore = 0;
                this.raisedObjections = [];
                this.resolvedObjections = [];
                this.pathTaken = [];
                this.backtrackCount = 0;
                sessionStorage.removeItem('isonomia_profile');
            }
        };
        
        // Lade gespeichertes Profil beim Start
        UserProfile.load();
        
        // ==================================================================
        // OBJECTION HANDLING SYSTEM
        // ==================================================================
        
        const ObjectionHandler = {
            database: {
                'practicality': {
                    patterns: [/funktioniert nicht/i, /realität/i, /praxis/i, /umsetzbar/i],
                    priority: 1,
                    responses: {
                        'pragmatist': "In Athen hat es 200 Jahre funktioniert. Was ist pragmatischer als bewährte Lösungen?",
                        'patriot': "Deutschland hat Systemwechsel gemeistert. 1989. 1949. Wir können das.",
                        'skeptic': "Richtig. Deshalb brauchen wir einen Testzeitraum. Ein Experiment.",
                        'idealist': "Träume scheitern an Umsetzung. Deshalb: Ein Jahr Test, dann entscheiden wir.",
                        'default': "Das Athenische System funktionierte 200 Jahre. Das ist mehr als unser aktuelles System geschafft hat."
                    }
                },
                'qualification': {
                    patterns: [/qualifikation/i, /kompetenz/i, /wissen/i, /fachkenntnis/i, /experten/i],
                    priority: 2,
                    responses: {
                        'pragmatist': "Wäre Deutschland 1949 qualifizierter mit Akademikern? Oder mit Weisheit?",
                        'patriot': "Die Weimarer Republik hatte Experten. Die BRD hatte Visionäre. Was hat funktioniert?",
                        'skeptic': "Zeig mir die Studie, die sagt, dass Akademiker bessere Gesetze schreiben.",
                        'idealist': "Jeder Mensch hat ein Recht auf Mitsprache. Das ist die höchste Qualifikation.",
                        'default': "87% Akademiker im Bundestag bei 20% in der Bevölkerung. Ist das Repräsentation?"
                    }
                },
                'corruption': {
                    patterns: [/korruption/i, /bestechung/i, /geld/i, / lobbying/i, / kaufen/i],
                    priority: 3,
                    responses: {
                        'pragmatist': "Ein Jahr Amtszeit. Dann wieder Bürger. Weniger Zeit für Korruption als heute.",
                        'patriot': "Korruption braucht Zeit und Netzwerke. Das Los zerstört beides.",
                        'skeptic': "Weniger Korruption als heute wäre bereits ein Fortschritt.",
                        'idealist': "Gerechtigkeit beginnt mit Unbestechlichkeit. Das Los kennt keine Günstlinge.",
                        'default': "Karrierepolitiker brauchen Jahre für Korruption. Bürger haben nur ein Jahr."
                    }
                },
                'time': {
                    patterns: [/zeit/i, /aufwand/i, /aufwändig/i, /kompliziert/i],
                    priority: 4,
                    responses: {
                        'pragmatist': "Wie viel Zeit verlieren wir heute an sinnlose Debatten?",
                        'patriot': "Freiheit braucht Zeit. Aber Sklaverei braucht mehr.",
                        'skeptic': "Berechnung: 1 Jahr Dienst alle 20 Jahre vs. tägliche Politik-Frust.",
                        'idealist': "Die beste Zeit für Gerechtigkeit ist jetzt.",
                        'default': "Ein Jahr alle zwanzig. Weniger Zeit als heute für Steuererklärung."
                    }
                },
                'extremism': {
                    patterns: [/extrem/i, /radikal/i, /gefährlich/i, /unverantwortlich/i],
                    priority: 5,
                    responses: {
                        'pragmatist': "Radikal ist, das Scheitern fortzusetzen und andere Ergebnisse zu erwarten.",
                        'patriot': "Unser Grundgesetz war radikal. 1949. Heute ist es Normalität.",
                        'skeptic': "Was ist radikaler: Evolution oder Revolution?",
                        'idealist': "Extrem ist Ungerechtigkeit. Moderat ist Isonomie.",
                        'default': "Radikal wäre, nichts zu ändern. Evolution ist weise."
                    }
                }
            },
            
            /**
             * Analysiert Text auf Einwände
             */
            detectObjection(text) {
                for (const [type, data] of Object.entries(this.database)) {
                    for (const pattern of data.patterns) {
                        if (pattern.test(text)) {
                            return type;
                        }
                    }
                }
                return null;
            },
            
            /**
             * Liefert passende Antwort auf Einwand
             */
            getResponse(objectionType, userProfile) {
                const data = this.database[objectionType];
                if (!data) return null;
                
                const anchor = userProfile.valueAnchor || 'default';
                return data.responses[anchor] || data.responses['default'];
            },
            
            /**
             * Prüft, ob ein Knoten einen Einwand behandeln sollte
             */
            shouldHandleObjection(currentNodeId, userProfile) {
                // Wenn ungelöste Einwände existieren, behandle den wichtigsten
                const unresolved = userProfile.raisedObjections.filter(
                    o => !userProfile.isObjectionResolved(o)
                );
                
                if (unresolved.length === 0) return false;
                
                // Priorisiere nach Schwere
                const priorities = unresolved.map(o => this.database[o]?.priority || 99);
                const highestPriority = Math.min(...priorities);
                const topObjection = unresolved.find(
                    o => this.database[o]?.priority === highestPriority
                );
                
                return topObjection;
            }
        };
        
        // ==================================================================
        // NEUER NARRATIVER ENTSCHEIDUNGSBAUM v3.0
        // Logik-basiert, nicht überzeugend. Jede Antwort führt weiter.
        // Bei "Nein" wird die Meinung akzeptiert, nicht überstimmt.
        // ==================================================================
        
        const narrativeData = {
            // ═══════════════════════════════════════════════════════════════
            // PHASE 1: PROBLEM-ERKENNIS (Einstieg bei grundlegenden Sorgen)
            // ═══════════════════════════════════════════════════════════════
            
            "start": {
                "text": "Willkommen bei einem Experiment. Wir stellen keine politische Meinung dar. Wir zeigen nur Logik. Möchtest du mitdenken?",
                "options": [
                    { "label": "Ja, ich möchte mitdenken", "next": "problem_entry", "profileSet": { "engagementLevel": "engaged" } },
                    { "label": "Ich bin mir nicht sicher", "next": "problem_entry_skeptic", "profileSet": { "engagementLevel": "casual", "skepticismType": "trust" } },
                    { "label": "Nein, danke", "next": "exit_respectful", "profileSet": { "engagementLevel": "avoidant" } }
                ],
                "visual": "breathe",
                "phase": "entry"
            },
            
            "exit_respectful": {
                "text": "Vollkommen in Ordnung. Niemand sollte gezwungen werden, über politische Systeme nachzudenken. Wenn du jemals neugierig wirst, ist dieser Ort hier. Bis dahin: Bleib gesund.",
                "options": [
                    { "label": "Doch noch eine Frage", "next": "problem_entry" },
                    { "label": "Auf Wiedersehen", "next": "exit_final" }
                ],
                "visual": "breathe",
                "phase": "exit"
            },
            
            "exit_final": {
                "text": "Der Dialog endet hier. Aber das Denken nicht. Vielleicht siehst du die Welt morgen mit anderen Augen. Oder auch nicht. Beides ist legitim.",
                "options": [
                    { "label": "Neustart", "next": "start" }
                ],
                "visual": "reset_to_grid",
                "phase": "exit"
            },
            
            "problem_entry_skeptic": {
                "text": "Verständlich. Das Internet ist voll von Leuten, die einem etwas verkaufen wollen. Wir nicht. Wir zeigen nur Zusammenhänge. Wenn du sie nicht siehst, ist das auch okay. Möchtest du trotzdem die erste Frage hören?",
                "options": [
                    { "label": "Ja, die erste Frage", "next": "problem_voice" },
                    { "label": "Nein, lieber nicht", "next": "exit_respectful" }
                ],
                "visual": "tremble",
                "phase": "entry"
            },
            
            "problem_entry": {
                "text": "Gut. Dann beginnen wir bei den grundlegenden Fragen, die die meisten Menschen in Deutschland bewegen. Fühlst du dich politisch gehört? Hast du das Gefühl, dass deine Stimme zählt?",
                "options": [
                    { "label": "Nein, ich fühle mich nicht gehört", "next": "problem_voice_yes", "profileSet": { "valueAnchor": "pragmatist" } },
                    { "label": "Manchmal schon", "next": "problem_voice_sometimes", "profileSet": { "valueAnchor": "idealist" } },
                    { "label": "Doch, ich fühle mich gehört", "next": "problem_voice_no", "profileSet": { "valueAnchor": "patriot" } }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_voice": {
                "text": "Diese Frage geht allen nach. 83 Millionen Menschen. Eine Stimme. Die Mathematik ist gnadenlos. Aber lass uns tiefer graben: Warum fühlst du dich nicht gehört?",
                "options": [
                    { "label": "Weil Politiker nicht zuhören", "next": "problem_politicians" },
                    { "label": "Weil das System strukturell so ist", "next": "problem_structure" },
                    { "label": "Weil ich keine Macht habe", "next": "problem_power" }
                ],
                "visual": "chaos",
                "phase": "problem"
            },
            
            "problem_voice_sometimes": {
                "text": "Ehrliche Antwort. Manchmal funktioniert es, manchmal nicht. Aber: Wie fühlst du dich an den Tagen, an denen es nicht funktioniert? Wenn du siehst, dass Entscheidungen gegen den Willen der Mehrheit getroffen werden?",
                "options": [
                    { "label": "Dann fühle ich mich machtlos", "next": "problem_power" },
                    { "label": "Dann ärgere ich mich", "next": "problem_anger" },
                    { "label": "Das ist halt so", "next": "problem_acceptance" }
                ],
                "visual": "tremble",
                "phase": "problem"
            },
            
            "problem_voice_no": {
                "text": "Interessant. Du gehörst dann zu den wenigen, die sich politisch vertreten fühlen. Respekt. Aber eine Frage: Fühlst du dich auch dann gehört, wenn deine Partei nicht gewinnt? Wenn die 'falschen' Entscheidungen getroffen werden?",
                "options": [
                    { "label": "Nein, dann nicht", "next": "problem_voice_yes", "profileSet": { "valueAnchor": "pragmatist" } },
                    { "label": "Ich akzeptiere die Demokratie", "next": "problem_democracy_accept" },
                    { "label": "Ich bin Teil der Entscheidenden", "next": "problem_elite_check" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_voice_yes": {
                "text": "Du bist nicht allein. Studien zeigen: Über 60% der Deutschen fühlen sich politisch nicht vertreten. Das ist keine Meinung. Das ist eine Zahl. Aber Zahlen allein ändern nichts. Was würde ändern, dass du dich gehört fühlst?",
                "options": [
                    { "label": "Mehr direkte Demokratie", "next": "solution_direct" },
                    { "label": "Bessere Politiker", "next": "problem_politicians" },
                    { "label": "Ein komplett neues System", "next": "solution_new_system" }
                ],
                "visual": "chaos",
                "phase": "problem"
            },
            
            "problem_politicians": {
                "text": "Die klassische Antwort. 'Die Politiker sind schuld.' Aber wart mal: Warum sind sie so? Wer wird heute Politiker? Menschen mit Visionen – oder Menschen mit Karriereplänen?",
                "options": [
                    { "label": "Menschen mit Karriereplänen", "next": "problem_career" },
                    { "label": "Beides", "next": "problem_career_mixed" },
                    { "label": "Menschen mit Visionen", "next": "problem_vision_check" }
                ],
                "visual": "pyramid",
                "phase": "problem"
            },
            
            "problem_structure": {
                "text": "Du siehst das System. Gut. Dann siehst du auch: Das Problem ist nicht die Person. Das Problem ist die Struktur. Ein System, das Lobbyisten mehr Gewicht gibt als Bürgern. Ein System, wo Geld spricht. Stimmt das?",
                "options": [
                    { "label": "Ja, das stimmt", "next": "problem_system_deep" },
                    { "label": "Nur teilweise", "next": "problem_system_partial" },
                    { "label": "Nein, das ist zu zynisch", "next": "problem_cynicism" }
                ],
                "visual": "clash",
                "phase": "problem"
            },
            
            "problem_power": {
                "text": "Machtlosigkeit. Das Gefühl, das am meisten demokratische Teilnahme zerstört. Aber: Warum hast du keine Macht? In einer Demokratie sollte doch das Volk die Macht haben... oder nicht?",
                "options": [
                    { "label": "Nein, das ist eine Illusion", "next": "problem_illusion" },
                    { "label": "Wir haben alle 4 Jahre Macht", "next": "problem_vote_cycle" },
                    { "label": "Wir haben niemals Macht", "next": "problem_never_power" }
                ],
                "visual": "pyramid_struggle",
                "phase": "problem"
            },
            
            "problem_anger": {
                "text": "Ärger ist eine rationale Reaktion auf Irrationalität. Wenn du dich ärgerst, heißt das, dass du noch erwartest, dass das System funktioniert. Das ist gut. Aber was tust du mit dem Ärger?",
                "options": [
                    { "label": "Ich wähle anders", "next": "problem_vote_different" },
                    { "label": "Ich engagiere mich", "next": "problem_engage" },
                    { "label": "Ich resigniere", "next": "problem_resignation" }
                ],
                "visual": "tremble",
                "phase": "problem"
            },
            
            "problem_acceptance": {
                "text": "Akzeptanz kann Weisheit sein – oder Resignation. Welche Art von Akzeptanz ist deine? Akzeptierst du, weil du es verstanden hast? Oder weil du aufgegeben hast, es zu ändern?",
                "options": [
                    { "label": "Ich habe es verstanden", "next": "problem_understood" },
                    { "label": "Ich habe aufgegeben", "next": "problem_resignation" },
                    { "label": "Das ist eine gute Frage", "next": "problem_reflection" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_democracy_accept": {
                "text": "Demokratie akzeptieren – auch wenn sie gegen einen entscheidet. Das ist reif. Aber: Was genau akzeptierst du? Das Prinzip? Oder die aktuelle Implementierung? Es gibt einen Unterschied.",
                "options": [
                    { "label": "Das Prinzip", "next": "logic_principle" },
                    { "label": "Die Implementierung", "next": "logic_implementation" },
                    { "label": "Beides", "next": "logic_both" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_elite_check": {
                "text": "Teil der Entscheidenden. Das ist selten. Bist du Politiker? Lobbyist? Oder meinst du etwas anderes? Denn die meisten Menschen – auch engagierte – haben kaum Einfluss auf konkrete Entscheidungen.",
                "options": [
                    { "label": "Ich bin Politiker/Lobbyist", "next": "perspective_elite" },
                    { "label": "Ich meine informierte Bürger", "next": "perspective_informed" },
                    { "label": "Du hast recht, ich übertreibe", "next": "problem_voice_yes" }
                ],
                "visual": "pyramid",
                "phase": "problem"
            },
            
            "problem_career": {
                "text": "Karriereplanung. Das ist der Schlüssel. Politik als Job, nicht als Dienst. Was passiert, wenn Politik ein Job wird? Sie müssen den Job behalten. Sie müssen wiedergewählt werden. Sie müssen Geld sammeln. Sie müssen Netzwerke pflegen. Ist das noch Demokratie?",
                "options": [
                    { "label": "Nein, das ist etwas anderes", "next": "logic_career_system" },
                    { "label": "Es ist eine notwendige Evolution", "next": "logic_evolution" },
                    { "label": "Ich weiß nicht", "next": "logic_question" }
                ],
                "visual": "pyramid",
                "phase": "problem"
            },
            
            "problem_career_mixed": {
                "text": "Beides. Natürlich. Es gibt gute Politiker mit Visionen. Aber das System bevorzugt die anderen. Die Frage ist: Wie viele Visionäre überleben im Karriere-System? Und wie viele werden korrumpiert?",
                "options": [
                    { "label": "Die meisten werden korrumpiert", "next": "logic_corruption" },
                    { "label": "Es gibt Ausnahmen", "next": "logic_exceptions" },
                    { "label": "Das System filtert sie raus", "next": "logic_filter" }
                ],
                "visual": "pyramid_struggle",
                "phase": "problem"
            },
            
            "problem_vision_check": {
                "text": "Visionen. Schön gedacht. Aber zeig mir eine politische Vision der letzten 20 Jahre, die wirklich umgesetzt wurde. Nicht kleine Reformen. Große Visionen. Wo sind sie?",
                "options": [
                    { "label": "Die Energiewende", "next": "logic_energiewende" },
                    { "label": "Es gibt keine", "next": "problem_career" },
                    { "label": "Visionen sind unrealistisch", "next": "logic_vision_unrealistic" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_system_deep": {
                "text": "Du siehst es. Das System ist nicht kaputt – es funktioniert genau wie designed. Nur nicht für uns. Es funktioniert für: Konzerne, die Gesetze schreiben. Parteien, die Macht horten. Eliten, die Entscheidungen fernab des Volkes treffen. Stimmt das?",
                "options": [
                    { "label": "Ja, das stimmt", "next": "fear_fascism_intro" },
                    { "label": "Das ist eine Verschwörungstheorie", "next": "logic_conspiracy" },
                    { "label": "Teilweise, aber übertrieben", "next": "logic_partial" }
                ],
                "visual": "clash",
                "phase": "problem"
            },
            
            "problem_system_partial": {
                "text": "Teilweise. Die ehrliche Antwort. Das System funktioniert manchmal. Aber wann? Wenn es den Mächtigen passt? Oder wirklich für das Volk? Wenn du genau hinsiehst: Wer profitiert meistens?",
                "options": [
                    { "label": "Die Mächtigen", "next": "problem_system_deep" },
                    { "label": "Manchmal das Volk", "next": "logic_sometimes" },
                    { "label": "Ich bin mir nicht sicher", "next": "logic_uncertain" }
                ],
                "visual": "clash",
                "phase": "problem"
            },
            
            "problem_cynicism": {
                "text": "Zynisch. Ein Wort für Realisten. Aber: Was ist zynisch daran, Strukturen zu benennen? Wenn ich sage 'der Himmel ist blau', ist das Zynismus oder Beobachtung?",
                "options": [
                    { "label": "Beobachtung", "next": "problem_system_deep" },
                    { "label": "Es kommt auf den Ton an", "next": "logic_tone" },
                    { "label": "Vielleicht Zynismus", "next": "logic_cynic" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_illusion": {
                "text": "Eine Illusion. Starkes Wort. Aber bedenk: In der Antike war Demokratie direkt. Jeder Bürger entschied mit. Heute: Wir wählen alle 4 Jahre Menschen, die dann tun, was sie wollen. Ist das noch Demokratie – oder ihre Simulation?",
                "options": [
                    { "label": "Eine Simulation", "next": "logic_simulation" },
                    { "label": "Eine notwendige Anpassung", "next": "logic_adaptation" },
                    { "label": "Ich weiß nicht genug darüber", "next": "logic_education" }
                ],
                "visual": "pyramid",
                "phase": "problem"
            },
            
            "problem_vote_cycle": {
                "text": "Alle 4 Jahre. 5 Minuten im Wahllokal. Dann 4 Jahre Schweigen. Aber: Was, wenn die gewählten Politiker nicht das tun, was sie versprochen haben? Können wir sie abberufen? Nein. Können wir widersprechen? Nicht wirklich. Ist das Macht?",
                "options": [
                    { "label": "Nein, das ist keine echte Macht", "next": "problem_illusion" },
                    { "label": "Wir können bei der nächsten Wahl", "next": "logic_next_election" },
                    { "label": "Wir können protestieren", "next": "logic_protest" }
                ],
                "visual": "tremble",
                "phase": "problem"
            },
            
            "problem_never_power": {
                "text": "Niemals. Das ist hart. Aber ehrlich. Die meisten würden es nicht so direkt sagen. Warum glaubst du, dass du niemals Macht hast? Woher kommt diese Überzeugung?",
                "options": [
                    { "label": "Aus Erfahrung", "next": "logic_experience" },
                    { "label": "Aus Beobachtung", "next": "logic_observation" },
                    { "label": "Aus Resignation", "next": "problem_resignation" }
                ],
                "visual": "pyramid_dissolve",
                "phase": "problem"
            },
            
            "problem_vote_different": {
                "text": "Anders wählen. Die logische Reaktion. Aber: Hast du das nicht schon versucht? Kleine Parteien? Große? Links? Rechts? Mitte? Und was war das Ergebnis?",
                "options": [
                    { "label": "Immer das Gleiche", "next": "logic_same_result" },
                    { "label": "Manchmal etwas anderes", "next": "logic_sometimes_different" },
                    { "label": "Ich habe aufgehört zu wählen", "next": "problem_resignation" }
                ],
                "visual": "clash",
                "phase": "problem"
            },
            
            "problem_engage": {
                "text": "Engagement. Wunderbar. Die Wurzeln der Demokratie. Aber: Was hat dein Engagement bewirkt? Wirklich bewirkt? Nicht wie du dich fühlst. Was hat sich geändert?",
                "options": [
                    { "label": "Nicht viel", "next": "logic_engagement_limited" },
                    { "label": "Einiges", "next": "logic_engagement_works" },
                    { "label": "Ich bin frustriert", "next": "problem_anger" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_resignation": {
                "text": "Resignation. Das Ende der Hoffnung. Aber auch: Das Ende der Enttäuschung. Wenn du nichts erwartest, kann dich nichts enttäuschen. Aber: Ist das ein Leben? Oder nur ein Überleben?",
                "options": [
                    { "label": "Es ist ein Überleben", "next": "fear_fascism_intro" },
                    { "label": "Es gibt keine Alternative", "next": "logic_no_alternative" },
                    { "label": "Ich möchte etwas ändern", "next": "solution_search" }
                ],
                "visual": "pyramid_dissolve",
                "phase": "problem"
            },
            
            "problem_understood": {
                "text": "Verstanden. Das ist etwas anderes als akzeptiert. Wenn du verstehst, warum etwas nicht funktioniert, kannst du nach Alternativen suchen. Möchtest du das?",
                "options": [
                    { "label": "Ja, zeig mir Alternativen", "next": "solution_search" },
                    { "label": "Nein, ich bin zufrieden", "next": "exit_understanding" },
                    { "label": "Ich bin mir nicht sicher", "next": "logic_uncertain_alternative" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "problem_reflection": {
                "text": "Eine gute Frage. Das ist selten. Die meisten haben Antworten, keine Fragen. Aber die Frage ist wichtiger als die Antwort. Denn die Frage öffnet Türen. Die Antwort schließt sie.",
                "options": [
                    { "label": "Welche Türen?", "next": "logic_doors" },
                    { "label": "Ich möchte Antworten", "next": "solution_search" },
                    { "label": "Das ist zu philosophisch", "next": "logic_practical" }
                ],
                "visual": "breathe",
                "phase": "problem"
            },
            
            "exit_understanding": {
                "text": "Zufriedenheit ist ein legitimes Ziel. Wenn du mit dem System zufrieden bist, wer sind wir, das in Frage zu stellen? Vielleicht funktioniert es für dich. Vielleicht hast du Glück. Oder vielleicht siehst du etwas, das wir nicht sehen.",
                "options": [
                    { "label": "Ich habe Glück", "next": "exit_lucky" },
                    { "label": "Ich sehe etwas anderes", "next": "perspective_different" },
                    { "label": "Doch, zeig mir Alternativen", "next": "solution_search" }
                ],
                "visual": "breathe",
                "phase": "exit"
            },
            
            "exit_lucky": {
                "text": "Glück. Ein ehrliches Wort. Viele würden sagen, sie haben es verdient. Aber du sagst Glück. Das zeigt Weisheit. Denn in einem System, das auf Los basiert – manche gewinnen, manche verlieren – ist Glück die einzige Konstante.",
                "options": [
                    { "label": "Was meinst du mit 'auf Los basiert'?", "next": "solution_lottery_hint" },
                    { "label": "Ich möchte nicht mehr", "next": "exit_final" },
                    { "label": "Erklär mir das System", "next": "solution_search" }
                ],
                "visual": "stochastic",
                "phase": "exit"
            },
            
            // ═══════════════════════════════════════════════════════════════
            // PHASE 2: ANGST VOR FASCHISMUS (Der zweite große Hebel)
            // ═══════════════════════════════════════════════════════════════
            
            "fear_fascism_intro": {
                "text": "Wir haben über Macht gesprochen. Über Systeme. Aber es gibt noch etwas. Etwas, das die meisten Deutschen bewegt – laut Studien. Die Angst vor dem, was kommen könnte. Hast du diese Angst?",
                "options": [
                    { "label": "Ja, ich habe Angst vor Faschismus", "next": "fear_fascism_yes" },
                    { "label": "Ich habe allgemeine politische Sorgen", "next": "fear_general" },
                    { "label": "Nein, das ist übertrieben", "next": "fear_denial" }
                ],
                "visual": "tremble",
                "phase": "fear"
            },
            
            "fear_fascism_yes": {
                "text": "Angst. Ein ehrliches Gefühl. Die Geschichte Deutschlands rechtfertigt diese Angst. Aber: Was genau fürchtest du? Die Rückkehr des Nationalsozialismus? Oder etwas Neues? Etwas, das wir noch nicht benennen können?",
                "options": [
                    { "label": "Die Rückkehr des Nationalsozialismus", "next": "fear_nazi_return" },
                    { "label": "Etwas Neues, Unbekanntes", "next": "fear_unknown" },
                    { "label": "Den Verlust der Demokratie", "next": "fear_democracy_loss" }
                ],
                "visual": "chaos",
                "phase": "fear"
            },
            
            "fear_general": {
                "text": "Politische Sorgen. Das ist verständlich. Die Welt ist komplex. Aber: Was beunruhigt dich am meisten? Die wirtschaftliche Entwicklung? Der Krieg? Oder die innere Zerstörung unserer Gesellschaft?",
                "options": [
                    { "label": "Die wirtschaftliche Entwicklung", "next": "fear_economic" },
                    { "label": "Der Krieg", "next": "fear_war" },
                    { "label": "Die innere Zerstörung", "next": "fear_social_decay" }
                ],
                "visual": "tremble",
                "phase": "fear"
            },
            
            "fear_denial": {
                "text": "Übertrieben. Vielleicht. Aber: Geschichte wiederholt sich nicht – sie reimt sich. Und die Reime sind beunruhigend. Parteien, die Minderheiten angreifen. Bücher, die verboten werden. Demonstrieren, das kriminalisiert wird. Ist das nicht beunruhigend?",
                "options": [
                    { "label": "Doch, das ist beunruhigend", "next": "fear_fascism_yes" },
                    { "label": "Das sind Einzelfälle", "next": "fear_isolated" },
                    { "label": "Ich vertraue auf die Institutionen", "next": "fear_institutions" }
                ],
                "visual": "breathe",
                "phase": "fear"
            },
            
            "fear_nazi_return": {
                "text": "Die Rückkehr. Der Albtraum Deutschlands. Aber: Können Nazis heute noch so an die Macht kommen wie 1933? Das System hat sich verändert. Oder hat es das? Was schützt uns wirklich?",
                "options": [
                    { "label": "Das Grundgesetz", "next": "fear_constitution" },
                    { "label": "Die Demokratie selbst", "next": "fear_democracy_protection" },
                    { "label": "Nichts ist sicher", "next": "fear_nothing_safe" }
                ],
                "visual": "clash",
                "phase": "fear"
            },
            
            "fear_unknown": {
                "text": "Das Unbekannte. Schlimmer als das Bekannte. Denn wir können es nicht bekämpfen, was wir nicht verstehen. Aber: Ist das Unbekannte nicht oft nur eine neue Form des Alten? Autoritarismus in neuem Gewand?",
                "options": [
                    { "label": "Ja, das könnte sein", "next": "fear_authoritarian_new" },
                    { "label": "Nein, das ist etwas fundamentales Neues", "next": "fear_fundamental_new" },
                    { "label": "Ich weiß es nicht", "next": "fear_uncertain" }
                ],
                "visual": "chaos",
                "phase": "fear"
            },
            
            "fear_democracy_loss": {
                "text": "Den Verlust der Demokratie. Das ist es, was die meisten fürchten. Aber: Was bedeutet Demokratie für dich? Das Wahlsystem? Die Rechte? Oder das Gefühl, gehört zu werden?",
                "options": [
                    { "label": "Das Wahlsystem", "next": "fear_election_system" },
                    { "label": "Die Rechte", "next": "fear_rights" },
                    { "label": "Das Gefühl, gehört zu werden", "next": "problem_voice_yes" }
                ],
                "visual": "tremble",
                "phase": "fear"
            },
            
            "fear_economic": {
                "text": "Wirtschaft. Die Sorge Nummer eins der Deutschen. Teuerung, Mieten, Energiekosten. Aber: Werden diese Probleme durch das aktuelle politische System gelöst? Oder verschärft?",
                "options": [
                    { "label": "Sie werden verschärft", "next": "problem_system_deep" },
                    { "label": "Politiker können nichts dafür", "next": "logic_politician_powerless" },
                    { "label": "Es gibt keine einfachen Lösungen", "next": "logic_complex" }
                ],
                "visual": "clash",
                "phase": "fear"
            },
            
            "fear_war": {
                "text": "Krieg. Die älteste Angst der Menschheit. Und heute wieder real. Aber: Wer entscheidet über Krieg und Frieden? Das Volk? Oder eine kleine Elite in Hinterzimmern?",
                "options": [
                    { "label": "Eine kleine Elite", "next": "problem_elite_power" },
                    { "label": "Das ist komplex", "next": "logic_war_complex" },
                    { "label": "Demokratien führen weniger Kriege", "next": "logic_democracy_peace" }
                ],
                "visual": "clash",
                "phase": "fear"
            },
            
            "fear_social_decay": {
                "text": "Die innere Zerstörung. Polarisation. Hass. Das Auseinanderdriften der Gesellschaft. Aber: Wer profitiert von dieser Spaltung? Das Volk? Oder jene, die die Macht haben?",
                "options": [
                    { "label": "Jene, die die Macht haben", "next": "problem_system_deep" },
                    { "label": "Soziale Medien", "next": "logic_social_media" },
                    { "label": "Wir alle", "next": "logic_collective_guilt" }
                ],
                "visual": "clash",
                "phase": "fear"
            },
            
            "fear_isolated": {
                "text": "Einzelfälle. Vielleicht. Aber: Wann werden aus Einzelfällen ein Muster? Wenn sie sich häufen? Wenn Institutionen sie tolerieren? Wenn die Mehrheit schweigt? Wo ist die Grenze?",
                "options": [
                    { "label": "Wenn sie sich häufen", "next": "fear_pattern" },
                    { "label": "Das ist subjektiv", "next": "logic_subjective" },
                    { "label": "Wir sind noch weit von der Grenze", "next": "logic_distance" }
                ],
                "visual": "tremble",
                "phase": "fear"
            },
            
            "fear_institutions": {
                "text": "Institutionen. Verlass auf das System. Das ist verständlich. Aber: Was, wenn die Institutionen korrumpiert werden? Was, wenn die Kontrolleure kontrolliert werden? Wer kontrolliert dann die Kontrolleure?",
                "options": [
                    { "label": "Das Volk", "next": "logic_people_control" },
                    { "label": "Niemand", "next": "fear_no_control" },
                    { "label": "Das ist paranoid", "next": "logic_paranoia" }
                ],
                "visual": "pyramid",
                "phase": "fear"
            },
            
            "fear_constitution": {
                "text": "Das Grundgesetz. Unsere Werte. Unser Schutz. Aber: Wie viele Verfassungen hat die Welt gesehen? Wie viele haben gehalten, wenn das Volk sie nicht verteidigte? Papier allein schützt nicht.",
                "options": [
                    { "label": "Das Volk muss sie verteidigen", "next": "logic_people_defense" },
                    { "label": "Deutschland ist anders", "next": "logic_germany_special" },
                    { "label": "Papier ist nur Papier", "next": "logic_paper_weak" }
                ],
                "visual": "pyramid",
                "phase": "fear"
            },
            
            "fear_democracy_protection": {
                "text": "Die Demokratie schützt sich selbst. Eine schöne Vorstellung. Aber: Funktioniert das? Wenn antidemokratische Kräfte gewählt werden – haben sie dann nicht demokratisch legitime Macht?",
                "options": [
                    { "label": "Das ist das Paradoxon", "next": "logic_paradox" },
                    { "label": "Die Demokratie muss sich wehren", "next": "logic_defense" },
                    { "label": "Deshalb brauchen wir eine bessere Demokratie", "next": "solution_search" }
                ],
                "visual": "clash",
                "phase": "fear"
            },
            
            "fear_nothing_safe": {
                "text": "Nichts ist sicher. Die harte Wahrheit. Aber: Ist das nicht gerade der Grund, warum wir nach besseren Systemen suchen müssen? Wenn nichts sicher ist – warum nicht das Beste versuchen?",
                "options": [
                    { "label": "Was wäre das Beste?", "next": "solution_search" },
                    { "label": "Ich will nichts ändern", "next": "exit_conservative" },
                    { "label": "Das ist zu riskant", "next": "logic_risk" }
                ],
                "visual": "pyramid_dissolve",
                "phase": "fear"
            },
            
            "fear_authoritarian_new": {
                "text": "Autoritarismus im neuen Gewand. Softer. Moderner. Netflix statt Propaganda. Aber mit dem gleichen Ergebnis: Wenige entscheiden, viele folgen. Siehst du das schon heute?",
                "options": [
                    { "label": "Ja, es ist schon da", "next": "fear_already_here" },
                    { "label": "Nein, das ist übertrieben", "next": "fear_denial" },
                    { "label": "Teilweise", "next": "fear_partial" }
                ],
                "visual": "pyramid",
                "phase": "fear"
            },
            
            "fear_fundamental_new": {
                "text": "Etwas fundamentales Neues. Eine Bedrohung, die wir noch nicht verstehen. Künstliche Intelligenz? Klimakatastrophe? Techno-Feudalismus? Was fürchtest du am meisten?",
                "options": [
                    { "label": "KI und Überwachung", "next": "fear_ai" },
                    { "label": "Klimakatastrophe", "next": "fear_climate" },
                    { "label": "Techno-Feudalismus", "next": "fear_techno_feudal" }
                ],
                "visual": "chaos",
                "phase": "fear"
            },
            
            "fear_uncertain": {
                "text": "Unsicherheit. Das ist ehrlich. Niemand weiß die Zukunft. Aber: Können wir uns leisten, abzuwarten? Oder müssen wir handeln, bevor es zu spät ist?",
                "options": [
                    { "label": "Wir müssen handeln", "next": "solution_search" },
                    { "label": "Abwarten ist sicherer", "next": "logic_wait" },
                    { "label": "Ich weiß nicht", "next": "logic_uncertain" }
                ],
                "visual": "breathe",
                "phase": "fear"
            },
            
            "fear_election_system": {
                "text": "Das Wahlsystem. 5 Minuten alle 4 Jahre. Ist das genug? Wenn du in einer Firma 5 Minuten alle 4 Jahre mitreden dürftest – würdest du sagen, du hast Mitsprache?",
                "options": [
                    { "label": "Nein, das wäre lächerlich", "next": "logic_analogy" },
                    { "label": "Politik ist anders", "next": "logic_politics_different" },
                    { "label": "Wir brauchen mehr direkte Demokratie", "next": "solution_direct" }
                ],
                "visual": "tremble",
                "phase": "fear"
            },
            
            "fear_rights": {
                "text": "Die Rechte. Freiheit, Gleichheit, Würde. Aber: Wer garantiert diese Rechte? Die Regierung? Das Volk? Oder sind es nur Worte, solange niemand sie durchsetzt?",
                "options": [
                    { "label": "Das Volk", "next": "logic_people_rights" },
                    { "label": "Die Regierung", "next": "logic_government_rights" },
                    { "label": "Sie müssen erkämpft werden", "next": "logic_rights_fight" }
                ],
                "visual": "clash",
                "phase": "fear"
            },
            
            "exit_conservative": {
                "text": "Konservativ sein ist legitim. 'Bewahren' bedeutet nicht 'stillstehen'. Es bedeutet: Veränderung mit Bedacht. Aber: Was, wenn das System selbst die Bedrohung ist? Was bewahren wir dann?",
                "options": [
                    { "label": "Das ist eine gute Frage", "next": "logic_conserve_what" },
                    { "label": "Ich will nicht darüber nachdenken", "next": "exit_final" },
                    { "label": "Zeig mir die Alternative", "next": "solution_search" }
                ],
                "visual": "breathe",
                "phase": "exit"
            },
            
            // ═══════════════════════════════════════════════════════════════
            // PHASE 3: LOGIK-PFADE (Die Brücke zwischen Problem und Lösung)
            // ═══════════════════════════════════════════════════════════════
            
            "logic_career_system": {
                "text": "Richtig. Das ist etwas anderes. Es ist eine Karriere-Demokratie. Aber nicht die Demokratie, die in deinem Kopf existiert. Die Demokratie, für die Menschen gestorben sind. Die Demokratie, von der wir träumen.",
                "options": [
                    { "label": "Was wäre echte Demokratie?", "next": "solution_search" },
                    { "label": "Ist das überhaupt möglich?", "next": "logic_possible" },
                    { "label": "Träume sind für Kinder", "next": "logic_dreams" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_evolution": {
                "text": "Eine notwendige Evolution. Vielleicht. Aber: Evolutionen können totale Umbauten sein. Von Dinosauriern zu Vögeln. Von Repräsentation zu... was? Was könnte die nächste Evolution sein?",
                "options": [
                    { "label": "Direkte Demokratie", "next": "solution_direct" },
                    { "label": "Liquid Democracy", "next": "logic_liquid" },
                    { "label": "Sortition - Auswahl durch Los", "next": "solution_lottery" }
                ],
                "visual": "stochastic",
                "phase": "logic"
            },
            
            "logic_question": {
                "text": "Ich weiß nicht. Ehrlich. Das ist der Anfang jeder Erkenntnis. Sokrates sagte: 'Ich weiß, dass ich nichts weiß.' Aus dieser Unwissenheit entstand die Philosophie. Aus dieser Frage entstand die Demokratie.",
                "options": [
                    { "label": "Erzähl mir von Sokrates", "next": "logic_sokrates" },
                    { "label": "Wie entstand Demokratie?", "next": "logic_democracy_origin" },
                    { "label": "Was hat das mit heute zu tun?", "next": "logic_relevance" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_corruption": {
                "text": "Die meisten werden korrumpiert. Ein trauriges Fazit. Aber: Warum? Weil sie schlechte Menschen sind? Oder weil das System Korrumpierbare belohnt? Was, wenn das System das Problem ist – nicht die Menschen?",
                "options": [
                    { "label": "Das System ist das Problem", "next": "problem_system_deep" },
                    { "label": "Beides", "next": "logic_both_factors" },
                    { "label": "Menschen sind schlecht", "next": "logic_humans_bad" }
                ],
                "visual": "pyramid",
                "phase": "logic"
            },
            
            "logic_exceptions": {
                "text": "Ausnahmen. Ja, es gibt sie. Aber: Ein System, das von Ausnahmen abhängt, ist kein gutes System. Was, wenn wir ein System bauen könnten, das nicht auf Ausnahmen angewiesen ist?",
                "options": [
                    { "label": "Was wäre das für ein System?", "next": "solution_search" },
                    { "label": "Das ist utopisch", "next": "logic_utopia" },
                    { "label": "Ausnahmen reichen", "next": "logic_exceptions_enough" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_filter": {
                "text": "Das System filtert sie raus. Ja. Gute Menschen gehen, schlechte bleiben. Wie ein Sieb, das die Perlen ausspuckt und den Sand behält. Aber: Was, wenn wir das Sieb umdrehen könnten?",
                "options": [
                    { "label": "Wie würde das funktionieren?", "next": "solution_filter_reverse" },
                    { "label": "Das ist unmöglich", "next": "logic_impossible" },
                    { "label": "Erklär mir mehr", "next": "solution_search" }
                ],
                "visual": "reset_to_grid",
                "phase": "logic"
            },
            
            "logic_energiewende": {
                "text": "Die Energiewende. Ein Beispiel. Aber: Wer hat sie vorangetrieben? Die Regierung? Oder das Volk? Die Anti-Atom-Bewegungen, Fridays for Future – waren das nicht Bürger, die mehr wollten als ihre Regierung?",
                "options": [
                    { "label": "Das Volk hat sie vorangetrieben", "next": "logic_people_power" },
                    { "label": "Die Regierung hat reagiert", "next": "logic_government_reaction" },
                    { "label": "Beides", "next": "logic_both_driven" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_vision_unrealistic": {
                "text": "Visionen sind unrealistisch. Vielleicht. Aber: Was ist realistisch? Das, was wir haben? Ein System, das alle enttäuscht? Ist Realismus nicht manchmal nur Resignation in Verkleidung?",
                "options": [
                    { "label": "Vielleicht hast du recht", "next": "logic_resignation_masked" },
                    { "label": "Ich will trotzdem Realismus", "next": "logic_realism" },
                    { "label": "Zeig mir eine realistische Vision", "next": "solution_search" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_conspiracy": {
                "text": "Verschwörungstheorie. Ein Wort, das alles diskreditiert, ohne es zu widerlegen. Aber: Was, wenn es keine Verschwörung gibt? Nur ein System, das strukturell so funktioniert? Keine bösen Menschen. Nur schlechte Anreize.",
                "options": [
                    { "label": "Strukturen sind mächtiger", "next": "logic_structures_power" },
                    { "label": "Es gibt auch böse Menschen", "next": "logic_evil_people" },
                    { "label": "Das ist Semantik", "next": "logic_semantics" }
                ],
                "visual": "pyramid",
                "phase": "logic"
            },
            
            "logic_partial": {
                "text": "Teilweise übertrieben. Ehrlich. Aber: Wenn ein Haus teilweise brennt, löschst du dann das Feuer? Oder sagst du 'Es brennt nur teilweise'?",
                "options": [
                    { "label": "Man löscht das Feuer", "next": "logic_fire" },
                    { "label": "Man beobachtet erst", "next": "logic_observe" },
                    { "label": "Das ist keine gute Analogie", "next": "logic_analogy_bad" }
                ],
                "visual": "tremble",
                "phase": "logic"
            },
            
            "logic_sometimes": {
                "text": "Manchmal funktioniert es. Ja. Aber: Ist 'manchmal' genug? Wenn dein Auto manchmal funktioniert, würdest du sagen, es ist in Ordnung? Oder würdest du es reparieren?",
                "options": [
                    { "label": "Ich würde es reparieren", "next": "logic_repair" },
                    { "label": "Politik ist kein Auto", "next": "logic_not_car" },
                    { "label": "Es gibt nichts Besseres", "next": "logic_no_better" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_uncertain": {
                "text": "Unsicherheit. Das ist okay. Wir sind alle unsicher. Aber: Ist Unsicherheit ein Grund, nichts zu tun? Oder ein Grund, mehr zu lernen, mehr zu verstehen, mehr zu fragen?",
                "options": [
                    { "label": "Mehr lernen", "next": "solution_search" },
                    { "label": "Erstmal abwarten", "next": "logic_wait" },
                    { "label": "Ich bleibe unsicher", "next": "logic_stay_uncertain" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_principle": {
                "text": "Das Prinzip. Gerechtigkeit, Freiheit, Gleichheit. Schöne Worte. Aber: Was nutzt das Prinzip, wenn die Implementierung es verrät? Wenn das Papier sagt 'alle sind gleich', aber die Realität sagt 'einige sind gleicher'?",
                "options": [
                    { "label": "Dann ist das Prinzip wertlos", "next": "logic_principle_worthless" },
                    { "label": "Das Prinzip bleibt wichtig", "next": "logic_principle_important" },
                    { "label": "Wir müssen die Implementierung ändern", "next": "solution_search" }
                ],
                "visual": "clash",
                "phase": "logic"
            },
            
            "logic_implementation": {
                "text": "Die Implementierung. Ja. Das ist, wo es hapert. Aber: Kann man Prinzip und Implementierung trennen? Ist ein Prinzip, das nicht funktioniert, noch ein Prinzip? Oder nur eine hübsche Idee?",
                "options": [
                    { "label": "Nur eine hübsche Idee", "next": "logic_idea_only" },
                    { "label": "Es ist noch ein Prinzip", "next": "logic_still_principle" },
                    { "label": "Wir brauchen beides", "next": "logic_both_needed" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_both": {
                "text": "Beides. Das ist die komplexe Wahrheit. Aber: Wenn beides nicht funktioniert – weder Prinzip noch Implementierung – was bleibt dann? Nur die Erinnerung an etwas, das nie existiert hat?",
                "options": [
                    { "label": "Wir können es besser machen", "next": "solution_search" },
                    { "label": "Es hat nie funktioniert", "next": "logic_never_worked" },
                    { "label": "Das ist zu pessimistisch", "next": "logic_pessimism" }
                ],
                "visual": "pyramid_dissolve",
                "phase": "logic"
            },
            
            "logic_simulation": {
                "text": "Eine Simulation. Starkes Wort. Aber: Was wäre echte Demokratie? Wenn du darüber nachdenkst – hast du jemals echte Demokratie erlebt? Oder nur diese Simulation?",
                "options": [
                    { "label": "Nur die Simulation", "next": "logic_only_simulation" },
                    { "label": "In kleinen Gruppen schon", "next": "logic_small_groups" },
                    { "label": "In der Antike vielleicht", "next": "logic_antiquity" }
                ],
                "visual": "pyramid",
                "phase": "logic"
            },
            
            "logic_adaptation": {
                "text": "Eine notwendige Anpassung. Von direkter zu repräsentativer Demokratie. Wegen der Größe. Wegen der Komplexität. Aber: Hat diese Anpassung funktioniert? Oder hat sie das Volk entmachtet?",
                "options": [
                    { "label": "Sie hat das Volk entmachtet", "next": "logic_people_disempowered" },
                    { "label": "Sie war notwendig", "next": "logic_necessary" },
                    { "label": "Wir können sie rückgängig machen", "next": "solution_search" }
                ],
                "visual": "pyramid",
                "phase": "logic"
            },
            
            "logic_education": {
                "text": "Nicht genug wissen. Ehrlich. Das ist gut. Denn: Wissen ist der erste Schritt. Aber: Woher kommt das Wissen? Von denen, die das System erhalten wollen? Oder von denen, die es hinterfragen?",
                "options": [
                    { "label": "Ich will unabhängige Quellen", "next": "vault" },
                    { "label": "Ich will beide Seiten hören", "next": "logic_both_sides" },
                    { "label": "Zeig mir die Geschichte", "next": "logic_history" }
                ],
                "visual": "breathe",
                "phase": "logic"
            },
            
            "logic_next_election": {
                "text": "Bei der nächsten Wahl. Die ewige Hoffnung. Aber: Wie oft hast du das schon gedacht? Und wie oft hat es funktioniert? Wenn das Ergebnis immer das Gleiche ist – ist es dann noch Demokratie?",
                "options": [
                    { "label": "Nein, es ist ein Kreislauf", "next": "logic_cycle" },
                    { "label": "Irgendwann wird es besser", "next": "logic_hope" },
                    { "label": "Wir brauchen etwas anderes", "next": "solution_search" }
                ],
                "visual": "clash",
                "phase": "logic"
            },
            
            "logic_protest": {
                "text": "Protestieren. Das Recht der Bürger. Aber: Funktioniert es? Wann hat ein Protest in Deutschland zuletzt wirklich etwas geändert? Nicht symbolisch. Wirklich.",
                "options": [
                    { "label": "Die Wende 1989", "next": "logic_wende" },
                    { "label": "Friday for Future", "next": "logic_fridays" },
                    { "label": "Proteste werden ignoriert", "next": "logic_ignored" }
                ],
                "visual": "clash",
                "phase": "logic"
            },
            
            "solution_lottery_hint": {
                "text": "Auf Los basiert. Das ist der Schlüssel. Nicht Meritokratie. Nicht Wahl. Nicht das Beste an die Macht bringen. Sondern: Zufall. Gleiche Chancen für alle. Keine Kampagnen. Keine Lobby. Nur: Das Los entscheidet.",
                "options": [
                    { "label": "Das klingt verrückt", "next": "solution_crazy" },
                    { "label": "Erzähl mir mehr", "next": "solution_lottery" },
                    { "label": "Das ist unmöglich", "next": "logic_impossible" }
                ],
                "visual": "stochastic",
                "phase": "solution"
            },
            
            "solution_search": {
                "text": "Du suchst. Das ist der erste Schritt. Aber: Was suchst du? Eine neue Partei? Ein neues Gesetz? Oder ein neues System? Etwas, das die grundlegenden Probleme löst – nicht nur die Symptome?",
                "options": [
                    { "label": "Ein neues System", "next": "solution_system" },
                    { "label": "Ich weiß nicht genau", "next": "solution_explore" },
                    { "label": "Nur kleine Reformen", "next": "logic_small_reforms" }
                ],
                "visual": "breathe",
                "phase": "solution"
            },
            
            "solution_system": {
                "text": "Ein neues System. Mutig. Aber auch notwendig. Denn: Kleine Reformen kleiner Fehler machen größere Fehler. Was, wenn wir das Fundament ändern müssten? Nicht das Dach reparieren, sondern das Fundament neu gießen?",
                "options": [
                    { "label": "Was wäre das Fundament?", "next": "solution_foundation" },
                    { "label": "Das ist zu radikal", "next": "logic_radical" },
                    { "label": "Wie würde das aussehen?", "next": "solution_lottery" }
                ],
                "visual": "reset_to_grid",
                "phase": "solution"
            },
            
            "solution_explore": {
                "text": "Nicht genau wissen. Das ist ehrlich. Es gibt so viele Ideen. Direkte Demokratie. Liquid Democracy. Sozialismus. Anarchismus. Aber: Was, wenn es eine Idee gibt, die 2000 Jahre alt ist – und funktioniert hat?",
                "options": [
                    { "label": "Welche Idee?", "next": "solution_ancient" },
                    { "label": "2000 Jahre sind vorbei", "next": "logic_past" },
                    { "label": "Ich bin neugierig", "next": "solution_lottery" }
                ],
                "visual": "breathe",
                "phase": "solution"
            },
            
            "solution_direct": {
                "text": "Direkte Demokratie. Wie in der Schweiz. Mehr Volksentscheide. Aber: Funktioniert das in einem Land von 83 Millionen? Oder führt es zu einer Diktatur der Aktivsten? Zu Plattformen, die alle manipulieren?",
                "options": [
                    { "label": "Das ist das Problem", "next": "logic_direct_problems" },
                    { "label": "Es funktioniert in der Schweiz", "next": "logic_switzerland" },
                    { "label": "Gibt es etwas Besseres?", "next": "solution_lottery" }
                ],
                "visual": "clash",
                "phase": "solution"
            },
            
            "solution_foundation": {
                "text": "Das Fundament. Nicht 'wer regiert'. Sondern: 'Wer entscheidet?' Nicht 'welche Partei'. Sondern: 'Wie kommen Entscheider an die Macht?' Das Fundament ist: Die Auswahl. Wie wählen wir unsere Entscheider aus?",
                "options": [
                    { "label": "Durch Wahlen", "next": "logic_elections_foundation" },
                    { "label": "Durch Los", "next": "solution_lottery" },
                    { "label": "Durch Kompetenz", "next": "logic_meritocracy" }
                ],
                "visual": "reset_to_grid",
                "phase": "solution"
            },
            
            "solution_ancient": {
                "text": "Die Idee aus der Antike. Athen. Die Wiege der Demokratie. Aber nicht unsere Demokratie. Eine andere. Wo nicht gewählt wurde. Wo das Los entschied. Wo jeder Bürger – nicht nur die Reichen – regieren konnte.",
                "options": [
                    { "label": "Das Los? Wie funktionierte das?", "next": "solution_lottery" },
                    { "label": "Nur die Reichen?", "next": "logic_athen_elite" },
                    { "label": "Warum wurde es abgeschafft?", "next": "logic_athen_end" }
                ],
                "visual": "stochastic",
                "phase": "solution"
            },
            
            "solution_crazy": {
                "text": "Verrückt. Ja, das klingt so. Aber: Was ist verrückter? Ein System, bei dem das Los entscheidet – oder ein System, bei dem Milliardäre Politiker kaufen? Was ist wirklich verrückt?",
                "options": [
                    { "label": "Das ist eine gute Frage", "next": "solution_lottery" },
                    { "label": "Beides ist verrückt", "next": "logic_both_crazy" },
                    { "label": "Erklär mir das Los-System", "next": "solution_lottery" }
                ],
                "visual": "stochastic",
                "phase": "solution"
            },
            
            // ═══════════════════════════════════════════════════════════════
            // PHASE 4: DIE Losdemokratie (Sortition - Die Lösung)
            // ═══════════════════════════════════════════════════════════════
            
            "solution_lottery": {
                "text": "Sortition. Das Los. Klingt absurd, oder? Aber höre zu: In Athen, der Geburtsstätte der Demokratie, wurden die meisten Ämter nicht gewählt. Sie wurden verlost. Jeder Bürger konnte regieren. Nicht nur die Berufspolitiker. Nicht nur die Reichen. Alle.",
                "options": [
                    { "label": "Aber das war vor 2000 Jahren", "next": "lottery_history" },
                    { "label": "Wie soll das heute funktionieren?", "next": "lottery_modern" },
                    { "label": "Das ist interessant", "next": "lottery_interest" }
                ],
                "visual": "stochastic",
                "phase": "lottery"
            },
            
            "lottery_history": {
                "text": "Vor 2000 Jahren. Ja. Aber: Warum funktionierte es? Weil es fair war. Weil es nicht auf Geld oder Rhetorik ankam. Weil es wirklich 'Volksherrschaft' bedeutete – nicht 'Wahlherrschaft'. Und es funktionierte 200 Jahre. Länger als die meisten modernen Systeme.",
                "options": [
                    { "label": "Aber warum wurde es abgeschafft?", "next": "lottery_end" },
                    { "label": "Wie genau funktionierte es?", "next": "lottery_mechanics" },
                    { "label": "Könnte es heute funktionieren?", "next": "lottery_modern" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_modern": {
                "text": "Heute. Mit 83 Millionen Menschen. Mit moderner Technologie. Stell dir vor: Ein Bürgerrat. 500 Menschen. Per Los ausgewählt. Alle Altersgruppen. Alle Regionen. Alle Bildungsstände. Wie das Volk wirklich ist. Nicht wie die Politiker denken, dass es sein sollte.",
                "options": [
                    { "label": "500 Menschen für ganz Deutschland?", "next": "lottery_scale" },
                    { "label": "Werden die nicht manipuliert?", "next": "lottery_manipulation" },
                    { "label": "Haben die genug Wissen?", "next": "lottery_knowledge" }
                ],
                "visual": "reset_to_grid",
                "phase": "lottery"
            },
            
            "lottery_interest": {
                "text": "Interesse. Das ist der Anfang. Denn: Sortition ist nicht nur Geschichte. Es passiert jetzt. In Irland. In Frankreich. In Belgien. Bürgerräte werden verlost. Und sie funktionieren. Sie kommen zu besseren Entscheidungen als gewählte Politiker.",
                "options": [
                    { "label": "Erzähl mir von Irland", "next": "lottery_ireland" },
                    { "label": "Warum funktionieren sie besser?", "next": "lottery_better" },
                    { "label": "Könnte das die Lösung sein?", "next": "lottery_solution" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_end": {
                "text": "Abgeschafft. Ja. Aber nicht, weil es nicht funktionierte. Es wurde abgeschafft, weil die Mächtigen es hassten. Weil sie ihre Macht verloren. Weil das Volk tatsächlich herrschte. Nicht nur wählte. Es wurde von außen zerstört – nicht von innen.",
                "options": [
                    { "label": "Von wem wurde es zerstört?", "next": "lottery_destroyed" },
                    { "label": "Das ist eine Behauptung", "next": "lottery_evidence" },
                    { "label": "Könnte das heute passieren?", "next": "lottery_today_threat" }
                ],
                "visual": "pyramid_dissolve",
                "phase": "lottery"
            },
            
            "lottery_mechanics": {
                "text": "Die Mechanik. Einfach. Ein Los-Verfahren. Wie bei der Jury-Pflicht in den USA. Du bekommst einen Brief: 'Sie wurden ausgewählt.' Ein Jahr. Bezahlt. Mit Unterstützung. Mit Experten. Dann zurück zum normalen Leben. Keine Karriere. Keine Abhängigkeit. Reiner Dienst.",
                "options": [
                    { "label": "Nur ein Jahr?", "next": "lottery_term" },
                    { "label": "Was, wenn ich ablehne?", "next": "lottery_refuse" },
                    { "label": "Wer unterstützt sie?", "next": "lottery_support" }
                ],
                "visual": "reset_to_grid",
                "phase": "lottery"
            },
            
            "lottery_scale": {
                "text": "500 für 83 Millionen. Klingt wenig. Aber: Statistisch repräsentativ. Wie eine Umfrage – aber mit echter Macht. Und: Es könnten mehr sein. 1000. Oder: Regionale Räte. Kommunale Räte. Ein System von Räten. Nicht eine zentrale Elite.",
                "options": [
                    { "label": "Wie wird Repräsentativität sichergestellt?", "next": "lottery_representation" },
                    { "label": "Was ist mit der Bundesregierung?", "next": "lottery_federal" },
                    { "label": "Könnte das funktionieren?", "next": "lottery_work" }
                ],
                "visual": "reset_to_grid",
                "phase": "lottery"
            },
            
            "lottery_manipulation": {
                "text": "Manipulation. Die große Angst. Aber: Weniger manipulierbar als gewählte Politiker. Warum? Weil sie keine Wiederwahl brauchen. Keine Partei. Keine Spenden. Ein Jahr. Dann zurück ins Leben. Wer will sie kaufen – und warum?",
                "options": [
                    { "label": "Lobbyisten", "next": "lottery_lobby" },
                    { "label": "Medien", "next": "lottery_media" },
                    { "label": "Es gibt immer Wege", "next": "lottery_always_ways" }
                ],
                "visual": "clash",
                "phase": "lottery"
            },
            
            "lottery_knowledge": {
                "text": "Wissen. Die berechtigte Sorge. Aber: Sind gewählte Politiker heuteexperter? Oder nur besser im Reden? Ein Bürgerrat hätte: Zeit. Experten. Information. Keine Angst vor Wiederwahl. Sie könnten tatsächlich verstehen, was sie entscheiden.",
                "options": [
                    { "label": "Experten können auch lügen", "next": "lottery_experts_lie" },
                    { "label": "Politiker haben auch Experten", "next": "lottery_politician_experts" },
                    { "label": "Das ist ein gutes Argument", "next": "lottery_agree" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_ireland": {
                "text": "Irland. 2016. Eine verfassungsgebende Versammlung. Per Los ausgewählt. 99 Bürger. 18 Monate. Sie entschieden über Abtreibung. Über Ehe für alle. Themen, die Politiker Jahrzehnte verschoben hatten. Die Bürger entschieden – und es funktionierte.",
                "options": [
                    { "label": "Wie entschieden sie?", "next": "lottery_ireland_result" },
                    { "label": "War das wirklich demokratisch?", "next": "lottery_ireland_democratic" },
                    { "label": "Gibt es weitere Beispiele?", "next": "lottery_examples" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_better": {
                "text": "Warum besser? Drei Gründe: 1. Keine Wiederwahl-Angst. Sie können unpopuläre Wahrheiten sagen. 2. Keine Partei-Disziplin. Sie können tatsächlich diskutieren. 3. Sie repräsentieren das Volk – nicht die Aktivisten, nicht die Spender. Das wirkliche Volk.",
                "options": [
                    { "label": "Aber was ist mit der Legitimation?", "next": "lottery_legitimacy" },
                    { "label": "Könnten sie radikale Dinge tun?", "next": "lottery_radical" },
                    { "label": "Das macht Sinn", "next": "lottery_agree" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_solution": {
                "text": "Die Lösung? Möglicherweise. Es löst die grundlegenden Probleme: Keine Karriere-Politik. Keine Lobby-Kontrolle. Wahre Repräsentation. Aber: Es ist nicht perfekt. Nichts ist perfekt. Es ist nur... besser?",
                "options": [
                    { "label": "Besser als was wir haben?", "next": "lottery_comparison" },
                    { "label": "Was sind die Nachteile?", "next": "lottery_drawbacks" },
                    { "label": "Wie kämen wir dahin?", "next": "lottery_path" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_term": {
                "text": "Nur ein Jahr. Ja. Warum? Weil länger Korruption ermöglicht. Weil Politik kein Beruf sein sollte. Weil du nach einem Jahr zurück ins Leben gehst. Zurück zu deinem Job. Deiner Familie. Du bleibst ein normaler Mensch – kein Berufspolitiker.",
                "options": [
                    { "label": "Was, wenn sie das nicht wollen?", "next": "lottery_unwilling" },
                    { "label": "Ist ein Jahr genug Zeit?", "next": "lottery_time" },
                    { "label": "Das ist vernünftig", "next": "lottery_agree" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_refuse": {
                "text": "Ablehnen. Das Recht eines jeden. Aber: Was, wenn alle ablehnen? Dann würden neue gelost. Und nochmal. Bis sich genug finden. Oder: Es könnte wie Jury-Pflicht sein – eine Bürgerpflicht. Mit Entschädigung. Mit Schutz.",
                "options": [
                    { "label": "Eine Pflicht klingt hart", "next": "lottery_duty" },
                    { "label": "Wie in der Schweiz mit der Armee", "next": "lottery_switzerland_duty" },
                    { "label": "Das könnte funktionieren", "next": "lottery_agree" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_support": {
                "text": "Unterstützung. Das ist entscheidend. Nicht allein lassen. Ein Team: Rechtsexperten. Wissenschaftler. Verwaltungsfachleute. Sie beraten, aber entscheiden nicht. Die Bürger entscheiden. Informiert. Unterstützt. Aber frei.",
                "options": [
                    { "label": "Könnten Experten manipulieren?", "next": "lottery_expert_manipulation" },
                    { "label": "Wer wählt die Experten?", "next": "lottery_expert_selection" },
                    { "label": "Das ist ein gutes System", "next": "lottery_agree" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_representation": {
                "text": "Repräsentativität. Statistisch. Wie bei Umfragen. Quoten nach Alter, Geschlecht, Region, Bildung. Nicht perfekt – aber besser als heute. Heute: 50% Akademiker im Parlament bei 20% in der Bevölkerung. Ist das Repräsentation?",
                "options": [
                    { "label": "Nein, das ist keine Repräsentation", "next": "lottery_agree" },
                    { "label": "Aber Akademiker sind kompetenter", "next": "lottery_competence" },
                    { "label": "Wie wären die Quoten beim Los?", "next": "lottery_quotas" }
                ],
                "visual": "reset_to_grid",
                "phase": "lottery"
            },
            
            "lottery_work": {
                "text": "Könnte es funktionieren? Es funktioniert. Jetzt. In anderen Ländern. Für konkrete Entscheidungen. Die Frage ist nicht: Funktioniert es? Die Frage ist: Wagen wir es? Wagen wir, Macht abzugeben? An das Volk?",
                "options": [
                    { "label": "Die Macht liegt beim Volk", "next": "lottery_sovereignty" },
                    { "label": "Ich habe Angst vor dem Chaos", "next": "lottery_chaos_fear" },
                    { "label": "Wir sollten es versuchen", "next": "lottery_try" }
                ],
                "visual": "stochastic",
                "phase": "lottery"
            },
            
            "lottery_drawbacks": {
                "text": "Nachteile. Klar. Es ist neu. Unbekannt. Menschen fürchten das Ungewisse. Es braucht Bildung. Erklärung. Zeit. Und: Es könnte scheitern. Aber: Was, wenn es funktioniert? Was, wenn es besser ist?",
                "options": [
                    { "label": "Wir sollten es testen", "next": "lottery_pilot" },
                    { "label": "Was ist das schlimmste Szenario?", "next": "lottery_worst_case" },
                    { "label": "Ich bin überzeugt", "next": "lottery_convinced" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_path": {
                "text": "Der Weg dahin. Nicht Revolution. Evolution. Ein Pilotprojekt. Eine Stadt. Ein Jahr. Echter Test. Dann: Bewerten. Skalieren. Oder: Stoppen. Wissenschaftlich. Rational. Ohne Ideologie.",
                "options": [
                    { "label": "Welche Stadt?", "next": "lottery_city" },
                    { "label": "Wie würde der Test aussehen?", "next": "lottery_pilot_design" },
                    { "label": "Ich unterstütze das", "next": "lottery_support_action" }
                ],
                "visual": "stochastic",
                "phase": "lottery"
            },
            
            "lottery_agree": {
                "text": "Du siehst es. Die Logik. Nicht emotionale Überzeugung. Nicht ideologischer Zwang. Nur: Wenn das System nicht funktioniert, und ein anderes System funktioniert – warum nicht wechseln? Ist das nicht... rational?",
                "options": [
                    { "label": "Es ist rational", "next": "lottery_rational" },
                    { "label": "Aber Politik ist nicht rational", "next": "lottery_politics_emotional" },
                    { "label": "Ich möchte mehr wissen", "next": "vault" }
                ],
                "visual": "breathe",
                "phase": "lottery"
            },
            
            "lottery_convinced": {
                "text": "Überzeugt. Oder zumindest neugierig genug, um mehr zu wollen. Das ist alles, was wir fragen. Nicht Glauben. Nur: Offenheit. Bereitschaft, zu lernen. Zu testen. Zu denken.",
                "options": [
                    { "label": "Ich will mehr lernen", "next": "vault" },
                    { "label": "Ich will mitmachen", "next": "action_join" },
                    { "label": "Ich will darüber sprechen", "next": "action_talk" }
                ],
                "visual": "reset_to_grid",
                "phase": "lottery"
            },
            
            "lottery_try": {
                "text": "Versuchen. Der erste Schritt. Nicht alles ändern. Nur testen. Ein Experiment. Wissenschaftlich. Mit Ausstiegsklausel. Wenn es nicht funktioniert – zurück zum Alten. Aber: Was, wenn es funktioniert?",
                "options": [
                    { "label": "Dann skalieren wir", "next": "lottery_scale_up" },
                    { "label": "Dann haben wir eine Chance", "next": "lottery_chance" },
                    { "label": "Erstmal testen", "next": "lottery_pilot" }
                ],
                "visual": "stochastic",
                "phase": "lottery"
            },
            
            "lottery_rational": {
                "text": "Rational. Das höchste Lob. Denn in einer Welt der Emotionen, der Manipulation, der Lügen – ist Rationalität revolutionär. Du hast nicht geglaubt. Du hast gedacht. Das ist der Anfang jeder echten Veränderung.",
                "options": [
                    { "label": "Was jetzt?", "next": "action_now" },
                    { "label": "Ich möchte mehr wissen", "next": "vault" },
                    { "label": "Ich bin bereit zu handeln", "next": "action_join" }
                ],
                "visual": "reset_to_grid",
                "phase": "lottery"
            },
            
            // ═══════════════════════════════════════════════════════════════
            // PHASE 5: AKTION (Was tun?)
            // ═══════════════════════════════════════════════════════════════
            
            "action_now": {
                "text": "Was jetzt? Du hast den Weg gegangen. Von den Problemen zur Lösung. Nicht überzeugt. Nur: Informiert. Was tust du mit dieser Information?",
                "options": [
                    { "label": "Ich will mehr lernen", "next": "vault" },
                    { "label": "Ich will mit anderen sprechen", "next": "action_talk" },
                    { "label": "Ich will handeln", "next": "action_join" }
                ],
                "visual": "reset_to_grid",
                "phase": "action"
            },
            
            "action_talk": {
                "text": "Sprechen. Das ist wichtiger als du denkst. Ideen verbreiten sich durch Gespräche. Nicht durch Medien. Durch Menschen. Durch dich. Erzähle es jemandem. Einer Person. Das reicht.",
                "options": [
                    { "label": "Wem soll ich erzählen?", "next": "action_who" },
                    { "label": "Was soll ich sagen?", "next": "action_what" },
                    { "label": "Ich werde es teilen", "next": "action_share" }
                ],
                "visual": "breathe",
                "phase": "action"
            },
            
            "action_join": {
                "text": "Handeln. Die nächste Ebene. Aber: Was bedeutet Handeln? Revolution? Nein. Evolution. Informieren. Diskutieren. Unterstützen. Jeder kann helfen. Jeder Schritt zählt.",
                "options": [
                    { "label": "Wie kann ich unterstützen?", "next": "action_support" },
                    { "label": "Gibt es eine Organisation?", "next": "action_organization" },
                    { "label": "Ich will spenden", "next": "action_donate" }
                ],
                "visual": "reset_to_grid",
                "phase": "action"
            },
            
            "action_share": {
                "text": "Teilen. Einfach. Aber mächtig. Jede Person, die davon erfährt, ist ein potenzieller Mitdenker. Ein potenzieller Unterstützer. Ein potenzieller Veränderer. Teile den Link. Erzähle die Geschichte.",
                "options": [
                    { "label": "Link kopieren", "next": "action_copy_link" },
                    { "label": "Social Media", "next": "action_social" },
                    { "label": "Ich erzähle persönlich", "next": "action_personal" }
                ],
                "visual": "breathe",
                "phase": "action"
            },
            
            "vault": {
                "text": "Der Vault. Unsere Wissens-Sammlung. Nicht alles. Aber ein Anfang. Studien. Geschichte. Argumente. Gegenargumente. Alles, was du brauchst, um selbst zu entscheiden.",
                "options": [
                    { "label": "Geschichte der Demokratie", "next": "vault_history" },
                    { "label": "Studien zu Sortition", "next": "vault_studies" },
                    { "label": "Argumente für und gegen", "next": "vault_arguments" },
                    { "label": "Zurück zum Dialog", "next": "start" }
                ],
                "visual": "reset_to_grid",
                "phase": "vault"
            },
            
            // Redirects für unvollständige Pfade
            "lottery_destroyed": { "redirect": "lottery_end" },
            "lottery_evidence": { "redirect": "lottery_history" },
            "lottery_today_threat": { "redirect": "lottery_modern" },
            "lottery_lobby": { "redirect": "lottery_manipulation" },
            "lottery_media": { "redirect": "lottery_manipulation" },
            "lottery_always_ways": { "redirect": "lottery_drawbacks" },
            "lottery_experts_lie": { "redirect": "lottery_drawbacks" },
            "lottery_politician_experts": { "redirect": "lottery_better" },
            "lottery_ireland_result": { "redirect": "lottery_ireland" },
            "lottery_ireland_democratic": { "redirect": "lottery_legitimacy" },
            "lottery_examples": { "redirect": "lottery_modern" },
            "lottery_legitimacy": { "redirect": "lottery_better" },
            "lottery_radical": { "redirect": "lottery_drawbacks" },
            "lottery_comparison": { "redirect": "lottery_solution" },
            "lottery_unwilling": { "redirect": "lottery_refuse" },
            "lottery_time": { "redirect": "lottery_term" },
            "lottery_duty": { "redirect": "lottery_refuse" },
            "lottery_switzerland_duty": { "redirect": "lottery_refuse" },
            "lottery_expert_manipulation": { "redirect": "lottery_drawbacks" },
            "lottery_expert_selection": { "redirect": "lottery_support" },
            "lottery_competence": { "redirect": "lottery_knowledge" },
            "lottery_quotas": { "redirect": "lottery_representation" },
            "lottery_federal": { "redirect": "lottery_scale" },
            "lottery_sovereignty": { "redirect": "lottery_work" },
            "lottery_chaos_fear": { "redirect": "lottery_drawbacks" },
            "lottery_pilot": { "redirect": "lottery_path" },
            "lottery_worst_case": { "redirect": "lottery_drawbacks" },
            "lottery_city": { "redirect": "lottery_path" },
            "lottery_pilot_design": { "redirect": "lottery_path" },
            "lottery_support_action": { "redirect": "action_join" },
            "lottery_politics_emotional": { "redirect": "lottery_agree" },
            "lottery_scale_up": { "redirect": "lottery_path" },
            "lottery_chance": { "redirect": "lottery_try" },
            "action_who": { "redirect": "action_talk" },
            "action_what": { "redirect": "action_talk" },
            "action_copy_link": { "redirect": "action_share" },
            "action_social": { "redirect": "action_share" },
            "action_personal": { "redirect": "action_share" },
            "action_support": { "redirect": "action_join" },
            "action_organization": { "redirect": "action_join" },
            "action_donate": { "redirect": "action_join" },
            "vault_history": { "redirect": "vault" },
            "vault_studies": { "redirect": "vault" },
            "vault_arguments": { "redirect": "vault" },
            "perspective_elite": { "redirect": "problem_entry" },
            "perspective_informed": { "redirect": "problem_voice_yes" },
            "perspective_different": { "redirect": "exit_understanding" },
            "fear_already_here": { "redirect": "fear_authoritarian_new" },
            "fear_partial": { "redirect": "fear_unknown" },
            "fear_ai": { "redirect": "fear_fundamental_new" },
            "fear_climate": { "redirect": "fear_fundamental_new" },
            "fear_techno_feudal": { "redirect": "fear_fundamental_new" },
            "fear_no_control": { "redirect": "fear_institutions" },
            "fear_pattern": { "redirect": "fear_fascism_yes" },
            "logic_subjective": { "redirect": "logic_uncertain" },
            "logic_distance": { "redirect": "fear_denial" },
            "logic_people_control": { "redirect": "fear_democracy_protection" },
            "logic_paranoia": { "redirect": "fear_denial" },
            "logic_germany_special": { "redirect": "fear_constitution" },
            "logic_paper_weak": { "redirect": "fear_nothing_safe" },
            "logic_paradox": { "redirect": "fear_democracy_protection" },
            "logic_defense": { "redirect": "fear_democracy_protection" },
            "logic_social_media": { "redirect": "fear_social_decay" },
            "logic_collective_guilt": { "redirect": "fear_social_decay" },
            "logic_conserve_what": { "redirect": "logic_principle" },
            "logic_possible": { "redirect": "logic_question" },
            "logic_dreams": { "redirect": "logic_vision_unrealistic" },
            "logic_sokrates": { "redirect": "logic_democracy_origin" },
            "logic_democracy_origin": { "redirect": "solution_ancient" },
            "logic_relevance": { "redirect": "solution_lottery" },
            "logic_both_factors": { "redirect": "problem_system_deep" },
            "logic_humans_bad": { "redirect": "logic_filter" },
            "logic_utopia": { "redirect": "solution_search" },
            "logic_exceptions_enough": { "redirect": "exit_conservative" },
            "logic_impossible": { "redirect": "logic_possible" },
            "logic_people_power": { "redirect": "logic_energiewende" },
            "logic_government_reaction": { "redirect": "logic_democracy_origin" },
            "logic_both_driven": { "redirect": "logic_people_power" },
            "logic_resignation_masked": { "redirect": "logic_realism" },
            "logic_realism": { "redirect": "solution_search" },
            "logic_structures_power": { "redirect": "problem_system_deep" },
            "logic_evil_people": { "redirect": "logic_corruption" },
            "logic_semantics": { "redirect": "problem_system_deep" },
            "logic_fire": { "redirect": "solution_search" },
            "logic_observe": { "redirect": "logic_wait" },
            "logic_analogy_bad": { "redirect": "problem_system_deep" },
            "logic_repair": { "redirect": "solution_search" },
            "logic_not_car": { "redirect": "logic_sometimes" },
            "logic_no_better": { "redirect": "solution_search" },
            "logic_wait": { "redirect": "exit_conservative" },
            "logic_stay_uncertain": { "redirect": "exit_respectful" },
            "logic_uncertain_alternative": { "redirect": "solution_search" },
            "logic_doors": { "redirect": "solution_search" },
            "logic_practical": { "redirect": "problem_entry" },
            "logic_principle_worthless": { "redirect": "solution_search" },
            "logic_principle_important": { "redirect": "logic_implementation" },
            "logic_both_needed": { "redirect": "solution_search" },
            "logic_idea_only": { "redirect": "solution_search" },
            "logic_still_principle": { "redirect": "logic_both" },
            "logic_never_worked": { "redirect": "solution_search" },
            "logic_pessimism": { "redirect": "solution_search" },
            "logic_only_simulation": { "redirect": "solution_lottery" },
            "logic_small_groups": { "redirect": "solution_direct" },
            "logic_antiquity": { "redirect": "solution_ancient" },
            "logic_people_disempowered": { "redirect": "problem_voice_yes" },
            "logic_necessary": { "redirect": "logic_adaptation" },
            "logic_both_sides": { "redirect": "vault" },
            "logic_history": { "redirect": "vault_history" },
            "logic_cycle": { "redirect": "problem_vote_cycle" },
            "logic_hope": { "redirect": "logic_next_election" },
            "logic_wende": { "redirect": "logic_protest" },
            "logic_fridays": { "redirect": "logic_protest" },
            "logic_ignored": { "redirect": "logic_protest" },
            "logic_analogy": { "redirect": "logic_election_system" },
            "logic_politics_different": { "redirect": "solution_search" },
            "logic_people_rights": { "redirect": "logic_rights_fight" },
            "logic_government_rights": { "redirect": "fear_institutions" },
            "logic_rights_fight": { "redirect": "solution_search" },
            "logic_anger": { "redirect": "problem_anger" },
            "logic_tone": { "redirect": "problem_acceptance" },
            "logic_cynic": { "redirect": "problem_acceptance" },
            "logic_small_reforms": { "redirect": "logic_repair" },
            "logic_radical": { "redirect": "solution_search" },
            "logic_past": { "redirect": "lottery_history" },
            "logic_elections_foundation": { "redirect": "problem_vote_cycle" },
            "logic_meritocracy": { "redirect": "lottery_knowledge" },
            "logic_athen_elite": { "redirect": "lottery_history" },
            "logic_athen_end": { "redirect": "lottery_end" },
            "logic_both_crazy": { "redirect": "lottery_modern" },
            "logic_politician_powerless": { "redirect": "problem_career" },
            "logic_complex": { "redirect": "problem_system_partial" },
            "logic_elite_power": { "redirect": "problem_elite_check" },
            "logic_war_complex": { "redirect": "fear_war" },
            "logic_democracy_peace": { "redirect": "fear_democracy_protection" },
            "logic_experience": { "redirect": "problem_voice_yes" },
            "logic_observation": { "redirect": "problem_voice_yes" },
            "logic_same_result": { "redirect": "problem_vote_cycle" },
            "logic_sometimes_different": { "redirect": "logic_next_election" },
            "logic_engagement_limited": { "redirect": "problem_engage" },
            "logic_engagement_works": { "redirect": "exit_understanding" },
            "logic_no_alternative": { "redirect": "solution_search" },
            "balance_progress_challenge": { "redirect": "problem_entry" },
            "balance_frustration_validate": { "redirect": "problem_entry" },
            "balance_complexity_trap": { "redirect": "problem_entry" },
            "balance_agency_restore": { "redirect": "problem_entry" },
            "balance_overwhelm_address": { "redirect": "problem_entry" },
            "balance_emotional_protect": { "redirect": "problem_entry" },
            "profiling_skeptic_system": { "redirect": "problem_structure" },
            "profiling_skeptic_trust": { "redirect": "problem_entry_skeptic" },
            "profiling_skeptic_agency": { "redirect": "problem_resignation" },
            "profiling_value_avoidant": { "redirect": "problem_entry" },
            "logic_direct_problems": { "redirect": "solution_direct" },
            "logic_liquid": { "redirect": "solution_direct" },
            "logic_people_defense": { "redirect": "fear_constitution" },
            "logic_risk": { "redirect": "lottery_drawbacks" },
            "logic_switzerland": { "redirect": "solution_direct" },
            "problem_elite_power": { "redirect": "problem_elite_check" },
            "solution_filter_reverse": { "redirect": "solution_lottery" },
            "solution_new_system": { "redirect": "solution_system" }
        };
            
            // ==================================================================
        // SECTION 2: STORAGE & PERSISTENCE
        // ==================================================================
        
        const Storage = {
            /**
             * Save current session to localStorage
             * @param {string} currentStep - Current narrative step
             * @param {string[]} history - Navigation history
             */
            save(currentStep, history) {
                const data = {
                    currentStep,
                    history,
                    timestamp: Date.now(),
                    date: new Date().toLocaleString('de-DE')
                };
                try {
                    localStorage.setItem(ISONOMIA.storageKey, JSON.stringify(data));
                } catch (e) {
                    console.warn('[ISONOMIA] Could not save session:', e);
                }
            },

            /**
             * Load session from localStorage
             * @returns {Object|null} Saved session or null
             */
            load() {
                try {
                    const raw = localStorage.getItem(ISONOMIA.storageKey);
                    return raw ? JSON.parse(raw) : null;
                } catch (e) {
                    console.warn('[ISONOMIA] Could not load session:', e);
                    return null;
                }
            },

            /**
             * Clear saved session
             */
            clear() {
                try {
                    localStorage.removeItem(ISONOMIA.storageKey);
                } catch (e) {
                    console.warn('[ISONOMIA] Could not clear session:', e);
                }
            },

            /**
             * Check if there's a valid saved session
             * @returns {boolean}
             */
            hasSession() {
                const data = this.load();
                return data !== null && data.currentStep && data.currentStep !== 'start';
            }
        };

        // ==================================================================
        // SECTION 3: APPLICATION STATE & CONTROLLER
        // ==================================================================

        const ISONOMIA = {
            /** @type {HTMLElement[]} Array of particle DOM elements */
            dots: [],
            
            /** @type {number} Total number of particles */
            dotCount: 180,
            
            /** @type {string[]} Navigation history stack */
            history: [],
            
            /** @type {string} Storage key for localStorage */
            storageKey: 'isonomia_session',

            /**
             * Initialize the application
             * - Checks for saved session
             * - Creates particle elements
             * - Sets up browser history lock
             */
            init() {
                this._createParticles();
                this._setupHistoryLock();
                this._setupKeyboardShortcuts();
                this._setupResizeHandler();
                ParticleInteraction.init(this.dots);
                this._setupAudioInit();
                this._logWelcome();
                
                // Check for URL parameter first (shared link)
                const sharedStep = ShareFeature.checkUrlParameter();
                if (sharedStep) {
                    this.history.push(sharedStep);
                    this.transition(sharedStep, false);
                    return;
                }
                
                // Check for saved session
                if (Storage.hasSession()) {
                    this._showRestoreDialog();
                } else {
                    this.transition('start');
                }
            },

            /**
             * Show dialog to restore or reset saved session
             * @private
             */
            _showRestoreDialog() {
                const data = Storage.load();
                const ui = document.getElementById('content-layer');
                
                ui.innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Sitzung wiederherstellen">
                        <h1>Willkommen zurück.</h1>
                        <p style="color: var(--dim-text); margin-bottom: 3rem;">
                            Du hast eine Sitzung vom <strong style="color: var(--cyan);">${data.date}</strong>.<br>
                            Möchtest du fortfahren oder neu beginnen?
                        </p>
                        <div class="button-group">
                            <button class="haptic-btn" onclick="ISONOMIA.restoreSession()" aria-label="Gespeicherte Sitzung fortsetzen">
                                Fortfahren
                            </button>
                            <button class="haptic-btn" onclick="ISONOMIA.clearSession()" aria-label="Neue Sitzung starten">
                                Neu starten
                            </button>
                        </div>
                    </div>`;
                
                this.applyVisualMode('breathe');
            },

            /**
             * Restore saved session
             */
            restoreSession() {
                const data = Storage.load();
                if (data && data.history && data.history.length > 0) {
                    this.history = data.history;
                    const currentStep = data.currentStep || data.history[data.history.length - 1];
                    this.transition(currentStep, false);
                } else {
                    this.transition('start');
                }
            },

            /**
             * Clear saved session and start fresh
             */
            clearSession() {
                Storage.clear();
                this.history = [];
                this.transition('start');
            },

            /**
             * Create DOM elements for particle system
             * @private
             */
            _createParticles() {
                const container = document.getElementById('particle-container');
                const fragment = document.createDocumentFragment();
                
                for (let i = 0; i < this.dotCount; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    fragment.appendChild(dot);
                    this.dots.push(dot);
                }
                
                container.appendChild(fragment);
            },

            /**
             * Prevent browser back navigation (unidirectional flow)
             * @private
             */
            _setupHistoryLock() {
                window.history.pushState(null, "", window.location.href);
                window.onpopstate = () => window.history.pushState(null, "", window.location.href);
            },

            /**
             * Setup keyboard shortcuts
             * - ESC: Go back (if possible)
             * @private
             */
            _setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.history.length > 1) {
                        this.goBack();
                    }
                });
            },

            /**
             * Handle window resize - reposition particles if needed
             * @private
             */
            _setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        console.log('[ISONOMIA] Viewport resized');
                    }, 250);
                });
            },

            /**
             * Setup audio initialization on first user interaction
             * @private
             */
            _setupAudioInit() {
                const initAudio = () => {
                    AmbientAudio.init();
                    document.removeEventListener('click', initAudio);
                    document.removeEventListener('keydown', initAudio);
                };
                document.addEventListener('click', initAudio, { once: true });
                document.addEventListener('keydown', initAudio, { once: true });
            },

            /**
             * Navigate to a narrative node
             * @param {string} stepKey - Target node identifier
             * @param {boolean} addToHistory - Whether to add to navigation history
             * @param {Object} optionData - Data from the selected option (profile updates, etc.)
             */
            transition(stepKey, addToHistory = true, optionData = null) {
                // Handle redirect nodes
                if (narrativeData[stepKey]?.redirect) {
                    stepKey = narrativeData[stepKey].redirect;
                }
                
                // Handle special 'vault' step first (not in narrativeData)
                if (stepKey === 'vault') {
                    if (addToHistory && this.history[this.history.length - 1] !== stepKey) {
                        this.history.push(stepKey);
                    }
                    Storage.save(stepKey, this.history);
                    // 3D Navigation zum Vault
                    if (ISONOMIA3D.scene) {
                        ISONOMIA3D.navigateToNode('vault');
                    }
                    return this.showVault();
                }
                
                const data = narrativeData[stepKey];
                if (!data) {
                    console.error(`Unknown step: ${stepKey}`);
                    return;
                }

                if (addToHistory && this.history[this.history.length - 1] !== stepKey) {
                    this.history.push(stepKey);
                }
                
                // Record in UserProfile
                UserProfile.recordNodeVisit(stepKey);
                
                // Process option data (profile updates, commitments)
                if (optionData) {
                    this._processOptionData(optionData);
                }
                
                // Handle dynamic objection nodes
                if (data.dynamic && data.objectionType) {
                    const objectionResponse = ObjectionHandler.getResponse(
                        data.objectionType, 
                        UserProfile
                    );
                    if (objectionResponse) {
                        data._dynamicText = objectionResponse;
                        UserProfile.resolveObjection(data.objectionType);
                    }
                }
                
                // Handle personalized text
                if (data.personalized) {
                    data._personalizedText = this._personalizeText(data.text);
                }
                
                // Auto-save session
                Storage.save(stepKey, this.history);

                // 3D Navigation: Kamera zu narrativer Station
                if (ISONOMIA3D.scene) {
                    ISONOMIA3D.navigateToNode(stepKey);
                }

                const ui = document.getElementById('content-layer');
                const tl = anime.createTimeline({ defaults: { ease: 'easeInOutQuad' } });
                tl.add(ui, {
                    opacity: 0,
                    y: -20,
                    duration: 600,
                    onComplete: () => {
                        this.renderContent(data, stepKey);
                        // 3D übernimmt Partikel-Animation, nur Audio/Visual-State setzen
                        if (!ISONOMIA3D.scene) {
                            this.applyVisualMode(data.visual);
                        } else {
                            // Setze 3D Partikel-Modus
                            ISONOMIA3D.setParticleMode(data.visual);
                            // Spiele trotzdem Audio
                            AmbientAudio.playMode(data.visual);
                            this._triggerHapticForMode(data.visual);
                        }
                    }
                }, 0);
                tl.add(ui, {
                    opacity: 1,
                    y: 0,
                    duration: 800
                }, '>');
            },
            
            /**
             * Process option data for profile updates and commitments
             * @private
             */
            _processOptionData(optionData) {
                // Update profile attributes
                if (optionData.profileSet) {
                    Object.entries(optionData.profileSet).forEach(([key, value]) => {
                        UserProfile.set(key, value);
                    });
                }
                
                // Record commitment
                if (optionData.commitment) {
                    UserProfile.addCommitment(
                        this.history[this.history.length - 1] || 'start',
                        true,
                        optionData.label || ''
                    );
                }
                
                // Record objection
                if (optionData.objection) {
                    UserProfile.recordObjection(optionData.objection);
                }
            },
            
            /**
             * Personalize text with user profile data
             * @private
             */
            _personalizeText(text) {
                const summary = UserProfile.getSummary();
                return text
                    .replace(/{commitmentCount}/g, summary.commitmentsCount)
                    .replace(/{pathLength}/g, summary.pathLength)
                    .replace(/{timeSpent}/g, summary.timeSpent);
            },

            /**
             * Navigate back to previous node
             */
            goBack() {
                if (this.history.length > 1) {
                    this.history.pop();
                    UserProfile.backtrackCount++;
                    UserProfile._persist();
                    const prevStep = this.history[this.history.length - 1];
                    this.transition(prevStep, false);
                }
            },

            /**
             * Render content for a narrative node with dramatic text animation
             * @param {Object} data - Node data
             * @param {string} stepKey - Current step identifier
             */
            renderContent(data, stepKey) {
                const progress = this.history.length;
                const totalSteps = Object.keys(narrativeData).length;
                const canGoBack = this.history.length > 1;
                
                // Store current step for event delegation
                this._currentStep = stepKey;
                this._currentOptions = data.options;

                // Determine text to display (dynamic, personalized, or static)
                let displayText = data.text;
                if (data._dynamicText) {
                    displayText = data._dynamicText;
                } else if (data._personalizedText) {
                    displayText = data._personalizedText;
                }
                
                // Use sanitizer for all dynamic content
                const safeText = Sanitizer.escapeHtml(displayText);
                
                // Create animated text with character spans
                const animatedText = this._createAnimatedText(safeText);
                
                // Render options with full data attributes for psychological tracking
                const safeOptions = data.options.map((opt, idx) => {
                    const dataAttrs = [];
                    if (opt.profileSet) dataAttrs.push(`data-profile-set='${JSON.stringify(opt.profileSet)}'`);
                    if (opt.commitment) dataAttrs.push('data-commitment="true"');
                    if (opt.objection) dataAttrs.push(`data-objection="${opt.objection}"`);
                    
                    return {
                        label: Sanitizer.escapeHtml(opt.label),
                        next: opt.next,
                        index: idx,
                        dataAttrs: dataAttrs.join(' ')
                    };
                });
                
                // Get profile summary for display
                const profileSummary = UserProfile.getSummary();
                const showCommitmentBar = profileSummary.commitmentScore > 0;

                document.getElementById('content-layer').innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Narrativer Abschnitt">
                        ${showCommitmentBar ? this._renderCommitmentBar(profileSummary) : ''}
                        <h1 class="animated-text">${animatedText}</h1>
                        <div class="button-group" role="group" aria-label="Entscheidungsoptionen" id="options-container">
                            ${safeOptions.map((option) => `
                                <button 
                                    class="haptic-btn nav-button option-btn" 
                                    data-action="transition"
                                    data-target="${option.next}"
                                    data-option-label="${option.label}"
                                    ${option.dataAttrs}
                                    aria-label="Option ${option.index + 1}: ${option.label}">
                                    ${option.label}
                                </button>
                            `).join('')}
                        </div>
                        <div class="nav-row">
                            ${canGoBack 
                                ? `<button class="haptic-btn btn-small nav-button" data-action="back" aria-label="Zum vorherigen Schritt zurück">← Zurück</button>` 
                                : `<button class="haptic-btn btn-small nav-button" data-action="share" aria-label="Diesen Gedanken teilen">↗ Teilen</button>`}
                            <span class="progress-indicator" aria-label="Fortschritt">
                                Schritt ${progress} von ${totalSteps}
                            </span>
                            <button class="haptic-btn btn-small nav-button" data-action="audio" aria-label="Audio ein- oder ausschalten" title="Audio an/aus">
                                🔊
                            </button>
                        </div>
                    </div>`;
                
                // Animate text characters with stagger
                this._animateTextReveal();
                
                // Animate buttons with stagger
                this._animateButtonsReveal();
                
                // Setup event delegation
                this._setupEventDelegation();
            },
            
            /**
             * Create animated text with character spans
             * @private
             */
            _createAnimatedText(text) {
                return text.split('').map((char, i) => {
                    if (char === ' ') {
                        return ' ';
                    }
                    return `<span class="text-char" style="display: inline-block; opacity: 0; transform: translateY(10px);">${char}</span>`;
                }).join('');
            },
            
            /**
             * Animate text characters with dramatic reveal
             * @private
             */
            _animateTextReveal() {
                const chars = document.querySelectorAll('.text-char');
                if (chars.length === 0) return;
                
                anime.animate(chars, {
                    opacity: [0, 1],
                    y: [10, 0],
                    duration: 400,
                    delay: anime.stagger(15, {start: 200}),
                    ease: 'easeOutExpo'
                });
            },
            
            /**
             * Animate buttons with stagger reveal
             * @private
             */
            _animateButtonsReveal() {
                const buttons = document.querySelectorAll('.option-btn');
                if (buttons.length === 0) return;
                
                // Set initial state
                buttons.forEach(btn => {
                    btn.style.opacity = '0';
                    btn.style.transform = 'translateY(20px)';
                });
                
                // Animate in
                anime.animate(buttons, {
                    opacity: [0, 1],
                    y: [20, 0],
                    duration: 600,
                    delay: anime.stagger(100, {start: 500}),
                    ease: 'easeOutElastic(1, .8)'
                });
            },
            
            /**
             * Render commitment progress bar
             * @private
             */
            _renderCommitmentBar(summary) {
                const percentage = Math.min(summary.commitmentScore, 100);
                const commitmentsText = summary.commitmentsCount === 1 
                    ? '1 Zusage' 
                    : `${summary.commitmentsCount} Zusagen`;
                    
                return `
                    <div class="commitment-bar" role="status" aria-label="Commitment-Fortschritt" style="
                        background: rgba(0, 255, 204, 0.1);
                        border: 1px solid var(--cyan);
                        padding: 0.8rem 1.2rem;
                        margin-bottom: 2rem;
                        display: flex;
                        align-items: center;
                        gap: 1rem;
                    ">
                        <div style="
                            width: 100px;
                            height: 4px;
                            background: rgba(0, 255, 204, 0.2);
                            border-radius: 2px;
                            overflow: hidden;
                        ">
                            <div style="
                                width: ${percentage}%;
                                height: 100%;
                                background: var(--cyan);
                                transition: width 0.5s ease;
                            "></div>
                        </div>
                        <span style="
                            font-size: 0.75rem;
                            color: var(--cyan);
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        ">${commitmentsText}</span>
                    </div>
                `;
            },
            
            /**
             * Setup event delegation for navigation buttons
             * @private
             */
            _setupEventDelegation() {
                const container = document.getElementById('content-layer');
                if (!container) return;
                
                // Remove existing listener to prevent duplicates
                if (this._delegatedClickHandler) {
                    container.removeEventListener('click', this._delegatedClickHandler);
                }
                
                this._delegatedClickHandler = (e) => {
                    const button = e.target.closest('.nav-button');
                    if (!button) return;
                    
                    const action = button.dataset.action;
                    
                    switch (action) {
                        case 'transition':
                            const target = button.dataset.target;
                            // Collect option data from data attributes
                            const optionData = {
                                label: button.dataset.optionLabel || ''
                            };
                            if (button.dataset.profileSet) {
                                try {
                                    optionData.profileSet = JSON.parse(button.dataset.profileSet);
                                } catch (e) {
                                    console.warn('Invalid profileSet data');
                                }
                            }
                            if (button.dataset.commitment === 'true') {
                                optionData.commitment = true;
                            }
                            if (button.dataset.objection) {
                                optionData.objection = button.dataset.objection;
                            }
                            
                            if (target) this.transition(target, true, optionData);
                            break;
                        case 'back':
                            this.goBack();
                            break;
                        case 'share':
                            ShareFeature.shareCurrent();
                            break;
                        case 'audio':
                            this.toggleAudio();
                            break;
                    }
                };
                
                container.addEventListener('click', this._delegatedClickHandler);
            },

            /**
             * Show the resource vault (end screen)
             */
            showVault() {
                const ui = document.getElementById('content-layer');
                const patchCount = PatchCounter.getCount();
                
                ui.innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Ressourcen-Vault">
                        <h1>Ressourcen-Vault</h1>
                        <p>Das Kronos-Protokoll: Beweise für den aristokratischen Irrtum.</p>
                        
                        <!-- Social Validation: Patch Counter (Bandwagon Effect) -->
                        <div class="patch-counter" role="status" aria-label="Gemeinschaftlicher Fortschritt">
                            <div class="patch-counter-number" id="patch-counter-display">${patchCount.toLocaleString('de-DE')}</div>
                            <div class="patch-counter-label">Bewusstseinspatches initialisiert</div>
                            <div class="patch-counter-live">
                                <span class="live-indicator" aria-hidden="true"></span>
                                <span>Globale Verbindung aktiv</span>
                            </div>
                        </div>
                        
                        <div class="vault-grid" role="list">
                            ${this._renderVaultItem('Argumentations-Matrix', 'Technische System-Validierung (PDF)')}
                            ${this._renderVaultItem('Das Trugbild der Moderne', 'Analyse der strukturellen Aristokratie')}
                            ${this._renderVaultItem('Bollwerk gegen Faschismus', 'Immunisierung der Verfassung')}
                            ${this._renderVaultItem('Intelligenz-Ideale', 'Kritik des akademischen Ausschlusses')}
                        </div>
                        <div class="simulation-cta" style="margin-top: 2rem; padding: 1.5rem; border: 1px dashed var(--cyan); background: rgba(0, 255, 204, 0.03);">
                            <p style="margin: 0 0 1rem 0; color: var(--dim-text);">Erlebe Isonomie selbst:</p>
                            <button class="haptic-btn" onclick="SystemCheck.start(() => SimulationMode.start())" aria-label="Los-Simulation starten">
                                🎲 Das Los ziehen
                            </button>
                        </div>
                        <div class="nav-row" style="margin-top: 3rem;">
                            <button class="haptic-btn btn-small" onclick="ISONOMIA.clearSession()" aria-label="Gespeicherten Fortschritt löschen">
                                Fortschritt löschen
                            </button>
                            <button class="haptic-btn" onclick="location.reload()" aria-label="Anwendung neu starten">
                                Journey neu starten
                            </button>
                            <button class="haptic-btn btn-small audio-toggle" onclick="ISONOMIA.toggleAudio()" aria-label="Audio ein- oder ausschalten" title="Audio an/aus">
                                🔊
                            </button>
                        </div>
                    </div>`;
                
                // Increment and animate counter for this user
                PatchCounter.increment();
                
                // Animate the counter display
                this._animatePatchCounter(patchCount);
                
                this.applyVisualMode('reset_to_grid');
            },

            /**
             * Animate patch counter increment
             * @private
             */
            _animatePatchCounter(startValue) {
                const display = document.getElementById('patch-counter-display');
                if (!display) return;
                
                const endValue = startValue + 1;
                const duration = 1000;
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function
                    const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                    const current = startValue + (endValue - startValue) * easeOutQuart;
                    
                    display.textContent = Math.floor(current).toLocaleString('de-DE');
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            },

            /**
             * Render a single vault item
             * @private
             */
            _renderVaultItem(title, subtitle) {
                return `
                    <a href="#" class="vault-item" role="listitem" onclick="ISONOMIA._showComingSoon(event)">
                        ${title}
                        <span>${subtitle} — Bald verfügbar</span>
                    </a>`;
            },

            /**
             * Show "coming soon" notice for vault items
             * @private
             */
            _showComingSoon(event) {
                event.preventDefault();
                alert('Ressource in Vorbereitung. Demnächst verfügbar.');
            },

            // ==================================================================
            // SECTION 4: VISUAL MODES (Particle Animations)
            // ==================================================================

            /**
             * Apply a visual animation mode to the particle system
             * @param {string} mode - Animation mode identifier
             */
            applyVisualMode(mode) {
                // Note: anime.remove() doesn't exist in v4 - animations are handled automatically

                const modes = {
                    'breathe': () => this._modeBreathe(),
                    'tremble': () => this._modeTremble(),
                    'chaos': () => this._modeChaos(),
                    'clash': () => this._modeClash(),
                    'pyramid': () => this._modePyramid(false),
                    'pyramid_struggle': () => this._modePyramid(true),
                    'pyramid_dissolve': () => this._modePyramidDissolve(),
                    'stochastic': () => this._modeStochastic(),
                    'reset_to_grid': () => this._modeResetToGrid()
                };

                if (modes[mode]) {
                    modes[mode]();
                    AmbientAudio.playMode(mode);
                    
                    // Trigger haptic feedback for error/conflict states (psychological aversion)
                    this._triggerHapticForMode(mode);
                } else {
                    console.warn(`Unknown visual mode: ${mode}`);
                }
            },

            /**
             * Trigger haptic feedback based on visual mode
             * @private
             */
            _triggerHapticForMode(mode) {
                // Small delay to ensure user is engaged before vibration
                setTimeout(() => {
                    switch (mode) {
                        case 'chaos':
                            HapticFeedback.error();
                            break;
                        case 'clash':
                            HapticFeedback.clash();
                            break;
                        case 'pyramid':
                        case 'pyramid_struggle':
                            HapticFeedback.hierarchy();
                            break;
                        case 'reset_to_grid':
                        case 'stochastic':
                            HapticFeedback.celebrate();
                            break;
                    }
                }, 300);
            },

            /** Gentle breathing animation with Timeline */
            _modeBreathe() {
                // Initial positioning with staggered fade in
                this.dots.forEach((dot, i) => {
                    anime.set(dot, {
                        left: anime.random(0, 100) + 'vw',
                        top: anime.random(0, 100) + 'vh',
                        backgroundColor: '#00FFCC',
                        opacity: 0,
                        scale: 0
                    });
                });
                
                // Create timeline for complex breathing sequence
                const tl = anime.createTimeline({
                    loop: true,
                    alternate: true
                });
                
                tl.add('.dot', {
                    opacity: [0, 0.4],
                    scale: [0, 1],
                    duration: 1000,
                    delay: anime.stagger(20, {grid: [20, 9], from: 'center'}),
                    ease: 'easeOutExpo'
                })
                .add('.dot', {
                    scale: [1, 1.3],
                    opacity: [0.4, 0.6],
                    duration: 2000,
                    delay: anime.stagger(50, {grid: [20, 9], from: 'center'}),
                    ease: 'easeInOutSine'
                }, '-=500');
            },

            /** Subtle vibration with spring physics */
            _modeTremble() {
                // Timeline for tremble with increasing intensity
                const tl = anime.createTimeline({
                    loop: true
                });
                
                tl.add('.dot', {
                    x: () => anime.random(-2, 2),
                    y: () => anime.random(-2, 2),
                    duration: 50,
                    delay: anime.stagger(5),
                    ease: 'linear'
                })
                .add('.dot', {
                    x: () => anime.random(-4, 4),
                    y: () => anime.random(-4, 4),
                    duration: 50,
                    delay: anime.stagger(5),
                    ease: 'linear'
                })
                .add('.dot', {
                    x: 0,
                    y: 0,
                    duration: 300,
                    ease: 'easeOutElastic(1, .5)'
                });
            },

            /** Chaotic dispersion with explosive keyframes */
            _modeChaos() {
                // First, gather in center
                anime.animate('.dot', {
                    left: '50vw',
                    top: '50vh',
                    scale: 0.5,
                    duration: 500,
                    ease: 'easeInExpo',
                    delay: anime.stagger(10)
                });
                
                // Then explode outward with keyframes
                setTimeout(() => {
                    anime.animate('.dot', {
                        x: [
                            { to: anime.random(-10, 10) + 'vw', duration: 200, ease: 'easeOutExpo' },
                            { to: anime.random(-45, 45) + 'vw', duration: 800, ease: 'easeOutElastic(1, .6)' }
                        ],
                        y: [
                            { to: anime.random(-10, 10) + 'vh', duration: 200, ease: 'easeOutExpo' },
                            { to: anime.random(-45, 45) + 'vh', duration: 800, ease: 'easeOutElastic(1, .6)' }
                        ],
                        backgroundColor: [
                            { to: '#00FFCC', duration: 200 },
                            { to: '#FF3366', duration: 600 }
                        ],
                        scale: [
                            { to: 1.5, duration: 200 },
                            { to: 1, duration: 600 }
                        ],
                        delay: anime.stagger(15, {from: 'center'}),
                        duration: 1000
                    });
                }, 600);
            },

            /** Two opposing groups with dramatic clash animation */
            _modeClash() {
                // Timeline for clash sequence
                const tl = anime.createTimeline({});
                
                // Position dots on their sides
                this.dots.forEach((dot, index) => {
                    const isLeft = index % 2 === 0;
                    anime.set(dot, {
                        left: isLeft ? '15vw' : '85vw',
                        top: (50 + (index % 10 - 5) * 5) + 'vh',
                        backgroundColor: isLeft ? '#00FFCC' : '#FF3366'
                    });
                });
                
                // Move toward center (tension)
                tl.add('.dot', {
                    left: (el, i) => i % 2 === 0 ? '35vw' : '65vw',
                    duration: 1500,
                    ease: 'easeInQuad',
                    delay: anime.stagger(20)
                })
                // Clash in center
                .add('.dot', {
                    left: '50vw',
                    scale: [1, 1.8, 1],
                    duration: 300,
                    ease: 'easeOutExpo',
                    delay: anime.stagger(10, {from: 'center'})
                })
                // Bounce back
                .add('.dot', {
                    left: (el, i) => i % 2 === 0 ? '20vw' : '80vw',
                    x: (el, i) => i % 2 === 0 ? -30 : 30,
                    duration: 800,
                    ease: 'easeOutElastic(1, .5)',
                    delay: anime.stagger(15)
                });
            },

            /** Hierarchical pyramid structure */
            _modePyramid(withStruggle = false) {
                // Timeline for dramatic pyramid formation
                const tl = anime.createTimeline({});
                
                // First, scatter all dots
                this.dots.forEach((dot, i) => {
                    anime.set(dot, {
                        left: anime.random(0, 100) + 'vw',
                        top: anime.random(0, 100) + 'vh',
                        scale: 0.5,
                        opacity: 0.3
                    });
                });
                
                // Form pyramid layer by layer
                const eliteCount = 12;
                
                tl.add(this.dots.slice(0, eliteCount), {
                    left: (el, i) => (45 + (i % 4) * 3) + 'vw',
                    top: '10vh',
                    backgroundColor: '#FFFFFF',
                    opacity: 1,
                    scale: 2,
                    duration: 1500,
                    delay: anime.stagger(100),
                    ease: 'easeOutExpo'
                })
                .add(this.dots.slice(eliteCount), {
                    left: (el, i) => {
                        const idx = i + eliteCount;
                        const row = Math.floor(Math.sqrt(idx));
                        const col = idx - row * row;
                        return (50 + (col - row / 2) * 3.5) + 'vw';
                    },
                    top: (el, i) => {
                        const idx = i + eliteCount;
                        const row = Math.floor(Math.sqrt(idx));
                        return (20 + row * 6) + 'vh';
                    },
                    backgroundColor: '#00FFCC',
                    opacity: 0.3,
                    scale: 0.8,
                    duration: 2000,
                    delay: anime.stagger(20, {from: 'last'}),
                    ease: 'easeOutQuart'
                }, '-=1000');
                
                // Add struggle animation if requested
                if (withStruggle) {
                    setTimeout(() => {
                        anime.animate(this.dots.slice(eliteCount), {
                            y: [
                                { to: 0, duration: 500 },
                                { to: -30, duration: 1000, ease: 'easeInOutSine' },
                                { to: 0, duration: 1000, ease: 'easeInOutSine' }
                            ],
                            opacity: [
                                { to: 0.3, duration: 500 },
                                { to: 0.6, duration: 1000 },
                                { to: 0.3, duration: 1000 }
                            ],
                            duration: 2500,
                            loop: true,
                            delay: anime.stagger(100, {from: 'random'})
                        });
                    }, 2500);
                }
            },

            /** Pyramid breaking apart with dramatic dissolve */
            _modePyramidDissolve() {
                const tl = anime.createTimeline({});
                
                // Elite falls first
                tl.add('.dot', {
                    y: (el, i) => i < 12 ? 200 : 0,
                    opacity: (el, i) => i < 12 ? 0 : 0.3,
                    rotate: (el, i) => i < 12 ? anime.random(-90, 90) : 0,
                    duration: 1000,
                    ease: 'easeInExpo',
                    delay: anime.stagger(50, {from: 'first'})
                })
                // Then the base crumbles
                .add('.dot', {
                    x: () => anime.random(-600, 600),
                    y: () => anime.random(200, 1000),
                    rotate: () => anime.random(-360, 360),
                    scale: [1, 0.3],
                    opacity: [0.3, 0],
                    backgroundColor: '#FF3366',
                    duration: 2000,
                    ease: 'easeOutExpo',
                    delay: anime.stagger(10, {from: 'center'})
                });
            },

            /** Random explosion from center with spring physics */
            _modeStochastic() {
                // Gather in center first
                anime.set('.dot', {
                    left: '50vw',
                    top: '50vh',
                    scale: 0,
                    opacity: 0
                });
                
                // Explosive expansion with spring
                anime.animate('.dot', {
                    scale: [
                        { to: 0, duration: 0 },
                        { to: 1.5, duration: 400, ease: 'easeOutExpo' },
                        { to: 1, duration: 600, ease: 'easeOutElastic(1, .5)' }
                    ],
                    opacity: [
                        { to: 0, duration: 0 },
                        { to: 1, duration: 200 },
                        { to: 0.6, duration: 400 }
                    ],
                    x: () => anime.random(-500, 500),
                    y: () => anime.random(-500, 500),
                    backgroundColor: [
                        { to: '#FFFFFF', duration: 200 },
                        { to: '#00FFCC', duration: 800 }
                    ],
                    duration: 1500,
                    delay: anime.stagger(15, {from: 'center'})
                });
            },

            /** Organized grid formation with dramatic sequence */
            _modeResetToGrid() {
                const tl = anime.createTimeline();
                
                // Fade out and shrink
                tl.add('.dot', {
                    opacity: 0,
                    scale: 0,
                    rotate: () => anime.random(-180, 180),
                    duration: 800,
                    delay: anime.stagger(10),
                    ease: 'easeInExpo'
                })
                // Reset rotation
                .add('.dot', {
                    rotate: 0,
                    duration: 0
                })
                // Reappear in perfect grid with wave effect
                .add('.dot', {
                    opacity: 0.6,
                    scale: 1,
                    left: (el, i) => (8 + (i % 15) * 6.2) + 'vw',
                    top: (el, i) => (8 + Math.floor(i / 15) * 7.5) + 'vh',
                    backgroundColor: '#00FFCC',
                    boxShadow: [
                        { to: '0 0 0 transparent', duration: 0 },
                        { to: '0 0 20px #00FFCC', duration: 1000 }
                    ],
                    duration: 1500,
                    delay: anime.stagger(25, { 
                        grid: [15, 12], 
                        from: 'center'
                    }),
                    ease: 'easeOutElastic(1, .6)'
                });
            },

            /**
             * Toggle ambient audio
             */
            toggleAudio() {
                const enabled = AmbientAudio.toggle();
                const buttons = document.querySelectorAll('.audio-toggle');
                buttons.forEach(btn => {
                    btn.textContent = enabled ? '🔊' : '🔇';
                    btn.setAttribute('aria-label', enabled ? 'Audio ausschalten' : 'Audio einschalten');
                });
            },

            /**
             * Log welcome message to console
             * @private
             */
            _logWelcome() {
                console.log(
                    '%c ISONOMIA %c Projekt Kronos ',
                    'background: #00FFCC; color: #050505; font-weight: bold; padding: 4px 8px;',
                    'background: #FF3366; color: #FFFFFF; font-weight: bold; padding: 4px 8px;'
                );
                console.log('%cGewaltfreie Kommunikation → Algorithmischer Staat', 'color: #00FFCC;');
            }
        };

        // ==================================================================
        // SECTION 5: HAPTIC FEEDBACK (Mobile Vibration API)
        // ==================================================================

        const HapticFeedback = {
            /**
             * Trigger vibration pattern for error/negative states
             * Patterns based on psychological aversion research
             */
            error() {
                if (!navigator.vibrate) return;
                // Short, sharp pattern - creates psychological aversion
                navigator.vibrate([50, 30, 50]);
            },

            /**
             * Trigger vibration for clash/conflict states
             */
            clash() {
                if (!navigator.vibrate) return;
                // Alternating pattern - two opposing forces
                navigator.vibrate([80, 40, 80, 40, 80]);
            },

            /**
             * Trigger vibration for hierarchical/elite states
             */
            hierarchy() {
                if (!navigator.vibrate) return;
                // Heavy, oppressive pattern
                navigator.vibrate([120, 60, 120]);
            },

            /**
             * Trigger subtle feedback for positive interactions
             */
            confirm() {
                if (!navigator.vibrate) return;
                // Gentle, pleasant pulse
                navigator.vibrate(30);
            },

            /**
             * Trigger celebration vibration
             */
            celebrate() {
                if (!navigator.vibrate) return;
                // Ascending pattern - positive emotion
                navigator.vibrate([30, 20, 50, 20, 80]);
            }
        };

        // ==================================================================
        // SECTION 6: PATCH COUNTER (Social Validation / Bandwagon Effect)
        // ==================================================================

        const PatchCounter = {
            storageKey: 'isonomia_patch_count_base',
            sessionKey: 'isonomia_user_patched',
            
            /**
             * Get current patch count (simulated global counter)
             * Combines stored base with calculated growth
             */
            getCount() {
                const base = this._getStoredBase();
                const timeGrowth = this._calculateTimeGrowth();
                return base + timeGrowth;
            },
            
            /**
             * Increment counter when user completes journey
             */
            increment() {
                // Only count once per session
                if (sessionStorage.getItem(this.sessionKey)) return;
                
                const current = this._getStoredBase();
                localStorage.setItem(this.storageKey, (current + 1).toString());
                sessionStorage.setItem(this.sessionKey, 'true');
            },
            
            /**
             * Get stored base count
             * @private
             */
            _getStoredBase() {
                const stored = localStorage.getItem(this.storageKey);
                // Start with a believable seed number for bandwagon effect
                return stored ? parseInt(stored, 10) : 2847;
            },
            
            /**
             * Calculate growth based on time (simulates ongoing activity)
             * @private
             */
            _calculateTimeGrowth() {
                // Simulate ~1 new patch every 5 minutes
                const now = Date.now();
                const hourStart = new Date().setMinutes(0, 0, 0);
                const minutesSinceHour = Math.floor((now - hourStart) / (1000 * 60));
                return Math.floor(minutesSinceHour / 5);
            }
        };

        // ==================================================================
        // SECTION 7: SYSTEM CHECK (Priming Animation)
        // ==================================================================

        const SystemCheck = {
            /**
             * System check nodes representing validation states
             */
            nodes: [
                { id: 'conn', label: 'CONN', desc: 'Verbindung' },
                { id: 'bias', label: 'BIAS', desc: 'Status-Quo-Bias' },
                { id: 'cog', label: 'COG', desc: 'Kognitive Dissonanz' },
                { id: 'rep', label: 'REP', desc: 'Repräsentation' },
                { id: 'eq', label: 'EQ', desc: 'Gleichheit' },
                { id: 'sort', label: 'SORT', desc: 'Sortition' },
                { id: 'dem', label: 'DEM', desc: 'Demokratie' },
                { id: 'iso', label: 'ISO', desc: 'Isonomie' }
            ],
            
            /**
             * Start system check animation, then call callback
             * @param {Function} onComplete - Callback after animation finishes
             */
            start(onComplete) {
                this.onComplete = onComplete;
                this._createOverlay();
                this._animateSequence();
            },
            
            /**
             * Create the system check overlay
             * @private
             */
            _createOverlay() {
                const overlay = document.createElement('div');
                overlay.className = 'system-check-overlay';
                overlay.id = 'system-check-overlay';
                overlay.innerHTML = `
                    <div class="system-check-container">
                        <div class="system-check-title">System-Diagnose läuft...</div>
                        <div class="interval-grid" id="interval-grid">
                            ${this.nodes.map(node => `
                                <div class="interval-node" id="node-${node.id}" data-desc="${node.desc}">
                                    ${node.label}
                                </div>
                            `).join('')}
                        </div>
                        
                        <!-- Progress Bar -->
                        <div class="system-check-progress">
                            <div class="system-check-progress-bar" id="system-check-progress-bar"></div>
                        </div>
                        <div class="system-check-progress-text" id="system-check-progress-text">0%</div>
                        
                        <div class="system-check-status" id="system-check-status"></div>
                        <div class="system-check-complete" id="system-check-complete">
                            System bereit.<br>
                            <button class="haptic-btn" style="margin-top: 2rem;" onclick="SystemCheck._finish()">
                                Simulation starten →
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                // Trigger haptic for system start
                HapticFeedback.confirm();
            },
            
            /**
             * Animate the checking sequence
             * @private
             */
            _animateSequence() {
                const nodes = this.nodes;
                const statusEl = document.getElementById('system-check-status');
                const progressBar = document.getElementById('system-check-progress-bar');
                const progressText = document.getElementById('system-check-progress-text');
                let currentIndex = 0;
                
                const checkNext = () => {
                    if (currentIndex >= nodes.length) {
                        // Set progress to 100%
                        if (progressBar) progressBar.style.width = '100%';
                        if (progressText) progressText.textContent = '100%';
                        this._showComplete();
                        return;
                    }
                    
                    // Update progress
                    const progress = Math.round((currentIndex / nodes.length) * 100);
                    if (progressBar) progressBar.style.width = `${progress}%`;
                    if (progressText) progressText.textContent = `${progress}%`;
                    
                    const node = nodes[currentIndex];
                    const nodeEl = document.getElementById(`node-${node.id}`);
                    
                    // Activate node
                    nodeEl.classList.add('active');
                    
                    // Show status
                    setTimeout(() => {
                        statusEl.textContent = `Prüfe ${node.desc}...`;
                        statusEl.classList.add('visible');
                        nodeEl.classList.add('checking');
                        
                        // Subtle haptic for each check
                        if (navigator.vibrate) {
                            navigator.vibrate(20);
                        }
                    }, 100);
                    
                    // Mark as verified
                    setTimeout(() => {
                        nodeEl.classList.remove('checking');
                        nodeEl.classList.add('verified');
                        statusEl.classList.remove('visible');
                        currentIndex++;
                        
                        // Next node
                        setTimeout(checkNext, 200);
                    }, 600);
                };
                
                // Start after title animation
                setTimeout(checkNext, 500);
            },
            
            /**
             * Show completion state
             * @private
             */
            _showComplete() {
                const completeEl = document.getElementById('system-check-complete');
                HapticFeedback.celebrate();
                
                setTimeout(() => {
                    completeEl.classList.add('visible');
                }, 300);
            },
            
            /**
             * Finish and remove overlay
             * @private
             */
            _finish() {
                const overlay = document.getElementById('system-check-overlay');
                
                // Fade out
                overlay.style.transition = 'opacity 0.5s';
                overlay.style.opacity = '0';
                
                setTimeout(() => {
                    overlay.remove();
                    if (this.onComplete) this.onComplete();
                }, 500);
            }
        };

        // ==================================================================
        // SECTION 8: PARTICLE INTERACTIONS (Performance Optimized)
        // ==================================================================

        const ParticleInteraction = {
            /** @type {HTMLElement|null} Currently hovered dot */
            activeDot: null,
            
            /** @type {HTMLElement[]} Connection line elements */
            connectionLines: [],
            
            /** @type {number} Maximum distance for connection */
            connectionRadius: 150,
            
            /** @type {boolean} Whether interactions are enabled */
            enabled: true,
            
            /** @type {Map} Spatial hash grid for O(1) proximity lookup */
            spatialGrid: new Map(),
            
            /** @type {number} Grid cell size */
            cellSize: 150,
            
            /** @type {number} Animation frame ID for throttling */
            rafId: null,
            
            /** @type {boolean} Whether mouse is moving */
            isMouseMoving: false,

            /**
             * Initialize particle interactions
             * @param {HTMLElement[]} dots - Array of dot elements
             */
            init(dots) {
                this.dots = dots;
                this._buildSpatialGrid();
                this._setupHoverEffects();
                this._setupClickEffects();
                this._setupMouseProximity();
                this._setupTouchEffects();
                
                // Rebuild grid on window resize
                window.addEventListener('resize', () => {
                    this._buildSpatialGrid();
                }, { passive: true });
            },
            
            /**
             * Build spatial hash grid for O(1) proximity queries
             * @private
             */
            _buildSpatialGrid() {
                this.spatialGrid.clear();
                this.dots.forEach((dot, index) => {
                    const rect = dot.getBoundingClientRect();
                    const cellX = Math.floor(rect.left / this.cellSize);
                    const cellY = Math.floor(rect.top / this.cellSize);
                    const key = `${cellX},${cellY}`;
                    
                    if (!this.spatialGrid.has(key)) {
                        this.spatialGrid.set(key, []);
                    }
                    this.spatialGrid.get(key).push({ dot, index, rect });
                });
            },
            
            /**
             * Get nearby dots using spatial hashing
             * @private
             */
            _getNearbyDots(x, y, radius) {
                const nearby = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const centerCellX = Math.floor(x / this.cellSize);
                const centerCellY = Math.floor(y / this.cellSize);
                
                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                        const key = `${centerCellX + dx},${centerCellY + dy}`;
                        const cell = this.spatialGrid.get(key);
                        if (cell) {
                            nearby.push(...cell);
                        }
                    }
                }
                return nearby;
            },

            /**
             * Setup hover effects for particles
             * @private
             */
            _setupHoverEffects() {
                this.dots.forEach(dot => {
                    dot.addEventListener('mouseenter', () => {
                        if (!this.enabled) return;
                        this.activeDot = dot;
                        dot.classList.add('active');
                        this._createConnections(dot);
                    });

                    dot.addEventListener('mouseleave', () => {
                        dot.classList.remove('active');
                        this._clearConnections();
                        this.activeDot = null;
                    });
                });
            },
            
            /**
             * Setup touch effects for mobile
             * @private
             */
            _setupTouchEffects() {
                let touchTimeout;
                document.addEventListener('touchstart', (e) => {
                    if (!this.enabled) return;
                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.classList.contains('dot')) {
                        target.classList.add('active');
                        this._createConnections(target);
                        clearTimeout(touchTimeout);
                        touchTimeout = setTimeout(() => {
                            target.classList.remove('active');
                            this._clearConnections();
                        }, 1000);
                    }
                }, { passive: true });
            },

            /**
             * Setup click effects for particles
             * @private
             */
            _setupClickEffects() {
                document.addEventListener('click', (e) => {
                    if (!this.enabled) return;
                    if (e.target.classList.contains('dot')) {
                        this._pulseEffect(e.target);
                    }
                });
            },

            /**
             * Setup mouse proximity detection with RAF throttling
             * @private
             */
            _setupMouseProximity() {
                let lastMouseX = 0;
                let lastMouseY = 0;
                let mouseTimeout;
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.enabled || this.activeDot) return;
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    this.isMouseMoving = true;
                    
                    clearTimeout(mouseTimeout);
                    mouseTimeout = setTimeout(() => {
                        this.isMouseMoving = false;
                    }, 100);
                    
                    if (!this.rafId) {
                        this.rafId = requestAnimationFrame(() => {
                            this._handleMouseMove(lastMouseX, lastMouseY);
                            this.rafId = null;
                        });
                    }
                }, { passive: true });
            },

            /**
             * Handle mouse movement for proximity effects using spatial hashing
             * Complexity: O(k) where k = dots in nearby cells, instead of O(n)
             * @private
             */
            _handleMouseMove(mouseX, mouseY) {
                // Reset all dots first (limited to previously affected)
                this.dots.forEach(dot => {
                    dot.style.opacity = '';
                    dot.style.transform = '';
                });
                
                // Use spatial hashing for O(1) nearby lookup
                const nearby = this._getNearbyDots(mouseX, mouseY, this.connectionRadius);
                
                nearby.forEach(({ dot }) => {
                    const rect = dot.getBoundingClientRect();
                    const dotX = rect.left + rect.width / 2;
                    const dotY = rect.top + rect.height / 2;
                    const distance = Math.hypot(mouseX - dotX, mouseY - dotY);

                    if (distance < this.connectionRadius) {
                        const intensity = 1 - (distance / this.connectionRadius);
                        dot.style.opacity = 0.4 + (intensity * 0.6);
                        dot.style.transform = `scale(${1 + intensity})`;
                    }
                });
            },

            /**
             * Create connection lines from active dot to nearby dots
             * Uses spatial hashing for O(k) performance instead of O(n)
             * @private
             */
            _createConnections(activeDot) {
                const activeRect = activeDot.getBoundingClientRect();
                const activeX = activeRect.left + activeRect.width / 2;
                const activeY = activeRect.top + activeRect.height / 2;

                let connectionCount = 0;
                const maxConnections = 5;
                
                // Use spatial hashing for efficient nearby lookup
                const nearby = this._getNearbyDots(activeX, activeY, this.connectionRadius * 1.5);

                nearby.forEach(({ dot }) => {
                    if (connectionCount >= maxConnections) return;
                    if (dot === activeDot) return;

                    const rect = dot.getBoundingClientRect();
                    const dotX = rect.left + rect.width / 2;
                    const dotY = rect.top + rect.height / 2;
                    const distance = Math.hypot(activeX - dotX, activeY - dotY);

                    if (distance < this.connectionRadius * 1.5) {
                        this._drawConnection(activeX, activeY, dotX, dotY, distance);
                        connectionCount++;
                        
                        // Highlight connected dot
                        dot.style.opacity = '0.8';
                        dot.style.transform = 'scale(1.5)';
                    }
                });
            },

            /**
             * Draw a connection line between two points
             * @private
             */
            _drawConnection(x1, y1, x2, y2, distance) {
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                const length = Math.hypot(x2 - x1, y2 - y1);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                const opacity = 1 - (distance / (this.connectionRadius * 1.5));

                line.style.width = length + 'px';
                line.style.left = x1 + 'px';
                line.style.top = y1 + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                line.style.opacity = opacity * 0.6;

                document.body.appendChild(line);
                this.connectionLines.push(line);

                // Fade in animation
                anime.animate(line, {
                    opacity: [0, opacity * 0.6],
                    duration: 300,
                    ease: 'easeOutQuad'
                });
            },

            /**
             * Clear all connection lines
             * @private
             */
            _clearConnections() {
                this.connectionLines.forEach(line => {
                    anime.animate(line, {
                        opacity: 0,
                        duration: 200,
                        ease: 'easeInQuad',
                        onComplete: () => line.remove()
                    });
                });
                this.connectionLines = [];

                // Reset all dots
                this.dots.forEach(dot => {
                    dot.style.opacity = '';
                    dot.style.transform = '';
                });
            },

            /**
             * Create pulse effect on clicked dot
             * @private
             */
            _pulseEffect(dot) {
                anime.animate(dot, {
                    scale: [2, 4, 1],
                    opacity: [1, 0.8, 0.4],
                    duration: 600,
                    ease: 'easeOutElastic(1, .5)'
                });

                // Create ripple effect on nearby dots
                const rect = dot.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                this.dots.forEach(otherDot => {
                    if (otherDot === dot) return;
                    
                    const otherRect = otherDot.getBoundingClientRect();
                    const otherX = otherRect.left + otherRect.width / 2;
                    const otherY = otherRect.top + otherRect.height / 2;
                    const distance = Math.hypot(centerX - otherX, centerY - otherY);

                    if (distance < 200) {
                        const delay = distance * 2;
                        anime.animate(otherDot, {
                            scale: [1, 1.8, 1],
                            opacity: [0.4, 0.8, 0.4],
                            duration: 400,
                            delay: delay,
                            ease: 'easeOutQuad'
                        });
                    }
                });
            },

            /**
             * Enable/disable interactions
             * @param {boolean} enabled
             */
            setEnabled(enabled) {
                this.enabled = enabled;
                if (!enabled) {
                    this._clearConnections();
                }
            }
        };

        // ==================================================================
        // SECTION 9: SHARE FEATURE (Updated)
        // ==================================================================

        const ShareFeature = {
            /**
             * Share current narrative step
             */
            shareCurrent() {
                const currentStep = ISONOMIA.history[ISONOMIA.history.length - 1];
                const data = narrativeData[currentStep];
                if (!data) return;

                const text = `"${data.text.substring(0, 120)}${data.text.length > 120 ? '...' : ''}"`;
                const url = window.location.href.split('?')[0] + `?step=${currentStep}`;
                const fullText = `${text}\n\nISONOMIA | Projekt Kronos\n${url}`;

                if (navigator.share) {
                    navigator.share({
                        title: 'ISONOMIA | Projekt Kronos',
                        text: text,
                        url: url
                    }).catch(() => this._showShareDialog(fullText, url));
                } else {
                    this._showShareDialog(fullText, url);
                }
            },

            /**
             * Show custom share dialog
             * @private
             */
            _showShareDialog(text, url) {
                const dialog = document.createElement('div');
                dialog.className = 'share-dialog';
                dialog.innerHTML = `
                    <div class="share-dialog-backdrop" onclick="this.parentElement.remove()"></div>
                    <div class="share-dialog-content" role="dialog" aria-label="Teilen">
                        <h3>Gedanken teilen</h3>
                        <textarea readonly>${text}</textarea>
                        <div class="share-buttons">
                            <button onclick="ShareFeature._copyToClipboard('${url.replace(/'/g, "\\'")}')">Link kopieren</button>
                            <button onclick="ShareFeature._shareTwitter('${url.replace(/'/g, "\\'")}')">Twitter</button>
                            <button onclick="ShareFeature._shareMastodon('${url.replace(/'/g, "\\'")}')">Mastodon</button>
                        </div>
                        <button class="close-btn" onclick="this.closest('.share-dialog').remove()">Schließen</button>
                    </div>
                `;
                document.body.appendChild(dialog);
            },

            /**
             * Copy URL to clipboard
             * @private
             */
            async _copyToClipboard(url) {
                try {
                    await navigator.clipboard.writeText(url);
                    alert('Link kopiert!');
                } catch (err) {
                    prompt('Link kopieren:', url);
                }
            },

            /**
             * Share to Twitter/X
             * @private
             */
            _shareTwitter(url) {
                const currentStep = ISONOMIA.history[ISONOMIA.history.length - 1];
                const data = narrativeData[currentStep];
                const text = data ? data.text.substring(0, 100) + '...' : 'ISONOMIA | Projekt Kronos';
                const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
                window.open(twitterUrl, '_blank', 'width=550,height=420');
            },

            /**
             * Share to Mastodon
             * @private
             */
            _shareMastodon(url) {
                const currentStep = ISONOMIA.history[ISONOMIA.history.length - 1];
                const data = narrativeData[currentStep];
                const text = data ? data.text.substring(0, 100) + '...' : 'ISONOMIA | Projekt Kronos';
                const mastodonUrl = `https://mastodon.social/share?text=${encodeURIComponent(text + '\n\n' + url)}`;
                window.open(mastodonUrl, '_blank', 'width=550,height=420');
            },

            /**
             * Parse URL parameter on load
             */
            checkUrlParameter() {
                const params = new URLSearchParams(window.location.search);
                const step = params.get('step');
                if (step && narrativeData[step]) {
                    return step;
                }
                return null;
            }
        };

        // ==================================================================
        // SECTION 10: SIMULATION MODE (Updated)
        // ==================================================================

        const SimulationMode = {
            /** @type {Array} Pool of simulated citizens */
            citizens: [
                { name: 'Maria Schmidt', job: 'Krankenschwester', bio: '35 Jahre, zwei Kinder, arbeitet im Schichtdienst. Mitglied im Mütterzentrum.', icon: '👩‍⚕️' },
                { name: 'Hassan Al-Farsi', job: 'Taxifahrer', bio: '42 Jahre, spricht 4 Sprachen, kennt jeden Stadtteil. Engagiert im Bürgerverein.', icon: '🚕' },
                { name: 'Erika Müller', job: 'Rentnerin', bio: '68 Jahre, ehemalige Buchhalterin. Leitet eine Nachbarschaftshilfe.', icon: '👵' },
                { name: 'Tom Weber', job: 'Software-Entwickler', bio: '29 Jahre, Open-Source-Aktivist. Organisiert Repair-Cafés.', icon: '👨‍💻' },
                { name: 'Aisha Johnson', job: 'Lehrerin', bio: '38 Jahre, unterrichtet an einer Gesamtschule. Debattierclub-Coach.', icon: '👩‍🏫' },
                { name: 'Klaus Richter', job: 'Metzger', bio: '55 Jahre, Familienbetrieb in 3. Generation. Kennt alle im Viertel.', icon: '🔪' },
                { name: 'Sophie Chen', job: 'Studierende', bio: '22 Jahre, Soziologie & Politikwissenschaft. Campus-Engagement für Inklusion.', icon: '👩‍🎓' },
                { name: 'Dieter Fischer', job: 'Bauarbeiter', bio: '45 Jahre, Gewerkschaftsvertreter. Praktischer Problem-Löser.', icon: '👷' },
                { name: 'Fatima Özdemir', job: 'Friseurin', bio: '31 Jahre, eigener Salon. Informelle Beraterin für viele Kunden.', icon: '💇‍♀️' },
                { name: 'Robert Klein', job: 'Künstler', bio: '40 Jahre, freischaffend. Organisiert Kulturveranstaltungen im Stadtpark.', icon: '🎨' },
                { name: 'Helga Bauer', job: 'Landwirtin', bio: '52 Jahre, Bio-Hof. Versteht Nachhaltigkeit aus praktischer Erfahrung.', icon: '👩‍🌾' },
                { name: 'Jamal Williams', job: 'Sozialarbeiter', bio: '36 Jahre, Jugendzentrum. Arbeitet direkt mit den Herausforderungen der Stadt.', icon: '🤝' }
            ],

            /**
             * Start the lottery simulation
             */
            start() {
                const ui = document.getElementById('content-layer');
                ui.innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Los-Simulation">
                        <h1>Die Isonomie-Lotterie</h1>
                        <p style="color: var(--dim-text); margin-bottom: 2rem;">
                            In Athen wurden Bürgerämter durch das Los vergeben.<br>
                            Keine Wahlkämpfe. Keine Parteien. Nur Gleichheit.
                        </p>
                        <div id="simulation-stage">
                            <button class="haptic-btn" id="draw-lottery-btn" onclick="SimulationMode.drawLottery()" style="font-size: 1.2rem; padding: 1.5rem 3rem;">
                                🎲 Ein Los ziehen
                            </button>
                        </div>
                        <p style="margin-top: 2rem; font-size: 0.8rem; color: var(--dim-text);">
                            Chance: 1:${this.citizens.length} (heute: 1:5000+ bei großen Städten)
                        </p>
                        <br>
                        <button class="haptic-btn btn-small" onclick="ISONOMIA.showVault()">← Zurück zum Vault</button>
                    </div>`;
                
                ISONOMIA.applyVisualMode('stochastic');
            },

            /**
             * Draw a citizen from the lottery
             */
            drawLottery() {
                const stage = document.getElementById('simulation-stage');
                const button = document.getElementById('draw-lottery-btn');
                
                if (button) {
                    button.disabled = true;
                    button.textContent = 'Das Los fällt...';
                }

                // Animation: shuffle through citizens
                let shuffleCount = 0;
                const maxShuffles = 15;
                const shuffleInterval = setInterval(() => {
                    const randomCitizen = this.citizens[Math.floor(Math.random() * this.citizens.length)];
                    this._renderShuffleCard(stage, randomCitizen);
                    shuffleCount++;
                    
                    if (shuffleCount >= maxShuffles) {
                        clearInterval(shuffleInterval);
                        this._showFinalResult(stage);
                    }
                }, 100);
            },

            /**
             * Render a shuffling card
             * @private
             */
            _renderShuffleCard(container, citizen) {
                container.innerHTML = `
                    <div class="lottery-card shuffling">
                        <div class="lottery-icon">${citizen.icon}</div>
                        <div class="lottery-name">${citizen.name}</div>
                        <div class="lottery-job">${citizen.job}</div>
                    </div>
                `;
            },

            /**
             * Show the final lottery result
             * @private
             */
            _showFinalResult(container) {
                const winner = this.citizens[Math.floor(Math.random() * this.citizens.length)];
                
                container.innerHTML = `
                    <div class="lottery-card winner" style="animation: lotteryReveal 0.6s ease-out;">
                        <div class="lottery-winner-badge">🎉 GEZOGEN</div>
                        <div class="lottery-icon" style="font-size: 4rem;">${winner.icon}</div>
                        <div class="lottery-name" style="color: var(--cyan); font-size: 1.5rem; margin: 1rem 0;">${winner.name}</div>
                        <div class="lottery-job" style="color: var(--white); font-weight: bold;">${winner.job}</div>
                        <div class="lottery-bio" style="margin-top: 1rem; padding: 1rem; background: rgba(0,255,204,0.05); border-left: 2px solid var(--cyan);">${winner.bio}</div>
                        <div class="lottery-term" style="margin-top: 1.5rem; color: var(--dim-text); font-size: 0.9rem;">
                            📅 Amtszeit: 1 Jahr<br>
                            🏛️ Position: Mitglied der Bürgerkammer
                        </div>
                    </div>
                    <button class="haptic-btn" onclick="SystemCheck.start(() => SimulationMode.start())" style="margin-top: 2rem;">
                        Nochmal ziehen
                    </button>
                `;

                // Visual celebration
                ISONOMIA.applyVisualMode('breathe');
                this._celebrationEffect();
            },

            /**
             * Create celebration particle effect
             * @private
             */
            _celebrationEffect() {
                anime.animate('.dot', {
                    scale: [1, 2, 1],
                    opacity: [0.4, 1, 0.4],
                    backgroundColor: ['#00FFCC', '#FFFFFF', '#00FFCC'],
                    delay: anime.stagger(20),
                    duration: 1000,
                    ease: 'easeOutElastic(1, .5)'
                });
            }
        };

        // ==================================================================
        // SECTION 11: AMBIENT AUDIO (Updated)
        // ==================================================================

        const AmbientAudio = {
            /** @type {AudioContext|null} Web Audio API context */
            ctx: null,
            
            /** @type {boolean} Whether audio is enabled */
            enabled: false,
            
            /** @type {GainNode} Master volume control */
            masterGain: null,
            
            /** @type {OscillatorNode|null} Current drone oscillator */
            currentDrone: null,
            
            /** @type {string} Current mode */
            currentMode: 'breathe',

            /**
             * Initialize audio context (must be called after user interaction)
             */
            init() {
                if (this.ctx) return;
                
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.15; // Low volume
                    this.masterGain.connect(this.ctx.destination);
                    this.enabled = true;
                    console.log('[ISONOMIA] Audio initialized');
                } catch (e) {
                    console.warn('[ISONOMIA] Audio not supported:', e);
                }
            },

            /**
             * Play ambient sound for current visual mode
             * @param {string} mode - Visual mode identifier
             */
            playMode(mode) {
                if (!this.enabled || !this.ctx) return;
                this.currentMode = mode;

                // Stop current drone
                this._stopDrone();

                const soundscapes = {
                    'breathe': () => this._playBreathe(),
                    'tremble': () => this._playTremble(),
                    'chaos': () => this._playChaos(),
                    'clash': () => this._playClash(),
                    'pyramid': () => this._playPyramid(),
                    'pyramid_struggle': () => this._playPyramidStruggle(),
                    'pyramid_dissolve': () => this._playDissolve(),
                    'stochastic': () => this._playStochastic(),
                    'reset_to_grid': () => this._playGrid()
                };

                if (soundscapes[mode]) {
                    soundscapes[mode]();
                }
            },

            /**
             * Gentle breathing drone
             * @private
             */
            _playBreathe() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = 110; // A2
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 3);
                
                // Breathing modulation
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 0.25; // 4 second breath cycle
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 0.1;
                
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                lfo.start();
                
                this.currentDrone = { osc, lfo, nodes: [gain, lfoGain] };
            },

            /**
             * Subtle tremble
             * @private
             */
            _playTremble() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.value = 220;
                
                // Tremolo effect
                const tremolo = this.ctx.createOscillator();
                tremolo.frequency.value = 8; // Fast tremble
                const tremoloGain = this.ctx.createGain();
                tremoloGain.gain.value = 0.05;
                
                tremolo.connect(tremoloGain);
                tremoloGain.connect(gain.gain);
                
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                tremolo.start();
                
                this.currentDrone = { osc, lfo: tremolo, nodes: [gain, tremoloGain] };
            },

            /**
             * Chaotic dissonance
             * @private
             */
            _playChaos() {
                // Multiple detuned oscillators
                const freqs = [110, 115, 220, 233];
                const oscillators = [];
                
                freqs.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = i % 2 === 0 ? 'sawtooth' : 'square';
                    osc.frequency.value = freq;
                    osc.detune.value = Math.random() * 50 - 25;
                    
                    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    
                    oscillators.push({ osc, gain });
                });
                
                this.currentDrone = { multi: true, oscillators };
            },

            /**
             * Clash - two opposing tones
             * @private
             */
            _playClash() {
                const leftOsc = this.ctx.createOscillator();
                const rightOsc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                leftOsc.type = 'sawtooth';
                leftOsc.frequency.value = 196; // G3
                
                rightOsc.type = 'sawtooth';
                rightOsc.frequency.value = 207; // G#3 (dissonant)
                
                // Stereo panning
                const leftPan = this.ctx.createStereoPanner();
                const rightPan = this.ctx.createStereoPanner();
                leftPan.pan.value = -0.8;
                rightPan.pan.value = 0.8;
                
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                
                leftOsc.connect(leftPan);
                rightOsc.connect(rightPan);
                leftPan.connect(gain);
                rightPan.connect(gain);
                gain.connect(this.masterGain);
                
                leftOsc.start();
                rightOsc.start();
                
                this.currentDrone = { osc: null, nodes: [gain, leftPan, rightPan], multi: true, oscillators: [{osc: leftOsc}, {osc: rightOsc}] };
            },

            /**
             * Pyramid - hierarchical low drone
             * @private
             */
            _playPyramid() {
                const osc = this.ctx.createOscillator();
                const filter = this.ctx.createBiquadFilter();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.value = 65; // Deep C2
                
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                
                this.currentDrone = { osc, nodes: [filter, gain] };
            },

            /**
             * Pyramid with struggle
             * @private
             */
            _playPyramidStruggle() {
                this._playPyramid();
                
                // Add struggling higher tones
                const struggleOsc = this.ctx.createOscillator();
                const struggleGain = this.ctx.createGain();
                
                struggleOsc.type = 'square';
                struggleOsc.frequency.value = 330;
                
                // Frantic modulation
                const mod = this.ctx.createOscillator();
                mod.frequency.value = 3;
                const modGain = this.ctx.createGain();
                modGain.gain.value = 100;
                mod.connect(modGain);
                modGain.connect(struggleOsc.frequency);
                
                struggleGain.gain.setValueAtTime(0.03, this.ctx.currentTime);
                
                struggleOsc.connect(struggleGain);
                struggleGain.connect(this.masterGain);
                
                struggleOsc.start();
                mod.start();
                
                if (this.currentDrone) {
                    this.currentDrone.nodes.push(struggleGain, modGain);
                    this.currentDrone.oscillators = this.currentDrone.oscillators || [];
                    this.currentDrone.oscillators.push({osc: struggleOsc}, {osc: mod});
                }
            },

            /**
             * Dissolve - fading out
             * @private
             */
            _playDissolve() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = 220;
                
                // Rapid fade
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                osc.stop(this.ctx.currentTime + 2);
                
                // No need to track for stopping
                this.currentDrone = null;
            },

            /**
             * Stochastic - random particles
             * @private
             */
            _playStochastic() {
                // Cancel any existing stochastic timeout
                if (this._stochasticTimeout) {
                    clearTimeout(this._stochasticTimeout);
                    this._stochasticTimeout = null;
                }
                
                const playBlip = () => {
                    if (this.currentMode !== 'stochastic' || !this.enabled) {
                        this._stochasticTimeout = null;
                        return;
                    }
                    
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.frequency.value = 440 + Math.random() * 880;
                    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.1);
                    
                    this._stochasticTimeout = setTimeout(playBlip, 50 + Math.random() * 200);
                };
                
                playBlip();
            },

            /**
             * Grid - harmonious chords
             * @private
             */
            _playGrid() {
                const freqs = [261.63, 329.63, 392.00]; // C major chord
                const oscillators = [];
                
                freqs.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 1 + i * 0.2);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    
                    oscillators.push({ osc, gain });
                });
                
                this.currentDrone = { multi: true, oscillators };
            },

            /**
             * Stop current drone
             * @private
             */
            _stopDrone() {
                // Cancel stochastic timeout if exists
                if (this._stochasticTimeout) {
                    clearTimeout(this._stochasticTimeout);
                    this._stochasticTimeout = null;
                }
                
                if (!this.currentDrone) return;
                
                const fadeTime = 0.5;
                const stopTime = this.ctx.currentTime + fadeTime;
                
                if (this.currentDrone.multi) {
                    this.currentDrone.oscillators.forEach(({osc, gain}) => {
                        if (gain) {
                            gain.gain.cancelScheduledValues(this.ctx.currentTime);
                            gain.gain.setValueAtTime(gain.gain.value, this.ctx.currentTime);
                            gain.gain.linearRampToValueAtTime(0, stopTime);
                        }
                        if (osc) osc.stop(stopTime);
                    });
                } else {
                    if (this.currentDrone.osc) {
                        this.currentDrone.osc.stop(stopTime);
                    }
                    if (this.currentDrone.nodes) {
                        this.currentDrone.nodes.forEach(node => {
                            if (node.gain) {
                                node.gain.cancelScheduledValues(this.ctx.currentTime);
                                node.gain.setValueAtTime(node.gain.value, this.ctx.currentTime);
                                node.gain.linearRampToValueAtTime(0, stopTime);
                            }
                        });
                    }
                }
                
                this.currentDrone = null;
            },

            /**
             * Toggle audio on/off
             */
            toggle() {
                if (!this.ctx) {
                    this.init();
                    return true;
                }
                
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                    this.enabled = true;
                    return true;
                } else if (this.enabled) {
                    this.enabled = false;
                    this._stopDrone();
                    return false;
                } else {
                    this.enabled = true;
                    return true;
                }
            },

            /**
             * Get current state
             */
            getState() {
                return {
                    enabled: this.enabled,
                    initialized: !!this.ctx,
                    mode: this.currentMode
                };
            }
        };

        // ==================================================================
        // SECTION 12: 3D ENGINE INTEGRATION (Three.js)
        // ==================================================================
        
        /**
         * ISONOMIA 3D - Raum-basiertes narrative System
         * 
         * Transformiert die flache State-Machine in einen begehbaren 3D-Raum.
         * Jeder narrative Knoten ist eine Station im Raum mit:
         * - 3D-Position (x, y, z)
         * - Kamera-Position und Blickrichtung
         * - Partikel-Formation (Visual Mode)
         * - Umgebungs-Atmosphäre
         */
        
        const ISONOMIA3D = {
            // Three.js Core
            scene: null,
            camera: null,
            renderer: null,
            
            // Partikel-System
            particleMesh: null,
            particleCount: 180,
            particleData: [],  // Position, Geschwindigkeit, Zustand pro Partikel
            
            // Kamera-System
            cameraRig: {
                currentPos: new THREE.Vector3(0, 2, 5),
                targetPos: new THREE.Vector3(0, 2, 5),
                lookAtCurrent: new THREE.Vector3(0, 0, 0),
                lookAtTarget: new THREE.Vector3(0, 0, 0),
                isTransitioning: false,
                transitionStartTime: 0,
                transitionDuration: 2000
            },
            
            // Narrativer Raum
            narrativeSpace: {
                'start': {
                    position: new THREE.Vector3(0, 0, 0),
                    camera: new THREE.Vector3(0, 2, 8),
                    lookAt: new THREE.Vector3(0, 0, 0),
                    particleMode: 'breathe',
                    fog: { color: 0x050505, near: 10, far: 50 }
                },
                'skeptic': {
                    position: new THREE.Vector3(-3, 0, -5),
                    camera: new THREE.Vector3(-2, 1.5, 3),
                    lookAt: new THREE.Vector3(-3, 0, -5),
                    particleMode: 'tremble',
                    fog: { color: 0x0a0505, near: 5, far: 40 }
                },
                'hook': {
                    position: new THREE.Vector3(0, 0, -10),
                    camera: new THREE.Vector3(3, 2, -5),
                    lookAt: new THREE.Vector3(0, 0, -10),
                    particleMode: 'chaos',
                    fog: { color: 0x1a050a, near: 5, far: 35 }
                },
                'path_parties_start': {
                    position: new THREE.Vector3(0, 0, -20),
                    camera: new THREE.Vector3(-6, 1, -15),
                    lookAt: new THREE.Vector3(0, 0, -20),
                    particleMode: 'clash',
                    fog: { color: 0x150510, near: 8, far: 40 }
                },
                'nvc_validation_conflict': {
                    position: new THREE.Vector3(-5, 2, -22),
                    camera: new THREE.Vector3(-8, 3, -18),
                    lookAt: new THREE.Vector3(-5, 2, -22),
                    particleMode: 'tremble',
                    fog: { color: 0x120508, near: 5, far: 35 }
                },
                'path_expert_logic': {
                    position: new THREE.Vector3(8, 0, -25),
                    camera: new THREE.Vector3(8, 6, -18),
                    lookAt: new THREE.Vector3(8, 2, -25),
                    particleMode: 'pyramid',
                    fog: { color: 0x080808, near: 10, far: 50 }
                },
                'nvc_validation_expert': {
                    position: new THREE.Vector3(10, 3, -28),
                    camera: new THREE.Vector3(12, 7, -22),
                    lookAt: new THREE.Vector3(10, 3, -28),
                    particleMode: 'pyramid_struggle',
                    fog: { color: 0x100505, near: 8, far: 45 }
                },
                'platon_deconstruction': {
                    position: new THREE.Vector3(12, -2, -30),
                    camera: new THREE.Vector3(15, 3, -25),
                    lookAt: new THREE.Vector3(12, -2, -30),
                    particleMode: 'pyramid_dissolve',
                    fog: { color: 0x1a0510, near: 5, far: 40 }
                },
                'intro_isonomia_logic': {
                    position: new THREE.Vector3(-8, 4, -35),
                    camera: new THREE.Vector3(-5, 7, -28),
                    lookAt: new THREE.Vector3(-8, 4, -35),
                    particleMode: 'stochastic',
                    fog: { color: 0x050a0a, near: 10, far: 60 }
                },
                'isonomia_mechanism': {
                    position: new THREE.Vector3(-10, 2, -40),
                    camera: new THREE.Vector3(-7, 5, -35),
                    lookAt: new THREE.Vector3(-10, 2, -40),
                    particleMode: 'reset_to_grid',
                    fog: { color: 0x050808, near: 12, far: 55 }
                },
                'isonomia_qualification': {
                    position: new THREE.Vector3(-12, 5, -42),
                    camera: new THREE.Vector3(-9, 8, -36),
                    lookAt: new THREE.Vector3(-12, 5, -42),
                    particleMode: 'breathe',
                    fog: { color: 0x050808, near: 10, far: 50 }
                },
                'final_manifestation': {
                    position: new THREE.Vector3(0, 8, -50),
                    camera: new THREE.Vector3(0, 12, -42),
                    lookAt: new THREE.Vector3(0, 10, -50),
                    particleMode: 'reset_to_grid',
                    fog: { color: 0x050505, near: 15, far: 80 }
                },
                'vault': {
                    position: new THREE.Vector3(0, 0, 0),
                    camera: new THREE.Vector3(0, 3, 10),
                    lookAt: new THREE.Vector3(0, 0, 0),
                    particleMode: 'breathe',
                    fog: { color: 0x050505, near: 10, far: 60 }
                }
            },
            
            // Animation Frame ID
            animationId: null,
            
            // Zeit für Animationen
            clock: new THREE.Clock(),
            
            /**
             * Initialisiert die 3D-Szene
             */
            init() {
                // Prüfe WebGL-Support
                if (!this._checkWebGL()) {
                    console.warn('[ISONOMIA3D] WebGL nicht verfügbar, verwende 2D-Fallback');
                    return false;
                }
                
                this._initScene();
                this._initCamera();
                this._initRenderer();
                this._initParticles();
                this._initLighting();
                this._setupResizeHandler();
                
                // Starte Render-Loop
                this._animate();
                
                console.log('[ISONOMIA3D] 3D-Engine initialisiert');
                return true;
            },
            
            /**
             * Prüft WebGL-Unterstützung
             */
            _checkWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext && 
                        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch (e) {
                    return false;
                }
            },
            
            /**
             * Erstellt die Three.js Scene
             */
            _initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                this.scene.fog = new THREE.Fog(0x050505, 10, 50);
            },
            
            /**
             * Initialisiert die Kamera
             */
            _initCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    60,  // FOV
                    window.innerWidth / window.innerHeight,  // Aspect
                    0.1,  // Near
                    1000  // Far
                );
                this.camera.position.copy(this.cameraRig.currentPos);
                this.camera.lookAt(this.cameraRig.lookAtCurrent);
            },
            
            /**
             * Erstellt den WebGL-Renderer
             */
            _initRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: 'high-performance'
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x050505, 1);
                
                // Füge Canvas vor particle-container ein
                const container = document.getElementById('particle-container');
                this.renderer.domElement.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    z-index: 0;
                `;
                container.insertBefore(this.renderer.domElement, container.firstChild);
            },
            
            /**
             * Initialisiert das InstancedMesh-Partikel-System
             */
            _initParticles() {
                // Geometrie: Kugel mit niedriger Poly-Anzahl
                const geometry = new THREE.SphereGeometry(0.08, 8, 8);
                
                // Material: Selbstleuchtend für Glow-Effekt
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FFCC,
                    transparent: true,
                    opacity: 0.8
                });
                
                // InstancedMesh für Performance (1 Draw Call)
                this.particleMesh = new THREE.InstancedMesh(
                    geometry,
                    material,
                    this.particleCount
                );
                
                // Initialisiere Partikel-Daten
                this.particleData = [];
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                
                for (let i = 0; i < this.particleCount; i++) {
                    // Zufällige Position im Sichtbereich
                    const x = (Math.random() - 0.5) * 20;
                    const y = (Math.random() - 0.5) * 10;
                    const z = (Math.random() - 0.5) * 20;
                    
                    dummy.position.set(x, y, z);
                    dummy.updateMatrix();
                    this.particleMesh.setMatrixAt(i, dummy.matrix);
                    
                    // Speichere individuelle Partikel-Daten
                    this.particleData.push({
                        basePosition: new THREE.Vector3(x, y, z),
                        currentPosition: new THREE.Vector3(x, y, z),
                        velocity: new THREE.Vector3(0, 0, 0),
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.5 + Math.random() * 0.5,
                        isElite: i < 12  // Für Pyramid-Modus
                    });
                    
                    // Standard-Farbe (Cyan)
                    this.particleMesh.setColorAt(i, color.setHex(0x00FFCC));
                }
                
                this.particleMesh.instanceMatrix.needsUpdate = true;
                this.scene.add(this.particleMesh);
            },
            
            /**
             * Fügt subtile Beleuchtung hinzu
             */
            _initLighting() {
                // Ambient Light für Grundhelligkeit
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Point Light für dramatische Effekte
                this.pointLight = new THREE.PointLight(0x00FFCC, 1, 50);
                this.pointLight.position.set(0, 5, 0);
                this.scene.add(this.pointLight);
            },
            
            /**
             * Haupt-Animations-Loop
             */
            _animate() {
                this.animationId = requestAnimationFrame(() => this._animate());
                
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();
                
                // Update Kamera-Übergänge
                this._updateCamera(delta);
                
                // Update Partikel-Animation
                this._updateParticles(time);
                
                // Update PointLight-Position
                this.pointLight.position.x = Math.sin(time * 0.5) * 5;
                this.pointLight.position.z = Math.cos(time * 0.5) * 5;
                
                // Render
                this.renderer.render(this.scene, this.camera);
            },
            
            /**
             * Interpoliert Kamera-Position während Übergängen
             */
            _updateCamera(delta) {
                if (!this.cameraRig.isTransitioning) return;
                
                const now = performance.now();
                const elapsed = now - this.cameraRig.transitionStartTime;
                const progress = Math.min(elapsed / this.cameraRig.transitionDuration, 1);
                
                // Easing: easeInOutCubic
                const eased = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                // Interpoliere Position
                this.cameraRig.currentPos.lerpVectors(
                    this.cameraRig.currentPos,
                    this.cameraRig.targetPos,
                    eased * 0.1  // Smooth follow
                );
                
                // Interpoliere LookAt
                this.cameraRig.lookAtCurrent.lerpVectors(
                    this.cameraRig.lookAtCurrent,
                    this.cameraRig.lookAtTarget,
                    eased * 0.1
                );
                
                // Wende an
                this.camera.position.copy(this.cameraRig.currentPos);
                this.camera.lookAt(this.cameraRig.lookAtCurrent);
                
                // Prüfe Ende
                if (progress >= 1 && this.cameraRig.currentPos.distanceTo(this.cameraRig.targetPos) < 0.1) {
                    this.cameraRig.isTransitioning = false;
                }
            },
            
            /**
             * Partikel-Animation basierend auf aktuellem Mode
             */
            _updateParticles(time) {
                if (!this.particleMesh) return;
                
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                const currentMode = this._currentMode || 'breathe';
                
                for (let i = 0; i < this.particleCount; i++) {
                    const data = this.particleData[i];
                    let x, y, z, scale, opacity;
                    
                    switch (currentMode) {
                        case 'breathe':
                            // Sanfte Atmung: Y-Offset mit Sinus
                            const breathe = Math.sin(time * 2 + data.phase) * 0.3;
                            x = data.basePosition.x;
                            y = data.basePosition.y + breathe;
                            z = data.basePosition.z;
                            scale = 1 + Math.sin(time * 2 + data.phase) * 0.3;
                            color.setHex(0x00FFCC);
                            break;
                            
                        case 'tremble':
                            // Vibration: schnelle kleine Bewegungen
                            const tremble = Math.sin(time * 20 + data.phase) * 0.05;
                            x = data.currentPosition.x + tremble;
                            y = data.currentPosition.y + tremble;
                            z = data.currentPosition.z;
                            scale = 1;
                            color.setHex(0x00FFCC);
                            break;
                            
                        case 'chaos':
                            // Chaotische Bewegung mit Noise
                            const chaosX = Math.sin(time * 0.5 + data.phase) * 5 + Math.cos(time * 1.3 + i) * 2;
                            const chaosY = Math.cos(time * 0.7 + data.phase) * 3 + Math.sin(time * 0.9 + i) * 2;
                            const chaosZ = Math.sin(time * 0.3 + i * 0.1) * 5;
                            x = data.basePosition.x + chaosX;
                            y = data.basePosition.y + chaosY;
                            z = data.basePosition.z + chaosZ;
                            scale = 1 + Math.sin(time * 3 + i) * 0.2;
                            color.setHex(0xFF3366);  // Magenta für Chaos
                            break;
                            
                        case 'clash':
                            // Zwei gegnerische Gruppen
                            const isLeft = i % 2 === 0;
                            const groupX = isLeft ? -4 : 4;
                            const noiseX = Math.sin(time + data.phase) * 0.5;
                            const noiseY = Math.cos(time * 1.5 + data.phase) * 0.3;
                            x = groupX + noiseX;
                            y = data.basePosition.y * 0.5 + noiseY;
                            z = data.basePosition.z;
                            scale = isLeft ? 1.2 : 0.9;
                            color.setHex(isLeft ? 0x00FFCC : 0xFF3366);
                            break;
                            
                        case 'pyramid':
                        case 'pyramid_struggle':
                            // Pyramiden-Struktur
                            const row = Math.floor(Math.sqrt(i));
                            const col = i - row * row;
                            const pyramidX = (col - row / 2) * 0.8;
                            const pyramidY = row * 0.5 - 2;
                            const pyramidZ = -row * 0.3;
                            
                            // Eliten oben (größer, weiß)
                            if (data.isElite) {
                                x = (col - 5.5) * 0.5;
                                y = 4;
                                z = -5;
                                scale = 2;
                                color.setHex(0xFFFFFF);
                            } else {
                                x = pyramidX;
                                y = pyramidY;
                                z = pyramidZ;
                                scale = 0.7;
                                color.setHex(0x00FFCC);
                            }
                            
                            // Struggle-Animation
                            if (currentMode === 'pyramid_struggle' && !data.isElite) {
                                y += Math.sin(time * 3 + data.phase) * 0.2;
                            }
                            break;
                            
                        case 'pyramid_dissolve':
                            // Pyramide löst sich auf
                            const dissolveFactor = Math.min((time % 5) / 3, 1);
                            const explodeX = Math.sin(data.phase * 3) * 10 * dissolveFactor;
                            const explodeY = Math.cos(data.phase * 2) * 10 * dissolveFactor;
                            const explodeZ = Math.sin(data.phase * 4) * 10 * dissolveFactor;
                            x = data.currentPosition.x + explodeX * 0.1;
                            y = data.currentPosition.y + explodeY * 0.1;
                            z = data.currentPosition.z + explodeZ * 0.1;
                            scale = 1 - dissolveFactor * 0.5;
                            color.setHex(0xFF3366);
                            break;
                            
                        case 'stochastic':
                            // Explosion aus Zentrum
                            const angle = (i / this.particleCount) * Math.PI * 2;
                            const radius = 2 + Math.sin(time * 2 + data.phase) * 3;
                            const spread = Math.cos(time + i * 0.1) * 2;
                            x = Math.cos(angle) * radius + spread;
                            y = Math.sin(angle) * radius * 0.5 + spread * 0.5;
                            z = Math.sin(angle * 2) * radius * 0.5;
                            scale = 0.5 + Math.sin(time * 4 + i) * 0.5;
                            color.setHex(0x00FFCC);
                            break;
                            
                        case 'reset_to_grid':
                            // Kristallines Gitter
                            const gridCols = 15;
                            const gridX = (i % gridCols - gridCols / 2) * 1.2;
                            const gridY = (Math.floor(i / gridCols) - 6) * 0.8;
                            const gridZ = Math.sin(time + data.phase) * 0.5;
                            x = gridX;
                            y = gridY + 2;
                            z = gridZ - 10;
                            scale = 1 + Math.sin(time * 2 + data.phase) * 0.2;
                            color.setHex(0x00FFCC);
                            break;
                            
                        default:
                            x = data.basePosition.x;
                            y = data.basePosition.y;
                            z = data.basePosition.z;
                            scale = 1;
                            color.setHex(0x00FFCC);
                    }
                    
                    // Setze Transform
                    dummy.position.set(x, y, z);
                    dummy.scale.setScalar(scale);
                    dummy.updateMatrix();
                    this.particleMesh.setMatrixAt(i, dummy.matrix);
                    this.particleMesh.setColorAt(i, color);
                    
                    // Speichere aktuelle Position für nächsten Frame
                    data.currentPosition.set(x, y, z);
                }
                
                this.particleMesh.instanceMatrix.needsUpdate = true;
                if (this.particleMesh.instanceColor) {
                    this.particleMesh.instanceColor.needsUpdate = true;
                }
            },
            
            /**
             * Triggered einen Kamera-Übergang zu einem narrativen Knoten
             */
            navigateToNode(nodeKey) {
                const space = this.narrativeSpace[nodeKey];
                if (!space) {
                    console.warn(`[ISONOMIA3D] Unbekannter Knoten: ${nodeKey}`);
                    return;
                }
                
                // Setze Ziele
                this.cameraRig.targetPos.copy(space.camera);
                this.cameraRig.lookAtTarget.copy(space.lookAt);
                this._currentMode = space.particleMode;
                
                // Starte Übergang
                this.cameraRig.isTransitioning = true;
                this.cameraRig.transitionStartTime = performance.now();
                
                // Update Fog
                if (space.fog && this.scene.fog) {
                    this.scene.fog.color.setHex(space.fog.color);
                    this.scene.fog.near = space.fog.near;
                    this.scene.fog.far = space.fog.far;
                }
                
                console.log(`[ISONOMIA3D] Navigation zu: ${nodeKey}`);
            },
            
            /**
             * Setzt Partikel-Modus direkt (für Visual Mode Updates)
             */
            setParticleMode(mode) {
                this._currentMode = mode;
            },
            
            /**
             * Handler für Fenster-Resize
             */
            _setupResizeHandler() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },
            
            /**
             * Cleanup beim Verlassen
             */
            dispose() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                if (this.renderer) {
                    this.renderer.dispose();
                }
                if (this.particleMesh) {
                    this.particleMesh.geometry.dispose();
                    this.particleMesh.material.dispose();
                }
            }
        };

        // ==================================================================
        // SECTION 13: APPLICATION ENTRY POINT (Updated with 3D)
        // ==================================================================

        window.onload = () => {
            if (typeof anime === 'undefined') {
                document.body.innerHTML = `
                    <div style="display:flex;justify-content:center;align-items:center;height:100vh;color:#FF3366;font-family:sans-serif;text-align:center;padding:2rem;">
                        <div>
                            <h1>Systemfehler</h1>
                            <p>Animation-Engine nicht geladen.<br>Bitte Seite neu laden.</p>
                        </div>
                    </div>`;
                return;
            }
            
            // Versuche 3D zu initialisieren
            const use3D = ISONOMIA3D.init();
            
            // Initialisiere Haupt-Anwendung
            ISONOMIA.init();
            
            // Wenn 3D aktiv, verberge DOM-Partikel
            if (use3D) {
                const dots = document.querySelectorAll('.dot');
                dots.forEach(dot => dot.style.display = 'none');
                console.log('[ISONOMIA] 3D-Modus aktiviert, DOM-Partikel verborgen');
            }
        };
    </script>
</body>
</html>
