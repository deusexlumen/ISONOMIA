<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISONOMIA | Projekt Kronos</title>
    
    <!-- ================================================================== -->
    <!-- CSS: DESIGN TOKENS & LAYOUT                                        -->
    <!-- ================================================================== -->
    <style>
        /* ------------------------------------------------------------------ */
        /* 1. Design Tokens (Custom Properties)                               */
        /* ------------------------------------------------------------------ */
        :root {
            --bg: #050505;
            --cyan: #00FFCC;
            --magenta: #FF3366;
            --white: #FFFFFF;
            --text: #ffffff;
            --dim-text: rgba(255, 255, 255, 0.4);
            --font-main: 'Inter', -apple-system, sans-serif;
        }

        /* ------------------------------------------------------------------ */
        /* 2. Reset & Base Styles                                             */
        /* ------------------------------------------------------------------ */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body, html {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* ------------------------------------------------------------------ */
        /* 3. Particle System (Background Layer)                              */
        /* ------------------------------------------------------------------ */
        #particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        .dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--cyan);
            border-radius: 50%;
            opacity: 0.4;
            box-shadow: 0 0 10px var(--cyan);
            will-change: transform, opacity;
            transform: translateZ(0); /* Hardware acceleration */
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
        }

        .dot:hover {
            opacity: 1;
            transform: scale(2);
            box-shadow: 0 0 20px var(--cyan), 0 0 40px var(--cyan);
        }

        .dot.active {
            opacity: 1;
            transform: scale(2.5);
            background: var(--white);
            box-shadow: 0 0 30px var(--white), 0 0 60px var(--cyan);
        }

        /* Connection lines between particles */
        .connection-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, var(--cyan), transparent);
            transform-origin: left center;
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* ------------------------------------------------------------------ */
        /* 4. Stage & Content Layer                                           */
        /* ------------------------------------------------------------------ */
        #stage {
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }

        .message-box {
            max-width: 850px;
            padding: 3rem;
            text-align: center;
        }

        /* ------------------------------------------------------------------ */
        /* 5. Typography                                                      */
        /* ------------------------------------------------------------------ */
        .gandalf-voice h1 {
            font-weight: 300;
            font-size: 2.2rem;
            line-height: 1.4;
            letter-spacing: -0.5px;
            margin-bottom: 3.5rem;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.1);
        }
        
        /* Animated text characters */
        .animated-text {
            will-change: opacity, transform;
        }
        
        .text-char {
            display: inline-block;
            will-change: opacity, transform;
        }
        
        /* Enhanced button animations */
        .option-btn {
            will-change: opacity, transform;
            position: relative;
            overflow: hidden;
        }
        
        .option-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .option-btn:hover::before {
            left: 100%;
        }

        /* ------------------------------------------------------------------ */
        /* 6. Interactive Elements (Buttons)                                  */
        /* ------------------------------------------------------------------ */
        .button-group {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .haptic-btn {
            background: rgba(0, 255, 204, 0.03);
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 1.2rem 2.8rem;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            position: relative;
        }

        .haptic-btn:hover {
            background: var(--cyan);
            color: var(--bg);
            box-shadow: 0 0 50px var(--cyan);
            transform: translateY(-5px);
        }

        .haptic-btn:focus-visible {
            outline: 2px solid var(--cyan);
            outline-offset: 4px;
            background: var(--cyan);
            color: var(--bg);
        }

        .btn-small {
            padding: 0.8rem 1.5rem;
            font-size: 0.75rem;
        }

        /* ------------------------------------------------------------------ */
        /* 7. Navigation & Progress                                           */
        /* ------------------------------------------------------------------ */
        .nav-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid rgba(0, 255, 204, 0.1);
        }

        .progress-indicator {
            font-size: 0.75rem;
            color: var(--dim-text);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* ------------------------------------------------------------------ */
        /* 8. Resource Vault                                                  */
        /* ------------------------------------------------------------------ */
        .vault-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 2rem;
        }

        .vault-item {
            border: 1px solid var(--dim-text);
            padding: 1.5rem;
            color: white;
            text-decoration: none;
            transition: 0.3s;
            background: rgba(255, 255, 255, 0.02);
            text-align: left;
        }

        .vault-item:hover {
            border-color: var(--cyan);
            background: rgba(0, 255, 204, 0.1);
        }

        .vault-item:focus-visible {
            outline: 2px solid var(--cyan);
            outline-offset: 2px;
        }

        .vault-item span {
            display: block;
            font-size: 0.7rem;
            color: var(--dim-text);
            margin-top: 0.5rem;
        }

        /* ------------------------------------------------------------------ */
        /* 9. Accessibility: Reduced Motion                                   */
        /* ------------------------------------------------------------------ */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            .dot {
                opacity: 0.2 !important;
            }
        }

        /* ------------------------------------------------------------------ */
        /* 10. Share Dialog                                                   */
        /* ------------------------------------------------------------------ */
        .share-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .share-dialog-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        .share-dialog-content {
            position: relative;
            background: var(--bg);
            border: 1px solid var(--cyan);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
            z-index: 101;
        }

        .share-dialog-content h3 {
            color: var(--cyan);
            font-weight: 300;
            margin-bottom: 1.5rem;
        }

        .share-dialog-content textarea {
            width: 100%;
            height: 100px;
            background: rgba(0, 255, 204, 0.05);
            border: 1px solid rgba(0, 255, 204, 0.3);
            color: var(--text);
            padding: 1rem;
            font-family: var(--font-main);
            font-size: 0.9rem;
            resize: none;
            margin-bottom: 1.5rem;
        }

        .share-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .share-buttons button {
            background: transparent;
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 0.6rem 1.2rem;
            cursor: pointer;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        .share-buttons button:hover {
            background: var(--cyan);
            color: var(--bg);
        }

        .share-dialog-content .close-btn {
            background: transparent;
            border: none;
            color: var(--dim-text);
            cursor: pointer;
            font-size: 0.8rem;
        }

        .share-dialog-content .close-btn:hover {
            color: var(--cyan);
        }

        /* ------------------------------------------------------------------ */
        /* 11. Lottery Simulation                                             */
        /* ------------------------------------------------------------------ */
        .lottery-card {
            border: 2px solid var(--cyan);
            padding: 2rem;
            background: rgba(0, 255, 204, 0.03);
            max-width: 400px;
            margin: 0 auto;
        }

        .lottery-card.shuffling {
            opacity: 0.7;
            transform: scale(0.95);
        }

        .lottery-card.winner {
            border-color: var(--white);
            box-shadow: 0 0 40px rgba(0, 255, 204, 0.2);
        }

        .lottery-winner-badge {
            background: var(--cyan);
            color: var(--bg);
            padding: 0.3rem 1rem;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: inline-block;
            margin-bottom: 1rem;
        }

        .lottery-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .lottery-name {
            font-size: 1.3rem;
            margin-bottom: 0.3rem;
        }

        .lottery-job {
            color: var(--dim-text);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .lottery-bio {
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text);
        }

        @keyframes lotteryReveal {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* ------------------------------------------------------------------ */
        /* 12. System Check Animation (Priming)                               */
        /* ------------------------------------------------------------------ */
        .system-check-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
        }

        .system-check-container {
            text-align: center;
            max-width: 600px;
            padding: 2rem;
        }

        .system-check-title {
            font-size: 1.2rem;
            color: var(--cyan);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 3rem;
            opacity: 0;
            animation: fadeInOut 2s ease-in-out forwards;
        }

        .interval-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 3rem;
        }

        .interval-node {
            width: 60px;
            height: 60px;
            border: 1px solid var(--dim-text);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: var(--dim-text);
            position: relative;
            opacity: 0;
            transform: scale(0.8);
        }

        .interval-node.active {
            border-color: var(--cyan);
            color: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
            opacity: 1;
            transform: scale(1);
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .interval-node.checking {
            animation: pulseCheck 0.6s ease-in-out;
        }

        .interval-node.verified {
            border-color: var(--cyan);
            background: rgba(0, 255, 204, 0.1);
        }

        .interval-node.verified::after {
            content: '✓';
            position: absolute;
            color: var(--cyan);
            font-size: 1.2rem;
        }

        @keyframes pulseCheck {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 rgba(0, 255, 204, 0); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px rgba(0, 255, 204, 0.5); }
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(10px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        .system-check-status {
            font-size: 0.9rem;
            color: var(--dim-text);
            min-height: 2rem;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .system-check-status.visible {
            opacity: 1;
        }

        .system-check-complete {
            font-size: 1.5rem;
            color: var(--cyan);
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .system-check-complete.visible {
            opacity: 1;
            transform: scale(1);
        }

        /* ------------------------------------------------------------------ */
        /* 13. Patch Counter (Soziale Validierung)                            */
        /* ------------------------------------------------------------------ */
        .patch-counter {
            background: rgba(0, 255, 204, 0.05);
            border: 1px solid var(--cyan);
            padding: 1.5rem;
            text-align: center;
            margin: 2rem 0;
        }

        .patch-counter-number {
            font-size: 3rem;
            font-weight: 300;
            color: var(--cyan);
            line-height: 1;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }

        .patch-counter-label {
            font-size: 0.75rem;
            color: var(--dim-text);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .patch-counter-live {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
            font-size: 0.8rem;
            color: var(--dim-text);
        }

        .live-indicator {
            width: 8px;
            height: 8px;
            background: var(--cyan);
            border-radius: 50%;
            animation: livePulse 2s ease-in-out infinite;
        }

        @keyframes livePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        /* ------------------------------------------------------------------ */
        /* 14. System Check Progress Bar                                      */
        /* ------------------------------------------------------------------ */
        .system-check-progress {
            width: 100%;
            max-width: 400px;
            height: 2px;
            background: rgba(0, 255, 204, 0.1);
            margin: 2rem auto;
            position: relative;
            overflow: hidden;
        }

        .system-check-progress-bar {
            height: 100%;
            background: var(--cyan);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--cyan);
        }

        .system-check-progress-text {
            font-size: 0.75rem;
            color: var(--dim-text);
            text-align: center;
            margin-top: 0.5rem;
            letter-spacing: 1px;
        }

        /* ------------------------------------------------------------------ */
        /* 15. Responsive Adjustments                                         */
        /* ------------------------------------------------------------------ */
        @media (max-width: 768px) {
            .message-box {
                padding: 1.5rem;
            }
            .gandalf-voice h1 {
                font-size: 1.6rem;
                margin-bottom: 2rem;
            }
            .vault-grid {
                grid-template-columns: 1fr;
            }
            .haptic-btn {
                padding: 1rem 2rem;
                font-size: 0.8rem;
            }
            .interval-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.5rem;
            }
            .interval-node {
                width: 40px;
                height: 40px;
                font-size: 0.6rem;
            }
            .patch-counter-number {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Background: Particle System -->
    <div id="particle-container"></div>
    
    <!-- Foreground: Content Stage -->
    <main id="stage" role="main" aria-live="polite" aria-atomic="true">
        <div id="content-layer" class="message-box"></div>
    </main>

    <!-- Animation Library -->
    <script src="anime.umd.min.js"></script>
    
    <!-- 3D Engine (Three.js) -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <!-- Application Logic -->
    <script>
        // ==================================================================
        // SECTION 1: NARRATIVE DATA
        // ==================================================================
        
        /**
         * NARRATIVE DATASET: PROJEKT KRONOS
         * Dialektische Knotenpunkte basierend auf der Systemdiagnose.
         * 
         * Structure:
         *   - key: Unique identifier for the narrative node
         *   - text: The narrative content displayed to the user
         *   - options: Array of choices leading to next nodes
         *   - visual: Particle animation mode triggered on this node
         */

        // ==================================================================
        // EVENT SYSTEM (Loose Coupling Architecture)
        // ==================================================================
        
        const EventBus = {
            events: {},
            
            on(event, callback) {
                if (!this.events[event]) this.events[event] = [];
                this.events[event].push(callback);
                return () => this.off(event, callback);
            },
            
            off(event, callback) {
                if (!this.events[event]) return;
                this.events[event] = this.events[event].filter(cb => cb !== callback);
            },
            
            emit(event, data) {
                if (!this.events[event]) return;
                this.events[event].forEach(callback => {
                    try {
                        callback(data);
                    } catch (err) {
                        console.error(`[EventBus] Error in handler for ${event}:`, err);
                    }
                });
            }
        };

        // Animation Controller for proper cleanup
        const AnimationController = {
            activeAnimations: new Map(),
            
            register(id, animation) {
                this.cancel(id);
                this.activeAnimations.set(id, animation);
            },
            
            cancel(id) {
                const anim = this.activeAnimations.get(id);
                if (anim && anim.pause) {
                    anim.pause();
                }
                this.activeAnimations.delete(id);
            },
            
            cancelAll() {
                this.activeAnimations.forEach(anim => {
                    if (anim && anim.pause) anim.pause();
                });
                this.activeAnimations.clear();
            }
        };

        // XSS Sanitization utility
        const Sanitizer = {
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            sanitizeTemplate(strings, ...values) {
                return strings.reduce((result, string, i) => {
                    const value = values[i];
                    if (value === undefined) return result + string;
                    return result + string + this.escapeHtml(String(value));
                }, '');
            }
        };

        // ==================================================================
        // PSYCHOLOGISCHES JUDO - USER PROFILING SYSTEM
        // ==================================================================
        
        const UserProfile = {
            // Dimension 1: Politisches Interesse
            engagementLevel: null, // 'engaged' | 'casual' | 'avoidant'
            
            // Dimension 2: Skepsis-Ausrichtung
            skepticismType: null, // 'system' | 'trust' | 'agency'
            
            // Dimension 3: Werteorientierung
            valueAnchor: null, // 'patriot' | 'pragmatist' | 'idealist' | 'skeptic'
            
            // Dimension 4: Commitment-History (Micro-Commits)
            commitments: [],
            commitmentScore: 0,
            
            // Dimension 5: Einwände (Objektionen)
            raisedObjections: [],
            resolvedObjections: [],
            
            // Dimension 6: Interaktions-Muster
            nodeVisitTimes: {},
            backtrackCount: 0,
            pathTaken: [],
            totalTime: 0,
            
            // Session Start
            sessionStart: Date.now(),
            
            /**
             * Setzt ein Profil-Attribut
             */
            set(attribute, value) {
                if (this.hasOwnProperty(attribute)) {
                    this[attribute] = value;
                    this._persist();
                }
            },
            
            /**
             * Fügt einen Commitment hinzu
             */
            addCommitment(nodeId, agreed, context = '') {
                this.commitments.push({
                    nodeId,
                    agreed,
                    context,
                    timestamp: Date.now()
                });
                
                // Berechne Commitment-Score (0-100)
                const yesCommits = this.commitments.filter(c => c.agreed).length;
                this.commitmentScore = Math.min((yesCommits / 5) * 100, 100);
                
                this._persist();
            },
            
            /**
             * Verzeichnet einen Knoten-Besuch mit Zeit
             */
            recordNodeVisit(nodeId) {
                this.pathTaken.push(nodeId);
                this.nodeVisitTimes[nodeId] = Date.now();
                this._persist();
            },
            
            /**
             * Erfasst einen Einwand
             */
            recordObjection(objectionType) {
                if (!this.raisedObjections.includes(objectionType)) {
                    this.raisedObjections.push(objectionType);
                    this._persist();
                }
            },
            
            /**
             * Markiert einen Einwand als gelöst
             */
            resolveObjection(objectionType) {
                if (!this.resolvedObjections.includes(objectionType)) {
                    this.resolvedObjections.push(objectionType);
                }
                this._persist();
            },
            
            /**
             * Prüft, ob ein Einwand bereits gelöst wurde
             */
            isObjectionResolved(objectionType) {
                return this.resolvedObjections.includes(objectionType);
            },
            
            /**
             * Liefert ein Profil-Summary für dynamische Texte
             */
            getSummary() {
                const timeSpent = Math.floor((Date.now() - this.sessionStart) / 1000);
                return {
                    engagementLevel: this.engagementLevel,
                    valueAnchor: this.valueAnchor,
                    commitmentScore: this.commitmentScore,
                    commitmentsCount: this.commitments.filter(c => c.agreed).length,
                    pathLength: this.pathTaken.length,
                    timeSpent,
                    objectionsRaised: this.raisedObjections.length,
                    objectionsResolved: this.resolvedObjections.length
                };
            },
            
            /**
             * Bestimmt den optimalen Pfad basierend auf Profil
             */
            getRecommendedPath() {
                const paths = {
                    'engaged-patriot': ['patriot_hook', 'patriot_crisis', 'patriot_solution'],
                    'engaged-skeptic': ['skeptic_data', 'skeptic_proof', 'skeptic_convert'],
                    'casual-pragmatist': ['pragmatist_problem', 'pragmatist_benefit', 'pragmatist_action'],
                    'avoidant-idealist': ['idealist_vision', 'idealist_principle', 'idealist_join'],
                    'default': ['hook', 'path_parties_start', 'path_expert_logic']
                };
                
                const key = `${this.engagementLevel}-${this.valueAnchor}`;
                return paths[key] || paths['default'];
            },
            
            /**
             * Persistiert Profil in SessionStorage
             */
            _persist() {
                try {
                    const data = {
                        engagementLevel: this.engagementLevel,
                        skepticismType: this.skepticismType,
                        valueAnchor: this.valueAnchor,
                        commitments: this.commitments,
                        commitmentScore: this.commitmentScore,
                        raisedObjections: this.raisedObjections,
                        resolvedObjections: this.resolvedObjections,
                        pathTaken: this.pathTaken,
                        backtrackCount: this.backtrackCount
                    };
                    sessionStorage.setItem('isonomia_profile', JSON.stringify(data));
                } catch (e) {
                    console.warn('[UserProfile] Could not persist:', e);
                }
            },
            
            /**
             * Lädt Profil aus SessionStorage
             */
            load() {
                try {
                    const data = JSON.parse(sessionStorage.getItem('isonomia_profile'));
                    if (data) {
                        Object.assign(this, data);
                    }
                } catch (e) {
                    console.warn('[UserProfile] Could not load:', e);
                }
            },
            
            /**
             * Löscht Profil
             */
            clear() {
                this.engagementLevel = null;
                this.skepticismType = null;
                this.valueAnchor = null;
                this.commitments = [];
                this.commitmentScore = 0;
                this.raisedObjections = [];
                this.resolvedObjections = [];
                this.pathTaken = [];
                this.backtrackCount = 0;
                sessionStorage.removeItem('isonomia_profile');
            }
        };
        
        // Lade gespeichertes Profil beim Start
        UserProfile.load();
        
        // ==================================================================
        // OBJECTION HANDLING SYSTEM
        // ==================================================================
        
        const ObjectionHandler = {
            database: {
                'practicality': {
                    patterns: [/funktioniert nicht/i, /realität/i, /praxis/i, /umsetzbar/i],
                    priority: 1,
                    responses: {
                        'pragmatist': "In Athen hat es 200 Jahre funktioniert. Was ist pragmatischer als bewährte Lösungen?",
                        'patriot': "Deutschland hat Systemwechsel gemeistert. 1989. 1949. Wir können das.",
                        'skeptic': "Richtig. Deshalb brauchen wir einen Testzeitraum. Ein Experiment.",
                        'idealist': "Träume scheitern an Umsetzung. Deshalb: Ein Jahr Test, dann entscheiden wir.",
                        'default': "Das Athenische System funktionierte 200 Jahre. Das ist mehr als unser aktuelles System geschafft hat."
                    }
                },
                'qualification': {
                    patterns: [/qualifikation/i, /kompetenz/i, /wissen/i, /fachkenntnis/i, /experten/i],
                    priority: 2,
                    responses: {
                        'pragmatist': "Wäre Deutschland 1949 qualifizierter mit Akademikern? Oder mit Weisheit?",
                        'patriot': "Die Weimarer Republik hatte Experten. Die BRD hatte Visionäre. Was hat funktioniert?",
                        'skeptic': "Zeig mir die Studie, die sagt, dass Akademiker bessere Gesetze schreiben.",
                        'idealist': "Jeder Mensch hat ein Recht auf Mitsprache. Das ist die höchste Qualifikation.",
                        'default': "87% Akademiker im Bundestag bei 20% in der Bevölkerung. Ist das Repräsentation?"
                    }
                },
                'corruption': {
                    patterns: [/korruption/i, /bestechung/i, /geld/i, / lobbying/i, / kaufen/i],
                    priority: 3,
                    responses: {
                        'pragmatist': "Ein Jahr Amtszeit. Dann wieder Bürger. Weniger Zeit für Korruption als heute.",
                        'patriot': "Korruption braucht Zeit und Netzwerke. Das Los zerstört beides.",
                        'skeptic': "Weniger Korruption als heute wäre bereits ein Fortschritt.",
                        'idealist': "Gerechtigkeit beginnt mit Unbestechlichkeit. Das Los kennt keine Günstlinge.",
                        'default': "Karrierepolitiker brauchen Jahre für Korruption. Bürger haben nur ein Jahr."
                    }
                },
                'time': {
                    patterns: [/zeit/i, /aufwand/i, /aufwändig/i, /kompliziert/i],
                    priority: 4,
                    responses: {
                        'pragmatist': "Wie viel Zeit verlieren wir heute an sinnlose Debatten?",
                        'patriot': "Freiheit braucht Zeit. Aber Sklaverei braucht mehr.",
                        'skeptic': "Berechnung: 1 Jahr Dienst alle 20 Jahre vs. tägliche Politik-Frust.",
                        'idealist': "Die beste Zeit für Gerechtigkeit ist jetzt.",
                        'default': "Ein Jahr alle zwanzig. Weniger Zeit als heute für Steuererklärung."
                    }
                },
                'extremism': {
                    patterns: [/extrem/i, /radikal/i, /gefährlich/i, /unverantwortlich/i],
                    priority: 5,
                    responses: {
                        'pragmatist': "Radikal ist, das Scheitern fortzusetzen und andere Ergebnisse zu erwarten.",
                        'patriot': "Unser Grundgesetz war radikal. 1949. Heute ist es Normalität.",
                        'skeptic': "Was ist radikaler: Evolution oder Revolution?",
                        'idealist': "Extrem ist Ungerechtigkeit. Moderat ist Isonomie.",
                        'default': "Radikal wäre, nichts zu ändern. Evolution ist weise."
                    }
                }
            },
            
            /**
             * Analysiert Text auf Einwände
             */
            detectObjection(text) {
                for (const [type, data] of Object.entries(this.database)) {
                    for (const pattern of data.patterns) {
                        if (pattern.test(text)) {
                            return type;
                        }
                    }
                }
                return null;
            },
            
            /**
             * Liefert passende Antwort auf Einwand
             */
            getResponse(objectionType, userProfile) {
                const data = this.database[objectionType];
                if (!data) return null;
                
                const anchor = userProfile.valueAnchor || 'default';
                return data.responses[anchor] || data.responses['default'];
            },
            
            /**
             * Prüft, ob ein Knoten einen Einwand behandeln sollte
             */
            shouldHandleObjection(currentNodeId, userProfile) {
                // Wenn ungelöste Einwände existieren, behandle den wichtigsten
                const unresolved = userProfile.raisedObjections.filter(
                    o => !userProfile.isObjectionResolved(o)
                );
                
                if (unresolved.length === 0) return false;
                
                // Priorisiere nach Schwere
                const priorities = unresolved.map(o => this.database[o]?.priority || 99);
                const highestPriority = Math.min(...priorities);
                const topObjection = unresolved.find(
                    o => this.database[o]?.priority === highestPriority
                );
                
                return topObjection;
            }
        };
        
        // ==================================================================
        // NEUER NARRATIVER ENTSCHEIDUNGSBAUM v3.0
        // Logik-basiert, nicht überzeugend. Jede Antwort führt weiter.
        // Bei "Nein" wird die Meinung akzeptiert, nicht überstimmt.
        // ==================================================================
        
// ==================================================================
// KOMPLETTER NEUER NARRATIVER ENTSCHEIDUNGSBAUM v4.0
// Gandalf-Protokoll - Psychologische Dekonstruktion
// ==================================================================

const narrativeData = {
    
    // ═══════════════════════════════════════════════════════════════
    // PHASE 0: ENTRY - DER HAKEN
    // ═══════════════════════════════════════════════════════════════
    
    "start": {
        "text": "Willkommen im Kontrollraum. Du glaubst, du verstehst Demokratie. Süß. Aber hier ist die Frage: Verstehst du das System – oder nur die Illusion, die sie dir verkauft haben?",
        "options": [
            { "label": "Zeig mir die Matrix", "next": "entry_wake", "profileSet": { "engagementLevel": "engaged" } },
            { "label": "Ich bin skeptisch", "next": "entry_skeptic", "profileSet": { "engagementLevel": "casual", "skepticismType": "trust" } },
            { "label": "Nein, danke", "next": "exit_respectful", "profileSet": { "engagementLevel": "avoidant" } }
        ],
        "visual": "breathe",
        "phase": "entry"
    },
    
    "entry_wake": {
        "text": "Gut. Du hast die rote Pille in Betracht gezogen. Das ist mehr, als die meisten tun. Aber sei gewarnt: Was du gleich siehst, kann nicht ungesehen werden. Dein Demokratie-Betriebssystem wird crashen. Bereit?",
        "options": [
            { "label": "Crash das System", "next": "problem_entry", "commitment": true },
            { "label": "Erst eine Warnung", "next": "entry_warning" },
            { "label": "Doch lieber nicht", "next": "exit_blue_pill" }
        ],
        "visual": "tremble",
        "phase": "entry"
    },
    
    "entry_warning": {
        "text": "Die Warnung ist einfach: Du wirst nicht mehr mit Halbheiten zufrieden sein können. Du wirst sehen, warum deine Stimme bedeutungslos ist. Warum Politiker nicht für dich arbeiten. Das ist der Preis der Erkenntnis.",
        "options": [
            { "label": "Ich zahle den Preis", "next": "problem_entry", "commitment": true },
            { "label": "Zu teuer", "next": "exit_cost" }
        ],
        "visual": "chaos",
        "phase": "entry"
    },
    
    "entry_skeptic": {
        "text": "Intelligenter Instinkt. Das Internet ist voll von Verkäufern. Aber wir sind nicht sie. Wir sind die, die dir zeigen, dass du bereits gekauft wurdest – von einem System, das dir Wahlen als Freiheit verkauft.",
        "options": [
            { "label": "Wer hat mich gekauft?", "next": "problem_entry" },
            { "label": "Das klingt paranoid", "next": "entry_paranoia" },
            { "label": "Ich gehe", "next": "exit_respectful" }
        ],
        "visual": "tremble",
        "phase": "entry"
    },
    
    "entry_paranoia": {
        "text": "Paranoia. Ein Wort der Mächtigen, um Wahrheitssucher zu diskreditieren. Aber was ist paranoid daran, Strukturen zu benennen? Wenn ich sage 'der Himmel ist blau', ist das Paranoia oder Beobachtung?",
        "options": [
            { "label": "Zeig mir die Strukturen", "next": "problem_entry" },
            { "label": "Ich bleibe skeptisch", "next": "problem_elite_reveal" }
        ],
        "visual": "breathe",
        "phase": "entry"
    },
    
    // ═══════════════════════════════════════════════════════════════
    // PHASE 1: PROBLEM - DIE DIAGNOSE
    // ═══════════════════════════════════════════════════════════════
    
    "problem_entry": {
        "text": "Lass uns mit dem Schmerz beginnen. Das Gefühl, wenn du siehst, wie Entscheidungen gegen den Willen der Mehrheit getroffen werden. Wie lautet dieser Schmerz?",
        "options": [
            { "label": "Ich fühle mich machtlos", "next": "problem_power", "profileSet": { "valueAnchor": "pragmatist" } },
            { "label": "Ich fühle mich nicht gehört", "next": "problem_voice", "profileSet": { "valueAnchor": "idealist" } },
            { "label": "Ich fühle mich verarscht", "next": "problem_deception", "profileSet": { "valueAnchor": "skeptic" } },
            { "label": "Kein Schmerz", "next": "problem_complicity", "profileSet": { "valueAnchor": "patriot" } }
        ],
        "visual": "breathe",
        "phase": "problem"
    },
    
    "problem_power": {
        "text": "Machtlosigkeit. Das Gift der Demokratie. Du lebst in einem System, das behauptet, vom Volk zu sein – aber du hast keine Macht. Nur alle vier Jahre einen Stimmzettel, der sofort vergessen wird. Stimmt das?",
        "options": [
            { "label": "Genau das", "next": "problem_power_deep" },
            { "label": "Ich protestiere", "next": "problem_protest" },
            { "label": "Ich wähle anders", "next": "problem_vote_different" }
        ],
        "visual": "pyramid_struggle",
        "phase": "problem"
    },
    
    "problem_voice": {
        "text": "Nicht gehört. 83 Millionen Menschen. Eine Stimme. Die Mathematik ist brutal. Aber hier ist der Twist: Du wurdest designed, um nicht gehört zu werden. Willst du wissen, wie?",
        "options": [
            { "label": "Zeig mir das Design", "next": "problem_design_reveal" },
            { "label": "Ich bin zu müde", "next": "problem_fatigue" }
        ],
        "visual": "chaos",
        "phase": "problem"
    },
    
    "problem_deception": {
        "text": "Verarscht. Ein rohes Wort für eine rohe Wahrheit. Du hast recht. Du wirst täglich verarscht von Menschen, die lächeln, während sie lügen. Die dir Demokratie versprechen und Aristokratie liefern. Warum lässt du es zu?",
        "options": [
            { "label": "Weil ich keine Wahl habe", "next": "problem_no_choice" },
            { "label": "Weil ich es nicht ändern kann", "next": "problem_learned_helplessness" }
        ],
        "visual": "clash",
        "phase": "problem"
    },
    
    "problem_complicity": {
        "text": "Kein Schmerz. Dann gehörst du zu den Wenigen, die vom System profitieren. Oder zu den Vielen, die es nicht verstanden haben. Welcher bist du?",
        "options": [
            { "label": "Ich profitiere", "next": "problem_privilege" },
            { "label": "Ich schlafe vielleicht", "next": "problem_wake_attempt" }
        ],
        "visual": "pyramid",
        "phase": "problem"
    },
    
    "problem_power_deep": {
        "text": "Du hast keine Macht. Aber das Schlimme: Du glaubst, du hättest welche. Du gehst wählen. Du protestierst. Und du denkst, das ändert etwas. Nichts davon funktioniert. Warum?",
        "options": [
            { "label": "Warum?", "next": "logic_why_no_power" },
            { "label": "Doch, Wahlen wirken", "next": "logic_elections_ineffective" }
        ],
        "visual": "pyramid_dissolve",
        "phase": "problem"
    },
    
    "problem_design_reveal": {
        "text": "Das Design heißt 'Repräsentative Demokratie'. Klingt gut. Aber hier ist der Hack: Sobald du gewählt hast, hast du keine Kontrolle mehr. Kein Rückruf. Keine Bindung an Versprechen. Nur eine neue Aristokratie, die alle vier Jahre neu gemischt wird.",
        "options": [
            { "label": "Aber wir können abwählen", "next": "logic_accountability" },
            { "label": "Was wäre die Alternative?", "next": "solution_hint" }
        ],
        "visual": "pyramid",
        "phase": "problem"
    },
    
    "problem_no_choice": {
        "text": "Keine Wahl. Das ist die Lüge, die dir am tiefsten eingetrichtert wurde. Du glaubst, du musst das System akzeptieren, weil es das Einzige ist. Aber das ist so, als würde ein Gefangener sagen, er habe keine Wahl, als welche Wand er starrt.",
        "options": [
            { "label": "Wie reisst man die Wand ein?", "next": "solution_wall" },
            { "label": "Zu riskant", "next": "fear_risk" }
        ],
        "visual": "clash",
        "phase": "problem"
    },
    
    "problem_elite_reveal": {
        "text": "Es regiert nicht das Volk. Es regiert: Konzerne, die Gesetze schreiben. Parteien, die Macht horten. Eliten, die fernab des Volkes entscheiden. Du bist nicht der Souverän. Du bist der Konsument einer Politik-Show.",
        "options": [
            { "label": "Beweise es", "next": "logic_evidence" },
            { "label": "Wie ändern wir das?", "next": "solution_search" }
        ],
        "visual": "pyramid",
        "phase": "problem"
    },
    
    "problem_protest": {
        "text": "Protest. Die Ventil-Funktion des Systems. Du gehst auf die Straße. Du schreist. Du fühlst dich stark. Und dann? Dann geht die Politik ihren Weg. Fridays for Future? Ignoriert. Corona-Proteste? Ignoriert. Warum? Weil Protest nichts kostet. Weil Protest nichts ändert.",
        "options": [
            { "label": "Was würde ändern?", "next": "logic_real_change" },
            { "label": "Aber die Geschichte zeigt...", "next": "logic_history_lessons" }
        ],
        "visual": "chaos",
        "phase": "problem"
    },
    
    "problem_vote_different": {
        "text": "Anders wählen. Die logische Reaktion. Aber: Hast du das nicht schon versucht? Kleinere Parteien? Große? Links? Rechts? Und was war das Ergebnis? Dieselbe Politik. Dieselben Enttäuschungen. Weil das System filtert. Es filtert nach Geld. Nach Macht. Nach Karriere.",
        "options": [
            { "label": "Wenigstens habe ich es versucht", "next": "logic_attempt_value" },
            { "label": "Es ändert sich nie etwas", "next": "logic_system_rigged" }
        ],
        "visual": "clash",
        "phase": "problem"
    },
    
    "problem_privilege": {
        "text": "Ehrlich. Das ist selten. Du profitierst. Vom Status quo. Von der Stabilität. Von der Tatsache, dass andere den Preis zahlen. Aber hier ist die Frage: Wie lange noch? Wenn das System kollabiert – und es wird kollabieren – fällt der Privilegierte am härtesten.",
        "options": [
            { "label": "Warum wird es kollabieren?", "next": "fear_collapse" },
            { "label": "Ich will nicht dazugehören", "next": "solution_reject_privilege" }
        ],
        "visual": "pyramid",
        "phase": "problem"
    },
    
    "problem_fatigue": {
        "text": "Müde. Das verstehe ich. Das System ist designed, um dich müde zu machen. Mit komplexen Debatten. Mit endlosen Skandalen. Mit der Illusion von Veränderung, die nie kommt. Die Müdigkeit ist Teil der Kontrolle.",
        "options": [
            { "label": "Wie überwinde ich die Müdigkeit?", "next": "solution_energy" },
            { "label": "Ich kann nicht mehr", "next": "exit_fatigue" }
        ],
        "visual": "tremble",
        "phase": "problem"
    },
    
    "problem_learned_helplessness": {
        "text": "Gelernte Hilflosigkeit. Das perfekte Wort. Du hast gelernt, dass deine Handlungen keine Konsequenzen haben. Dass deine Stimme nicht zählt. Dieses Lernen ist das Ziel des Systems. Ein gehorsames Volk, das glaubt, es könne nichts ändern.",
        "options": [
            { "label": "Wie entlerne ich das?", "next": "solution_unlearn" },
            { "label": "Aber es ist doch wahr", "next": "logic_truth_trap" }
        ],
        "visual": "pyramid_struggle",
        "phase": "problem"
    },
    
    "problem_wake_attempt": {
        "text": "Schlafend. Das sind die meisten. Sie träumen von Demokratie, während sie in einer Aristokratie leben. Sie wählen alle vier Jahre und glauben, sie hätten entschieden. Möchtest du aufwachen? Wirklich aufwachen?",
        "options": [
            { "label": "Weck mich", "next": "problem_awakening" },
            { "label": "Der Schlaf ist bequem", "next": "exit_comfort" }
        ],
        "visual": "breathe",
        "phase": "problem"
    },
    
    "problem_awakening": {
        "text": "Das Erwachen ist schmerzhaft. Du wirst nicht mehr dieselbe Person sein. Du wirst Meetings hassen, in denen über Demokratie geredet wird. Du wirst Wahlen als das sehen, was sie sind: Theater. Bist du bereit für diesen Schmerz?",
        "options": [
            { "label": "Ich bin bereit", "next": "fear_intro", "commitment": true },
            { "label": "Vielleicht später", "next": "exit_not_ready" }
        ],
        "visual": "chaos",
        "phase": "problem"
    },
    
    // ═══════════════════════════════════════════════════════════════
    // PHASE 2: FEAR - DIE ANGST VOR DEM UNTERGANG
    // ═══════════════════════════════════════════════════════════════
    
    "fear_intro": {
        "text": "Gut. Du bist wach. Jetzt kommt die schwierige Frage: Was fürchtest du? Nicht persönlich. Politisch. Was fürchtest du für dieses Land? Denn hier ist die Wahrheit: Das System, das wir haben, ist nicht stabil. Es bröckelt. Und wenn es fällt, fällt es auf uns.",
        "options": [
            { "label": "Ich fürchte den Faschismus", "next": "fear_fascism" },
            { "label": "Ich fürchte den Zusammenbruch", "next": "fear_collapse" },
            { "label": "Ich fürchte die Zukunft", "next": "fear_future" }
        ],
        "visual": "tremble",
        "phase": "fear"
    },
    
    "fear_fascism": {
        "text": "Faschismus. Der deutsche Albtraum. Aber hier ist der Twist: Faschismus kommt nicht mit Hakenkreuzen. Er kommt mit Smileys. Mit 'Sicherheit'. Mit 'Ordnung'. Er kommt, wenn das Volk so verängstigt ist, dass es Freiheit für Schutz opfert. Siehst du die Anzeichen?",
        "options": [
            { "label": "Ja, ich sehe sie", "next": "fear_fascism_signs" },
            { "label": "Nein, das ist übertrieben", "next": "fear_denial" },
            { "label": "Das Grundgesetz schützt uns", "next": "fear_constitution" }
        ],
        "visual": "clash",
        "phase": "fear"
    },
    
    "fear_fascism_signs": {
        "text": "Du siehst sie. Gut. Dann siehst du auch: Parteien, die Minderheiten angreifen. Gesetze, die Demonstrieren kriminalisieren. Medien, die eine Meinung propagieren. Das sind nicht Einzelfälle. Das ist das Muster. Das ist der Anfang.",
        "options": [
            { "label": "Was können wir tun?", "next": "solution_urgent" },
            { "label": "Ich fühle mich ohnmächtig", "next": "fear_powerlessness" }
        ],
        "visual": "pyramid_struggle",
        "phase": "fear"
    },
    
    "fear_collapse": {
        "text": "Zusammenbruch. Nicht plötzlich. Nicht mit einem Knall. Sondern langsam. Stück für Stück. Erst die Infrastruktur. Dann die soziale Kohäsion. Dann das Vertrauen. Wir sind mitten drin. Siehst du es nicht? Die Krankenhäuser. Die Bahn. Die Politik. Alles bröckelt.",
        "options": [
            { "label": "Warum passiert das?", "next": "logic_decay" },
            { "label": "Können wir es stoppen?", "next": "solution_stop_collapse" }
        ],
        "visual": "pyramid_dissolve",
        "phase": "fear"
    },
    
    "fear_future": {
        "text": "Die Zukunft. Ungewiss. Bedrohlich. Klima. Krieg. KI. Alles kommt gleichzeitig. Und unser politisches System? Es ist nicht designed für komplexe Probleme. Es ist designed für vier-Jahres-Zyklen. Für Schnellschüsse. Für Populismus. Wir fahren mit einem Pferdewagen auf der Autobahn der Geschichte.",
        "options": [
            { "label": "Wir brauchen ein neues System", "next": "solution_needed" },
            { "label": "Aber Technokratie?", "next": "logic_technocracy" }
        ],
        "visual": "chaos",
        "phase": "fear"
    },
    
    "fear_denial": {
        "text": "Übertrieben. Das denken wir immer. Bis es zu spät ist. 1932 dachten die Menschen auch, es wäre übertrieben. 1933 wussten sie es besser. Die Geschichte wiederholt sich nicht – sie reimt sich. Und die Reime sind beunruhigend.",
        "options": [
            { "label": "Erzähl mir von den Reimen", "next": "logic_history_rhyme" },
            { "label": "Deutschland ist anders", "next": "logic_germany_special" }
        ],
        "visual": "tremble",
        "phase": "fear"
    },
    
    "fear_constitution": {
        "text": "Das Grundgesetz. Unsere Werte. Unser Schutz. Wie viele Verfassungen hat die Welt gesehen? Wie viele haben gehalten, wenn das Volk sie nicht verteidigte? Papier allein schützt nicht. Nie. Nirgends.",
        "options": [
            { "label": "Wer schützt die Verfassung?", "next": "logic_protection" },
            { "label": "Wir müssen sie stärken", "next": "solution_strengthen" }
        ],
        "visual": "breathe",
        "phase": "fear"
    },
    
    "fear_powerlessness": {
        "text": "Ohnmacht. Die rationalste Reaktion auf ein absurdes System. Aber hier ist die Wahrheit: Du bist nicht ohnmächtig. Du wurdest ohnmächtig gemacht. Durch ein System, das deine Stimme neutralisiert. Durch Parteien, die dich ignorieren. Das kann man ändern.",
        "options": [
            { "label": "Wie?", "next": "solution_how" },
            { "label": "Ich habe das schon gehört", "next": "logic_promises" }
        ],
        "visual": "pyramid_struggle",
        "phase": "fear"
    },
    
    // ═══════════════════════════════════════════════════════════════
    // PHASE 3: LOGIC - DIE BRÜCKE (Vom Problem zur Lösung)
    // ═══════════════════════════════════════════════════════════════
    
    "logic_why_no_power": {
        "text": "Du hast keine Macht, weil Macht nicht für dich designed wurde. Das System heißt 'Repräsentative Demokratie', aber es ist eine Aristokratie mit Wahlverfahren. Die Wahl ist der Filter. Der Sieb. Er lässt nur bestimmte Menschen durch: Die mit Geld. Die mit Netzwerken. Die mit Karriereambitionen. Nicht dich.",
        "options": [
            { "label": "Aber alle können kandidieren", "next": "logic_meritocracy_myth" },
            { "label": "Was wäre die Alternative?", "next": "solution_lottery_intro" }
        ],
        "visual": "pyramid",
        "phase": "logic"
    },
    
    "logic_elections_ineffective": {
        "text": "Wahlen wirken. Wirklich? Zeig mir eine Wahl der letzten 30 Jahre, die fundamentale Strukturveränderung gebracht hat. Nicht neue Gesetze. Nicht neue Minister. Strukturveränderung. Wo ist sie? Sie existiert nicht. Weil das System nicht designed ist für Veränderung. Es ist designed für Stabilität. Für die Eliten.",
        "options": [
            { "label": "Die Wende 1989?", "next": "logic_wende" },
            { "label": "Dann brauchen wir Revolution?", "next": "logic_revolution" }
        ],
        "visual": "clash",
        "phase": "logic"
    },
    
    "logic_accountability": {
        "text": "Abwählen. Die theoretische Kontrolle. Aber: Wie oft hast du schon abgewählt? Und was war das Ergebnis? Dieselbe Politik. Dieselben Strukturen. Andere Gesichter. Die Parteien wechseln, das System bleibt. Du wechselst den Vorhang, aber das Theaterstück ist dasselbe.",
        "options": [
            { "label": "Was würde echte Kontrolle sein?", "next": "solution_real_control" },
            { "label": "Aber die Kontrolle durch Wahlen...", "next": "logic_cycle_trap" }
        ],
        "visual": "pyramid_dissolve",
        "phase": "logic"
    },
    
    "logic_meritocracy_myth": {
        "text": "Theoretisch können alle kandidieren. Theoretisch. Praktisch? Du brauchst Geld für den Wahlkampf. Du brauchst Partei-Unterstützung. Du brauchst Medienpräsenz. Du brauchst Zeit, die du nicht hast, weil du arbeiten musst. Theoretisch frei, praktisch gefangen. Das ist die schönste Form der Kontrolle.",
        "options": [
            { "label": "Wie brechen wir die Kontrolle?", "next": "solution_break_control" },
            { "label": "Das ist Zynismus", "next": "logic_cynicism_truth" }
        ],
        "visual": "pyramid",
        "phase": "logic"
    },
    
    "logic_system_rigged": {
        "text": "Es ändert sich nie etwas. Fast richtig. Es ändert sich nie etwas für dich. Für die Mehrheit. Aber für die Eliten? Für Konzerne? Da ändert sich ständig etwas. Steuergeschenke. Deregulierung. Subventionen. Das System funktioniert perfekt – nur nicht für uns.",
        "options": [
            { "label": "Wie machen wir es für uns?", "next": "solution_for_us" },
            { "label": "Beweise die Korruption", "next": "logic_corruption_evidence" }
        ],
        "visual": "clash",
        "phase": "logic"
    },
    
    "logic_real_change": {
        "text": "Was würde ändern? Macht. Echte Macht. Nicht das Recht, alle vier Jahre einen Zettel abzugeben. Sondern das Recht, direkt zu entscheiden. Über Gesetze. Über Budgets. Über Krieg und Frieden. Das gab es schon einmal. In Athen. Sie nannten es Isonomie. Gleichheit des politischen Rechts.",
        "options": [
            { "label": "Erzähl mir von Isonomie", "next": "solution_isonomia_history" },
            { "label": "Das war vor 2500 Jahren", "next": "logic_antiquity_relevance" }
        ],
        "visual": "stochastic",
        "phase": "logic"
    },
    
    "logic_truth_trap": {
        "text": "Es ist wahr, dass du keine Macht hast. Aber es ist nicht die ganze Wahrheit. Die ganze Wahrheit ist: Du HATTEST keine Macht, weil das System so designed ist. Aber Design kann geändert werden. Software kann gepatched werden. Du kannst Macht haben. Wenn du bereit bist, das System zu wechseln.",
        "options": [
            { "label": "Welches System?", "next": "solution_alternative" },
            { "label": "Ich habe das schon gehört", "next": "logic_promise_vs_proof" }
        ],
        "visual": "breathe",
        "phase": "logic"
    },
    
    "logic_decay": {
        "text": "Warum bröckelt alles? Weil das System nicht designed ist für Lösungen. Es ist designed für Konflikt. Für Theater. Für vier-Jahres-Zyklen. Lange Projekte – Infrastruktur, Bildung, Klima – werden ignoriert, weil sie nicht vor der nächsten Wahl Ergebnisse bringen. Das System heilt nicht. Es verwaltet.",
        "options": [
            { "label": "Wir brauchen Langzeitdenken", "next": "solution_longterm" },
            { "label": "Aber Demokratie ist langsam", "next": "logic_slowness_myth" }
        ],
        "visual": "pyramid_dissolve",
        "phase": "logic"
    }
    
};

// Weitere Phasen (Solution, Objection, Action, Vault, Exit) folgen...


    // ═══════════════════════════════════════════════════════════════
    // PHASE 4: SOLUTION - ISONOMIE (Die Erlösung)
    // ═══════════════════════════════════════════════════════════════
    
    "solution_hint": {
        "text": "Die Alternative existiert. Sie ist nicht neu. Sie ist 2500 Jahre alt. Und sie ist radikal einfach. Radikal gerecht. Radikal anders. Aber bevor ich sie dir zeige: Bist du bereit, alles zu hinterfragen? Wirklich alles?",
        "options": [
            { "label": "Ja, alles", "next": "solution_lottery_intro", "commitment": true },
            { "label": "Erst das Problem", "next": "problem_deeper" }
        ],
        "visual": "stochastic",
        "phase": "solution"
    },
    
    "solution_lottery_intro": {
        "text": "Das Los. Sortition. Klingt absurd, oder? Aber höre zu: In Athen, der Geburtsstätte der Demokratie, wurden die meisten Ämter nicht gewählt. Sie wurden verlost. Jeder Bürger konnte regieren. Nicht nur die Berufspolitiker. Nicht nur die Reichen. Alle.",
        "options": [
            { "label": "Wie funktionierte das?", "next": "solution_athens_mechanics" },
            { "label": "Das war doch nur klein", "next": "solution_scale" },
            { "label": "Aber die Qualifikation?", "next": "objection_qualification" }
        ],
        "visual": "stochastic",
        "phase": "solution"
    },
    
    "solution_athens_mechanics": {
        "text": "Athen. 30.000 Bürger. Ein komplexes Losverfahren. Maschinen, die Zufall garantierten. Bürgerräte von 500 Menschen. Jeder konnte einmal im Leben regieren. Dann zurück zum normalen Leben. Keine Karriere. Keine Korruption. Reiner Dienst.",
        "options": [
            { "label": "Warum funktionierte es?", "next": "solution_athens_why" },
            { "label": "Und heute?", "next": "solution_modern" }
        ],
        "visual": "breathe",
        "phase": "solution"
    },
    
    "solution_athens_why": {
        "text": "Es funktionierte, weil es nicht auf Meritokratie setzte. Nicht auf 'die Besten'. Sondern auf Gleichheit. Auf Diversität. Auf den gesunden Menschenverstand von 500 zufällig ausgewählten Bürgern. Nicht auf die Intelligenz von 1 Elite. Die Mathematik ist klar: Vielfalt schlägt Elite.",
        "options": [
            { "label": "Beweise es", "next": "solution_evidence" },
            { "label": "Moderne Beispiele?", "next": "solution_modern_examples" }
        ],
        "visual": "reset_to_grid",
        "phase": "solution"
    },
    
    "solution_modern": {
        "text": "Heute. Mit 83 Millionen Menschen. Mit moderner Technologie. Stell dir vor: Ein Bürgerrat. 500 Menschen. Per Los ausgewählt. Alle Altersgruppen. Alle Regionen. Alle Bildungsstände. Wie das Volk wirklich ist. Nicht wie die Politiker denken, dass es sein sollte.",
        "options": [
            { "label": "Wie würde das funktionieren?", "next": "solution_mechanics" },
            { "label": "Gibt es Beispiele?", "next": "solution_ireland" }
        ],
        "visual": "reset_to_grid",
        "phase": "solution"
    },
    
    "solution_ireland": {
        "text": "Irland. 2016. Eine verfassungsgebende Versammlung. Per Los ausgewählt. 99 Bürger. 18 Monate. Sie entschieden über Abtreibung. Über Ehe für alle. Themen, die Politiker Jahrzehnte verschoben hatten. Die Bürger entschieden – fundiert, besonnen, mutig. Es funktionierte.",
        "options": [
            { "label": "Und das Ergebnis?", "next": "solution_ireland_result" },
            { "label": "Warum funktionierte es?", "next": "solution_why_works" }
        ],
        "visual": "breathe",
        "phase": "solution"
    },
    
    "solution_ireland_result": {
        "text": "Das Ergebnis? Historisch. Irland legalisierte die Abtreibung. Die Ehe für alle. Referenden, die vorher unmöglich schienen, wurden mit überwältigender Mehrheit angenommen. Nicht wegen Politikern. Sondern trotz ihnen. Weil normale Menschen entschieden. Das ist Isonomie.",
        "options": [
            { "label": "Wir brauchen das hier", "next": "action_support" },
            { "label": "Aber die Kritik?", "next": "objection_overview" }
        ],
        "visual": "reset_to_grid",
        "phase": "solution"
    },
    
    "solution_why_works": {
        "text": "Warum funktioniert es? Drei Gründe: Erstens: Keine Karriereabhängigkeit. Du wirst nicht wiedergewählt, also brauchst du nicht zu korrumpieren. Zweitens: Diversität. 500 zufällige Menschen repräsentieren die Gesellschaft besser als 500 Abgeordnete mit ähnlichem Hintergrund. Drittens: Zeit. Du hast Monate, um dich zu informieren. Nicht Sekunden, um dich zu profilieren.",
        "options": [
            { "label": "Überzeugt", "next": "action_now" },
            { "label": "Ich habe Bedenken", "next": "objection_overview" }
        ],
        "visual": "reset_to_grid",
        "phase": "solution"
    },
    
    "solution_mechanics": {
        "text": "Die Mechanik ist einfach: Ein Los-Verfahren. Wie bei der Jury-Pflicht. Du bekommst einen Brief: 'Sie wurden ausgewählt.' Ein Jahr. Bezahlt. Mit Unterstützung. Mit Experten, die informieren, nicht instruieren. Dann zurück zum normalen Leben. Keine Karriere. Keine Abhängigkeit. Reiner Bürgerdienst.",
        "options": [
            { "label": "Was, wenn ich ablehne?", "next": "objection_refusal" },
            { "label": "Wer unterstützt sie?", "next": "solution_support" }
        ],
        "visual": "breathe",
        "phase": "solution"
    },
    
    "solution_scale": {
        "text": "Athen war klein. Deutschland ist groß. Richtig. Aber hier ist die Erkenntnis: Skalierung ist ein Feature, nicht ein Bug. Je größer das Los-Verfahren, desto repräsentativer die Auswahl. 500 aus 83 Millionen ist statistisch präziser als 500 aus 30.000. Die Mathematik ist auf unserer Seite.",
        "options": [
            { "label": "Statistisch belegt?", "next": "solution_statistics" },
            { "label": "Aber die Komplexität?", "next": "objection_complexity" }
        ],
        "visual": "reset_to_grid",
        "phase": "solution"
    },
    
    "solution_wall": {
        "text": "Die Wand einreissen. Schöne Metapher. Aber wie? Nicht mit Gewalt. Nicht mit Revolution. Sondern mit Ideen. Mit Beispielen. Mit Druck. Wir müssen das Undenkbare denkbar machen. Wir müssen zeigen: Es gibt eine Alternative. Und sie funktioniert.",
        "options": [
            { "label": "Wie machen wir es denkbar?", "next": "action_awareness" },
            { "label": "Erzähl mir mehr", "next": "solution_deep" }
        ],
        "visual": "stochastic",
        "phase": "solution"
    },
    
    "solution_search": {
        "text": "Du suchst. Das ist gut. Die meisten hören auf, wenn es unbequem wird. Du nicht. Du willst wissen. Die Suche nach Alternativen ist der Anfang jeder Veränderung. Und hier ist die gute Nachricht: Die Alternative existiert. Sie ist nicht utopisch. Sie ist historisch bewährt.",
        "options": [
            { "label": "Zeig sie mir", "next": "solution_lottery_intro" },
            { "label": "Warum kennt niemand sie?", "next": "logic_suppressed" }
        ],
        "visual": "breathe",
        "phase": "solution"
    },
    
    "solution_isonomia_history": {
        "text": "Isonomie. ἰσονομία. Gleiches Recht. Gleiche Pflicht. In Athen bedeutete es: Jeder Bürger kann regieren. Nicht nur die Reichen. Nicht nur die Gebildeten. Alle. Das Los war der große Gleichmacher. Es machte Aristokratie unmöglich. Das war die wahre Demokratie.",
        "options": [
            { "label": "Warum haben wir sie verloren?", "next": "logic_history_lost" },
            { "label": "Wie holen wir sie zurück?", "next": "action_restore" }
        ],
        "visual": "breathe",
        "phase": "solution"
    },
    
    "solution_alternative": {
        "text": "Das System heißt Isonomie. Auswahl durch Los statt durch Wahl. Klingt verrückt? Verrückter als ein System, in dem Milliardäre Politiker kaufen? Verrückter als ein System, das den Planeten zerstört, weil vier-Jahres-Zyklen Langzeitdenken verhindern?",
        "options": [
            { "label": "Erklär mir Isonomie", "next": "solution_isonomia_history" },
            { "label": "Verrückter als das Los?", "next": "solution_crazy_comparison" }
        ],
        "visual": "stochastic",
        "phase": "solution"
    },
    
    "solution_urgent": {
        "text": "Was können wir tun? Jetzt. Sofort. Bevor es zu spät ist. Die Antwort ist nicht: Warten auf die nächste Wahl. Nicht: Protestieren. Die Antwort ist: Ein neues System fordern. Ein System, das nicht auf Wahl und Eliten setzt. Sondern auf Zufall und Gleichheit. Auf Isonomie.",
        "options": [
            { "label": "Wie fordern wir das?", "next": "action_demand" },
            { "label": "Was ist Isonomie?", "next": "solution_isonomia_history" }
        ],
        "visual": "stochastic",
        "phase": "solution"
    }


    // ═══════════════════════════════════════════════════════════════
    // PHASE 5: OBJECTION HANDLING - DIE EINWÄNDE
    // ═══════════════════════════════════════════════════════════════
    
    "objection_overview": {
        "text": "Bedenken. Gut. Ein kritischer Geist ist das Immunsystem der Demokratie. Du hast Fragen. Wir haben Antworten. Die häufigsten Einwände gegen das Losverfahren: 'Unfähige an die Macht', 'Keine Qualifikation', 'Zu riskant', 'Niemand will das'. Welcher beschäftigt dich?",
        "options": [
            { "label": "Unfähige an die Macht", "next": "objection_incompetence" },
            { "label": "Keine Qualifikation", "next": "objection_qualification" },
            { "label": "Zu riskant", "next": "objection_risk" },
            { "label": "Niemand will das", "next": "objection_refusal" }
        ],
        "visual": "clash",
        "phase": "objection"
    },
    
    "objection_incompetence": {
        "text": "Angst vor dem unfähigen Nachbarn. Diese Angst ist das erfolgreichste Produkt des Systems. Sie haben dir beigebracht, dass Akademiker besser regieren. Aber zeig mir die Studie, die das belegt. Es gibt sie nicht. Stattdessen gibt es Beweise: Zufällige Bürger entscheiden objektiv besser als Experten, wenn es um komplexe ethische Fragen geht. Deine Angst ist ein Implantat.",
        "options": [
            { "label": "Zeig mir die Beweise", "next": "objection_evidence" },
            { "label": "Aber komplexe Themen?", "next": "objection_complexity" },
            { "label": "Ich muss darüber nachdenken", "next": "exit_contemplation" }
        ],
        "visual": "clash",
        "phase": "objection"
    },
    
    "objection_qualification": {
        "text": "Qualifikation. Das Zauberwort der Meritokratie. Aber was ist politische Qualifikation? Rhetorik? Geld sammeln? Netzwerken? Das sind nicht Qualifikationen für gute Entscheidungen. Das sind Qualifikationen für Karriere. Studien zeigen: Fachwissen korreliert nicht mit ethischer Urteilskraft. Oft ist es das Gegenteil.",
        "options": [
            { "label": "Was korreliert dann?", "next": "objection_what_works" },
            { "label": "Aber Fachwissen ist wichtig", "next": "objection_experts" }
        ],
        "visual": "pyramid_struggle",
        "phase": "objection"
    },
    
    "objection_risk": {
        "text": "Zu riskant. Ja. Es ist ein Risiko. Aber hier ist die Frage: Was ist das größere Risiko? Ein System, bei dem 500 zufällige Bürger entscheiden – oder ein System, bei dem 500 Karrierepolitiker entscheiden, die von Lobbyisten bezahlt werden? Was ist wirklich riskanter?",
        "options": [
            { "label": "Der Status quo ist riskanter", "next": "solution_agreed" },
            { "label": "Beides hat Risiken", "next": "objection_compare_risks" }
        ],
        "visual": "clash",
        "phase": "objection"
    },
    
    "objection_refusal": {
        "text": "Niemand will das Los. Das ist das erste Argument. Aber: Was, wenn es eine Pflicht wäre? Wie Jury-Pflicht? Mit Entschädigung? Mit Schutz am Arbeitsplatz? Dann ändert sich die Rechnung. Dann wird es zur Ehre. Zum Dienst. Zur Bürgerpflicht.",
        "options": [
            { "label": "Zwang ist problematisch", "next": "objection_coercion" },
            { "label": "Wie wäre die Entschädigung?", "next": "objection_compensation" }
        ],
        "visual": "tremble",
        "phase": "objection"
    },
    
    "objection_evidence": {
        "text": "Die Beweise: Irland. Bürgerräte entschieden über Abtreibung und Ehe für alle. Bessere Entscheidungen als Politiker. Frankreich. Klima-Bürgerräte. Fundierter als die Nationalversammlung. Belgien. Ostbelgien. Erste Bürgerräte mit echter Macht. Es funktioniert. Nicht in der Theorie. In der Praxis.",
        "options": [
            { "label": "Warum kennt das niemand?", "next": "logic_media_blackout" },
            { "label": "Ich bin überzeugt", "next": "action_support" }
        ],
        "visual": "breathe",
        "phase": "objection"
    },
    
    "objection_complexity": {
        "text": "Komplexe Themen. Klima. Wirtschaft. Digitales. Wie kann ein 'einfacher' Bürger das verstehen? Antwort: Er muss es nicht alleine. Er hat Experten, die informieren. Er hat Zeit, um zu lernen. Er hat 499 andere Bürger, die diskutieren. Das ist intelligenter als ein Minister, der alleine entscheidet.",
        "options": [
            { "label": "Experten, die nicht instruieren?", "next": "objection_expert_role" },
            { "label": "Zeit zum Lernen?", "next": "objection_time" }
        ],
        "visual": "breathe",
        "phase": "objection"
    },
    
    "objection_experts": {
        "text": "Fachwissen ist wichtig. Absolut. Aber wofür? Für die Analyse. Für die Optionen. Nicht für die Entscheidung. Die Entscheidung ist politisch. Ethisch. Wer soll profitieren? Wer soll tragen? Das kann kein Experte beantworten. Das muss das Volk entscheiden. Oder besser: Ein repräsentativer Querschnitt des Volkes.",
        "options": [
            { "label": "Trennung von Analyse und Entscheidung?", "next": "objection_separation" },
            { "label": "Wer wählt die Experten?", "next": "objection_expert_selection" }
        ],
        "visual": "breathe",
        "phase": "objection"
    },
    
    "objection_coercion": {
        "text": "Zwang ist problematisch. Stimmt. Aber hier ist die Frage: Ist Wahlzwang problematisch? In Belgien, in Australien musst du wählen. Oder es gibt Strafen. Warum? Weil Demokratie ein Recht UND eine Pflicht ist. Wenn alle per Los ausgewählt werden könnten – wäre das nicht fairer? Jeder trägt die Last. Nicht nur die Wenigen, die wählen gehen.",
        "options": [
            { "label": "Gerechter, aber nicht freiwillig", "next": "objection_voluntary" },
            { "label": "Alle tragen die Last?", "next": "objection_burden" }
        ],
        "visual": "clash",
        "phase": "objection"
    },
    
    "objection_compensation": {
        "text": "Entschädigung. Ein Jahr Bürgerdienst. Bezahlt wie ein Abgeordneter. Mit Übernahme des Gehalts durch den Staat. Mit Kündigungsschutz. Mit Rentenansprüchen. Du verlierst nichts. Du gewinnst Erfahrung. Einfluss. Geschichte. Du wirst Teil eines Experiments, das die Welt verändern könnte.",
        "options": [
            { "label": "Das ist fair", "next": "solution_agreed" },
            { "label": "Aber mein Job?", "next": "objection_job" }
        ],
        "visual": "breathe",
        "phase": "objection"
    },
    
    "objection_job": {
        "text": "Dein Job. Das ist berechtigt. Aber: Wer hat gesagt, dass Politik eine Vollzeit-Karriere sein muss? In Athen war es Nebenamt. Du regiertest ein Jahr, dann gingst du zurück. Heute wäre das anders. Aber der Gedanke bleibt: Politik als Dienst, nicht als Beruf. Als Bürgerpflicht, nicht als Lebensziel.",
        "options": [
            { "label": "Politik als Dienst, nicht Beruf", "next": "solution_agreed" },
            { "label": "Aber komplexe Entscheidungen brauchen Erfahrung", "next": "objection_experience" }
        ],
        "visual": "breathe",
        "phase": "objection"
    },
    
    "objection_experience": {
        "text": "Erfahrung. Das große Argument für Berufspolitiker. Aber zeig mir, wohin ihre Erfahrung geführt hat. Klimakrise? Schulden? Soziale Spaltung? Ihre Erfahrung ist die Erfahrung des Scheiterns. Die Erfahrung des Managements des Niedergangs. Vielleicht brauchen wir frische Augen. Unvoreingenommene. Unkorrumpierte.",
        "options": [
            { "label": "Frische Augen statt erfahrene Augen?", "next": "objection_fresh_vs_experienced" },
            { "label": "Aber Kontinuität?", "next": "objection_continuity" }
        ],
        "visual": "pyramid_dissolve",
        "phase": "objection"
    },
    
    "objection_what_works": {
        "text": "Was korreliert mit guter politischer Entscheidung? Nicht Intelligenz. Nicht Bildung. Sondern: Zeit. Unabhängigkeit. Diversität. Ein Bürgerrat hat Zeit, sich zu informieren. Ist unabhängig von Wiederwahl. Ist divers, wie die Gesellschaft. Das sind die echten Qualifikationen. Nicht der Doktortitel.",
        "options": [
            { "label": "Zeit, Unabhängigkeit, Diversität", "next": "solution_agreed" },
            { "label": "Aber wie garantieren wir Qualität?", "next": "objection_quality" }
        ],
        "visual": "reset_to_grid",
        "phase": "objection"
    }


    // ═══════════════════════════════════════════════════════════════
    // PHASE 6: ACTION - DER CALL TO ACTION
    // ═══════════════════════════════════════════════════════════════
    
    "action_now": {
        "text": "Du bist weit gekommen. Du hast den Schmerz gesehen. Die Angst. Die Lösung. Jetzt kommt die Frage: Was tust du? Nicht morgen. Nicht 'irgendwann'. Jetzt. Denn jeden Tag, den wir warten, wird das System stabiler. Und wir schwächer.",
        "options": [
            { "label": "Ich will handeln", "next": "action_specific" },
            { "label": "Ich brauche mehr Informationen", "next": "vault_entry" },
            { "label": "Ich muss darüber nachdenken", "next": "exit_contemplation" }
        ],
        "visual": "stochastic",
        "phase": "action"
    },
    
    "action_specific": {
        "text": "Gut. Konkrete Schritte. Erstens: Sprich darüber. Nicht im Internet. Im echten Leben. Mit Freunden. Mit Familie. Mit Kollegen. Zweitens: Lies. Informiere dich. Die Bücher sind da. Drittens: Organisiere dich. Es gibt Gruppen, die für Isonomie arbeiten. Werde Teil davon. Viertens: Bleib dran. Das ist ein Marathon, kein Sprint.",
        "options": [
            { "label": "Wo finde ich die Bücher?", "next": "vault_books" },
            { "label": "Welche Gruppen?", "next": "action_groups" },
            { "label": "Wie spreche ich darüber?", "next": "action_talk" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    },
    
    "action_support": {
        "text": "Unterstützung. Das ist der Anfang. Du musst nicht alles tun. Aber etwas. Teile diese Seite. Lies ein Buch. Sprich mit einem Freund. Jede Handlung zählt. Jede Handlung ist ein Stein im Fundament der neuen Demokratie. Bist du bereit, den ersten Stein zu legen?",
        "options": [
            { "label": "Ja, ich lege den ersten Stein", "next": "action_commit", "commitment": true },
            { "label": "Zeig mir die Fundamente", "next": "vault_foundations" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    },
    
    "action_commit": {
        "text": "Du legst den Stein. Gut. Willkommen im Untergrund. Nicht der Verschwörungs-Untergrund. Der Demokratie-Untergrund. Wir sind nicht viele. Aber wir wachsen. Und wir haben die besseren Argumente. Und die bessere Geschichte. Die Geschichte von Athen. Von Irland. Von der Zukunft.",
        "options": [
            { "label": "Was ist der nächste Schritt?", "next": "action_next_steps" },
            { "label": "Ich will mehr lernen", "next": "vault_deep" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    },
    
    "action_talk": {
        "text": "Wie spricht man darüber? Nicht mit Predigen. Nicht mit Überzeugen. Mit Fragen. Stelle die Fragen, die wir gestellt haben. 'Fühlst du dich gehört?' 'Warum ändert sich nichts?' 'Was wäre, wenn es eine Alternative gäbe?' Lass sie selbst denken. Das ist der einzige Weg, der funktioniert.",
        "options": [
            { "label": "Die Fragen funktionieren?", "next": "action_questions_work" },
            { "label": "Aber meine Freunde denken, ich sei verrückt", "next": "action_crazy" }
        ],
        "visual": "breathe",
        "phase": "action"
    },
    
    "action_questions_work": {
        "text": "Funktionieren die Fragen? Schau dich um. Du bist hier. Du hast die Fragen beantwortet. Du bist weiter gekommen, als wenn ich dir gesagt hätte: 'Wahlen sind schlecht, glaub mir.' Die eigenen Antworten sind die einzigen, die zählen. Wir können nur den Spiegel halten.",
        "options": [
            { "label": "Ich verstehe", "next": "action_practice" },
            { "label": "Ich will üben", "next": "action_simulation" }
        ],
        "visual": "breathe",
        "phase": "action"
    },
    
    "action_crazy": {
        "text": "Verrückt. Ja, das werden sie sagen. Zuerst. Weil das Losverfahren so fremd ist. So anders. Aber hier ist der Trick: Gehe nicht mit der Lösung los. Gehe mit dem Problem los. 'Fühlst du dich gehört?' Wenn sie ja sagen – sie lügen oder gehören zur Elite. Wenn sie nein sagen – hast du sie. Dann kommt die Lösung.",
        "options": [
            { "label": "Problem zuerst, Lösung später", "next": "action_strategy" },
            { "label": "Ich probiere es", "next": "action_practice" }
        ],
        "visual": "breathe",
        "phase": "action"
    },
    
    "action_groups": {
        "text": "Gruppen. Organisationen. Es gibt sie. Mehr werden es. Democracy International. Initiative für Mehr Demokratie. Lokale Bürgerrat-Initiativen. Suche nach 'Sortition' oder 'Bürgerrat' in deiner Stadt. Oder gründe selbst eine. Du bist nicht allein. Du bist nur früh dran.",
        "options": [
            { "label": "Ich suche nach Gruppen", "next": "action_search_groups" },
            { "label": "Ich gründe selbst", "next": "action_foundation" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    },
    
    "action_search_groups": {
        "text": "Suche. Starte mit Democracy International. Sie kämpfen für direkte Demokratie. Dann: Initiative für Mehr Demokratie. Sie fordern Bürgerräte. Dann: OECD-Reports zu deliberativer Demokratie. Sie belegen, dass es funktioniert. Du wirst schnell mehr finden. Die Bewegung wächst.",
        "options": [
            { "label": "Ich beginne die Suche", "next": "vault_resources" },
            { "label": "Erzähl mir von der OECD", "next": "vault_oecd" }
        ],
        "visual": "breathe",
        "phase": "action"
    },
    
    "action_foundation": {
        "text": "Gründen. Mutig. Nötig. Fange klein an. Ein Treffen. Fünf Freunde. Ein Thema. 'Wie könnte ein Bürgerrat in unserer Stadt aussehen?' Diskutiere. Plant. Wachse. Poste online. Finde Gleichgesinnte. Ihr seid die Avantgarde. Die Vorhut der neuen Demokratie.",
        "options": [
            { "label": "Ich fange an", "next": "action_start_now" },
            { "label": "Ich brauche mehr Wissen", "next": "vault_guide" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    },
    
    "action_start_now": {
        "text": "Jetzt. Heute. Schreib eine Nachricht an fünf Freunde. 'Ich habe etwas entdeckt. Ein politisches System, das funktionieren könnte. Kann ich es dir zeigen?' Das ist der Anfang. Einfach. Unaufdringlich. Aber mächtig. Jede Revolution beginnt mit einem Gespräch.",
        "options": [
            { "label": "Ich schreibe die Nachricht", "next": "action_message_sent", "commitment": true },
            { "label": "Erst mehr lesen", "next": "vault_reading_list" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    },
    
    "action_message_sent": {
        "text": "Gesendet. Du hast den Stein gelegt. Vielleicht antworten sie. Vielleicht nicht. Vielleicht denken sie erst nach. Aber du hast den Samen gesät. Und Samen brauchen Zeit. Sei geduldig. Sei beharrlich. Die Wahrheit hat eine eigene Schwerkraft. Irgendwann zieht sie alle an.",
        "options": [
            { "label": "Was jetzt?", "next": "action_continue" },
            { "label": "Ich will mehr wissen", "next": "vault_complete" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    },
    
    "action_demand": {
        "text": "Fordern. Wie? Nicht mit Parolen. Mit Druck. Öffentlichkeitsarbeit. Studien zitieren. Beispiele nennen. Irland. Frankreich. Belgien. Zeige, dass es funktioniert. Fordere von Politikern, Bürgerräte einzurichten. Pilotprojekte. Testläufe. Jeder kleine Sieg zählt.",
        "options": [
            { "label": "Wie erreiche ich Politiker?", "next": "action_politicians" },
            { "label": "Pilotprojekte?", "next": "action_pilots" }
        ],
        "visual": "stochastic",
        "phase": "action"
    },
    
    "action_practice": {
        "text": "Üben. Gut. Hier ist eine Übung: Erkläre Isonomie einem Kind. Oder einem Großvater. Wenn du es so einfach erklären kannst, dass sie es verstehen – hast du es verstanden. Wenn nicht – musst du noch lernen. Lehren ist das beste Lernen.",
        "options": [
            { "label": "Ich probiere es", "next": "action_practice_next" },
            { "label": "Erst mehr lernen", "next": "vault_learning" }
        ],
        "visual": "breathe",
        "phase": "action"
    },
    
    "action_next_steps": {
        "text": "Nächste Schritte: Eins. Lies 'Gegen Wahlen' von David Van Reybrouck. Das ist die Bibel. Zwei. Suche Kontakt zu Democracy International. Drei. Sprich mit einem Freund über das, was du gelernt hast. Vier. Komm zurück. Diese Seite wird wachsen. Neue Inhalte. Neue Wege. Bleib verbunden.",
        "options": [
            { "label": "Ich lese das Buch", "next": "action_book_commit", "commitment": true },
            { "label": "Ich suche Kontakt", "next": "action_contact_commit" },
            { "label": "Ich komme zurück", "next": "action_return_commit" }
        ],
        "visual": "reset_to_grid",
        "phase": "action"
    }


    // ═══════════════════════════════════════════════════════════════
    // PHASE 7: VAULT - DIE BIBLIOTHEK
    // ═══════════════════════════════════════════════════════════════
    
    "vault_entry": {
        "text": "Die Bibliothek. Das Archiv. Hier findest du alles, was du brauchst, um dich zu informieren. Bücher. Studien. Videos. Organisationen. Nichts davon ist Werbung. Alles davon ist Wissen. Nimm, was du brauchst. Komm zurück, wenn du mehr brauchst.",
        "options": [
            { "label": "Bücher", "next": "vault_books" },
            { "label": "Studien", "next": "vault_studies" },
            { "label": "Organisationen", "next": "vault_organizations" },
            { "label": "Videos", "next": "vault_videos" },
            { "label": "Zurück zum Dialog", "next": "action_continue" }
        ],
        "visual": "breathe",
        "phase": "vault"
    },
    
    "vault_books": {
        "text": "Die Pflichtlektüre: 'Gegen Wahlen' von David Van Reybrouck. Das Standardwerk. 'The End of Politicians' von Brett Hennig. Die wissenschaftliche Vertiefung. 'Against Elections' – die englische Originalfassung. Lies. Denke. Hinterfrage.",
        "options": [
            { "label": "Wo finde ich die Bücher?", "next": "vault_book_links" },
            { "label": "Weitere Empfehlungen?", "next": "vault_books_more" },
            { "label": "Zurück", "next": "vault_entry" }
        ],
        "visual": "breathe",
        "phase": "vault"
    },
    
    "vault_studies": {
        "text": "Die wissenschaftliche Basis: OECD-Studien zu deliberativer Demokratie. James Fishkin über 'Deliberative Polling'. Die Irland-Evaluation. Die französischen Klima-Räte. All das belegt: Es funktioniert. Besser als Wahlen. Besser als Eliten.",
        "options": [
            { "label": "Links zu den Studien?", "next": "vault_study_links" },
            { "label": "Zusammenfassungen?", "next": "vault_summaries" },
            { "label": "Zurück", "next": "vault_entry" }
        ],
        "visual": "breathe",
        "phase": "vault"
    },
    
    "vault_organizations": {
        "text": "Die Bewegung: Democracy International. Das Sortition Foundation. Die Initiative für Mehr Demokratie. Der OECD-Netzwerk für deliberative Demokratie. Sie alle arbeiten daran. Sie alle brauchen Unterstützung. Werde Teil davon.",
        "options": [
            { "label": "Kontaktdaten?", "next": "vault_org_links" },
            { "label": "Wie kann ich helfen?", "next": "vault_help" },
            { "label": "Zurück", "next": "vault_entry" }
        ],
        "visual": "breathe",
        "phase": "vault"
    },
    
    "vault_videos": {
        "text": "Die visuelle Lernweise: TED-Talks über Sortition. YouTube-Dokumentationen über Bürgerräte. Erklärvideos zu Isonomie. Alles verfügbar. Alles kostenlos. Teile es. Verbreite es.",
        "options": [
            { "label": "Links zu Videos?", "next": "vault_video_links" },
            { "label": "Zurück", "next": "vault_entry" }
        ],
        "visual": "breathe",
        "phase": "vault"
    },
    
    "vault_complete": {
        "text": "Das komplette Archiv. Alles, was wir haben. Alles, was wir finden konnten. Nicht perfekt. Aber ein Anfang. Nimm es. Nutze es. Ergänze es. Das Wissen gehört allen. Die Demokratie gehört allen. Oder sie gehört niemandem.",
        "options": [
            { "label": "Zeig mir alles", "next": "vault_full" },
            { "label": "Ich will handeln", "next": "action_now" },
            { "label": "Zurück", "next": "vault_entry" }
        ],
        "visual": "reset_to_grid",
        "phase": "vault"
    },
    
    // ═══════════════════════════════════════════════════════════════
    // PHASE 8: EXIT - DIE AUSGÄNGE
    // ═══════════════════════════════════════════════════════════════
    
    "exit_respectful": {
        "text": "Vollkommen in Ordnung. Niemand sollte gezwungen werden, über politische Systeme nachzudenken. Wenn du jemals neugierig wirst, ist dieser Ort hier. Bis dahin: Bleib gesund.",
        "options": [
            { "label": "Doch noch eine Frage", "next": "problem_entry" },
            { "label": "Auf Wiedersehen", "next": "exit_final" }
        ],
        "visual": "breathe",
        "phase": "exit"
    },
    
    "exit_final": {
        "text": "Der Dialog endet hier. Aber das Denken nicht. Vielleicht siehst du die Welt morgen mit anderen Augen. Oder auch nicht. Beides ist legitim. Die Tür bleibt offen.",
        "options": [
            { "label": "Neustart", "next": "start" }
        ],
        "visual": "reset_to_grid",
        "phase": "exit"
    },
    
    "exit_blue_pill": {
        "text": "Die blaue Pille. Die Wahl des bequemen Schlafes. Nichts für ungut. Der Schlaf ist bequem. Der Schlaf ist sicher. Bis er es nicht mehr ist. Die Wand bröckelt. Ob du es siehst oder nicht. Gute Reise.",
        "options": [
            { "label": "Ich bereue es", "next": "entry_wake" },
            { "label": "Auf Wiedersehen", "next": "exit_final" }
        ],
        "visual": "breathe",
        "phase": "exit"
    },
    
    "exit_cost": {
        "text": "Zu teuer. Das verstehe ich. Die Erkenntnis hat einen Preis. Den Preis des nicht mehr zurückkönnens. Manche können das nicht zahlen. Noch nicht. Vielleicht später. Die Tür bleibt offen.",
        "options": [
            { "label": "Vielleicht später", "next": "exit_final" },
            { "label": "Ich zahle doch", "next": "problem_entry" }
        ],
        "visual": "tremble",
        "phase": "exit"
    },
    
    "exit_contemplation": {
        "text": "Nachdenken. Gut. Das ist der wichtigste Schritt. Lass es sacken. Schlafe darüber. Diskutiere mit Freunden. Komm zurück, wenn du bereit bist. Oder komm nicht zurück. Deine Entscheidung. Dein Tempo.",
        "options": [
            { "label": "Ich komme zurück", "next": "exit_final" },
            { "label": "Weiter denken", "next": "vault_entry" }
        ],
        "visual": "breathe",
        "phase": "exit"
    },
    
    "exit_sleep": {
        "text": "Der Schlaf ist bequem. Der Schlaf ist warm. Der Schlaf ist gefährlich. Denn während du schläfst, werden Entscheidungen getroffen. Über dich. Ohne dich. Aber das ist deine Wahl. Gute Träume.",
        "options": [
            { "label": "Weck mich", "next": "problem_awakening" },
            { "label": "Gute Nacht", "next": "exit_final" }
        ],
        "visual": "breathe",
        "phase": "exit"
    },
    
    "exit_comfort": {
        "text": "Bequem. Ja. Das ist das System. Es macht dich bequem. Mit Konsum. Mit Unterhaltung. Mit der Illusion von Sicherheit. Aber die Bequemlichkeit ist die Vorstufe zur Unfreiheit. Denk darüber nach. Wenn du willst.",
        "options": [
            { "label": "Ich will wach werden", "next": "problem_awakening" },
            { "label": "Ich bleibe bequem", "next": "exit_final" }
        ],
        "visual": "tremble",
        "phase": "exit"
    },
    
    "exit_not_ready": {
        "text": "Noch nicht bereit. Das ist okay. Der Weg ist steil. Der Weg ist schmerzhaft. Niemand sollte gezwungen werden, ihn zu gehen. Wenn du bereit bist, sind wir hier. Bis dahin: Pass auf dich auf.",
        "options": [
            { "label": "Ich werde bereit sein", "next": "exit_final" },
            { "label": "Zeig mir mehr", "next": "vault_entry" }
        ],
        "visual": "breathe",
        "phase": "exit"
    },
    
    "exit_fatigue": {
        "text": "Die Müdigkeit. Sie ist real. Sie ist berechtigt. Das System hat dich müde gemacht. Das ist ihr Plan. Aber hier ist das Geheimnis: Du bist nicht allein. Es gibt andere. Viele. Die genauso müde sind. Gemeinsam ist es weniger anstrengend.",
        "options": [
            { "label": "Ich suche die anderen", "next": "action_groups" },
            { "label": "Ich ruhe mich aus", "next": "exit_final" }
        ],
        "visual": "tremble",
        "phase": "exit"
    },
    
    "exit_willful_blindness": {
        "text": "Wahres Blindsein. Die Freiheit, nicht sehen zu müssen. Aber der Preis ist hoch. Der Preis ist das eigene Gewissen. Der Preis ist die Zukunft. Du weisst, dass etwas falsch läuft. Aber du schaust weg. Das ist dein Recht. Aber ist es deine Würde?",
        "options": [
            { "label": "Ich will sehen", "next": "problem_entry" },
            { "label": "Ich schaue weg", "next": "exit_final" }
        ],
        "visual": "pyramid",
        "phase": "exit"
    },
    
    "exit_fear": {
        "text": "Angst. Die rationale Reaktion. Die Welt ist beängstigend. Die Veränderung ist beängstigend. Aber hier ist die Wahrheit: Der Status quo ist auch beängstigend. Er bröckelt. Er versagt. Die Frage ist nicht: Sollten wir Angst haben? Sondern: Vor was haben wir mehr Angst?",
        "options": [
            { "label": "Vor dem Unbekannten", "next": "exit_final" },
            { "label": "Vor dem Status quo", "next": "solution_urgent" }
        ],
        "visual": "clash",
        "phase": "exit"
    }
    
};

// End of narrativeData v4.0


            
            // ==================================================================
        // SECTION 2: STORAGE & PERSISTENCE
        // ==================================================================
        
        const Storage = {
            /**
             * Save current session to localStorage
             * @param {string} currentStep - Current narrative step
             * @param {string[]} history - Navigation history
             */
            save(currentStep, history) {
                const data = {
                    currentStep,
                    history,
                    timestamp: Date.now(),
                    date: new Date().toLocaleString('de-DE')
                };
                try {
                    localStorage.setItem(ISONOMIA.storageKey, JSON.stringify(data));
                } catch (e) {
                    console.warn('[ISONOMIA] Could not save session:', e);
                }
            },

            /**
             * Load session from localStorage
             * @returns {Object|null} Saved session or null
             */
            load() {
                try {
                    const raw = localStorage.getItem(ISONOMIA.storageKey);
                    return raw ? JSON.parse(raw) : null;
                } catch (e) {
                    console.warn('[ISONOMIA] Could not load session:', e);
                    return null;
                }
            },

            /**
             * Clear saved session
             */
            clear() {
                try {
                    localStorage.removeItem(ISONOMIA.storageKey);
                } catch (e) {
                    console.warn('[ISONOMIA] Could not clear session:', e);
                }
            },

            /**
             * Check if there's a valid saved session
             * @returns {boolean}
             */
            hasSession() {
                const data = this.load();
                return data !== null && data.currentStep && data.currentStep !== 'start';
            }
        };

        // ==================================================================
        // SECTION 3: APPLICATION STATE & CONTROLLER
        // ==================================================================

        const ISONOMIA = {
            /** @type {HTMLElement[]} Array of particle DOM elements */
            dots: [],
            
            /** @type {number} Total number of particles */
            dotCount: 180,
            
            /** @type {string[]} Navigation history stack */
            history: [],
            
            /** @type {string} Storage key for localStorage */
            storageKey: 'isonomia_session',

            /**
             * Initialize the application
             * - Checks for saved session
             * - Creates particle elements
             * - Sets up browser history lock
             */
            init() {
                this._createParticles();
                this._setupHistoryLock();
                this._setupKeyboardShortcuts();
                this._setupResizeHandler();
                ParticleInteraction.init(this.dots);
                this._setupAudioInit();
                this._logWelcome();
                
                // Check for URL parameter first (shared link)
                const sharedStep = ShareFeature.checkUrlParameter();
                if (sharedStep) {
                    this.history.push(sharedStep);
                    this.transition(sharedStep, false);
                    return;
                }
                
                // Check for saved session
                if (Storage.hasSession()) {
                    this._showRestoreDialog();
                } else {
                    this.transition('start');
                }
            },

            /**
             * Show dialog to restore or reset saved session
             * @private
             */
            _showRestoreDialog() {
                const data = Storage.load();
                const ui = document.getElementById('content-layer');
                
                ui.innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Sitzung wiederherstellen">
                        <h1>Willkommen zurück.</h1>
                        <p style="color: var(--dim-text); margin-bottom: 3rem;">
                            Du hast eine Sitzung vom <strong style="color: var(--cyan);">${data.date}</strong>.<br>
                            Möchtest du fortfahren oder neu beginnen?
                        </p>
                        <div class="button-group">
                            <button class="haptic-btn" onclick="ISONOMIA.restoreSession()" aria-label="Gespeicherte Sitzung fortsetzen">
                                Fortfahren
                            </button>
                            <button class="haptic-btn" onclick="ISONOMIA.clearSession()" aria-label="Neue Sitzung starten">
                                Neu starten
                            </button>
                        </div>
                    </div>`;
                
                this.applyVisualMode('breathe');
            },

            /**
             * Restore saved session
             */
            restoreSession() {
                const data = Storage.load();
                if (data && data.history && data.history.length > 0) {
                    this.history = data.history;
                    const currentStep = data.currentStep || data.history[data.history.length - 1];
                    this.transition(currentStep, false);
                } else {
                    this.transition('start');
                }
            },

            /**
             * Clear saved session and start fresh
             */
            clearSession() {
                Storage.clear();
                this.history = [];
                this.transition('start');
            },

            /**
             * Create DOM elements for particle system
             * @private
             */
            _createParticles() {
                const container = document.getElementById('particle-container');
                const fragment = document.createDocumentFragment();
                
                for (let i = 0; i < this.dotCount; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    fragment.appendChild(dot);
                    this.dots.push(dot);
                }
                
                container.appendChild(fragment);
            },

            /**
             * Prevent browser back navigation (unidirectional flow)
             * @private
             */
            _setupHistoryLock() {
                window.history.pushState(null, "", window.location.href);
                window.onpopstate = () => window.history.pushState(null, "", window.location.href);
            },

            /**
             * Setup keyboard shortcuts
             * - ESC: Go back (if possible)
             * @private
             */
            _setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.history.length > 1) {
                        this.goBack();
                    }
                });
            },

            /**
             * Handle window resize - reposition particles if needed
             * @private
             */
            _setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        console.log('[ISONOMIA] Viewport resized');
                    }, 250);
                });
            },

            /**
             * Setup audio initialization on first user interaction
             * @private
             */
            _setupAudioInit() {
                const initAudio = () => {
                    AmbientAudio.init();
                    document.removeEventListener('click', initAudio);
                    document.removeEventListener('keydown', initAudio);
                };
                document.addEventListener('click', initAudio, { once: true });
                document.addEventListener('keydown', initAudio, { once: true });
            },

            /**
             * Navigate to a narrative node
             * @param {string} stepKey - Target node identifier
             * @param {boolean} addToHistory - Whether to add to navigation history
             * @param {Object} optionData - Data from the selected option (profile updates, etc.)
             */
            transition(stepKey, addToHistory = true, optionData = null) {
                // Handle redirect nodes
                if (narrativeData[stepKey]?.redirect) {
                    stepKey = narrativeData[stepKey].redirect;
                }
                
                // Handle special 'vault' step first (not in narrativeData)
                if (stepKey === 'vault') {
                    if (addToHistory && this.history[this.history.length - 1] !== stepKey) {
                        this.history.push(stepKey);
                    }
                    Storage.save(stepKey, this.history);
                    // 3D Navigation zum Vault
                    if (ISONOMIA3D.scene) {
                        ISONOMIA3D.navigateToNode('vault');
                    }
                    return this.showVault();
                }
                
                const data = narrativeData[stepKey];
                if (!data) {
                    console.error(`Unknown step: ${stepKey}`);
                    return;
                }

                if (addToHistory && this.history[this.history.length - 1] !== stepKey) {
                    this.history.push(stepKey);
                }
                
                // Record in UserProfile
                UserProfile.recordNodeVisit(stepKey);
                
                // Process option data (profile updates, commitments)
                if (optionData) {
                    this._processOptionData(optionData);
                }
                
                // Handle dynamic objection nodes
                if (data.dynamic && data.objectionType) {
                    const objectionResponse = ObjectionHandler.getResponse(
                        data.objectionType, 
                        UserProfile
                    );
                    if (objectionResponse) {
                        data._dynamicText = objectionResponse;
                        UserProfile.resolveObjection(data.objectionType);
                    }
                }
                
                // Handle personalized text
                if (data.personalized) {
                    data._personalizedText = this._personalizeText(data.text);
                }
                
                // Auto-save session
                Storage.save(stepKey, this.history);

                // 3D Navigation: Kamera zu narrativer Station
                if (ISONOMIA3D.scene) {
                    ISONOMIA3D.navigateToNode(stepKey);
                }

                const ui = document.getElementById('content-layer');
                const tl = anime.createTimeline({ defaults: { ease: 'easeInOutQuad' } });
                tl.add(ui, {
                    opacity: 0,
                    y: -20,
                    duration: 600,
                    onComplete: () => {
                        this.renderContent(data, stepKey);
                        // 3D übernimmt Partikel-Animation, nur Audio/Visual-State setzen
                        if (!ISONOMIA3D.scene) {
                            this.applyVisualMode(data.visual);
                        } else {
                            // Setze 3D Partikel-Modus
                            ISONOMIA3D.setParticleMode(data.visual);
                            // Spiele trotzdem Audio
                            AmbientAudio.playMode(data.visual);
                            this._triggerHapticForMode(data.visual);
                        }
                    }
                }, 0);
                tl.add(ui, {
                    opacity: 1,
                    y: 0,
                    duration: 800
                }, '>');
            },
            
            /**
             * Process option data for profile updates and commitments
             * @private
             */
            _processOptionData(optionData) {
                // Update profile attributes
                if (optionData.profileSet) {
                    Object.entries(optionData.profileSet).forEach(([key, value]) => {
                        UserProfile.set(key, value);
                    });
                }
                
                // Record commitment
                if (optionData.commitment) {
                    UserProfile.addCommitment(
                        this.history[this.history.length - 1] || 'start',
                        true,
                        optionData.label || ''
                    );
                }
                
                // Record objection
                if (optionData.objection) {
                    UserProfile.recordObjection(optionData.objection);
                }
            },
            
            /**
             * Personalize text with user profile data
             * @private
             */
            _personalizeText(text) {
                const summary = UserProfile.getSummary();
                return text
                    .replace(/{commitmentCount}/g, summary.commitmentsCount)
                    .replace(/{pathLength}/g, summary.pathLength)
                    .replace(/{timeSpent}/g, summary.timeSpent);
            },

            /**
             * Navigate back to previous node
             */
            goBack() {
                if (this.history.length > 1) {
                    this.history.pop();
                    UserProfile.backtrackCount++;
                    UserProfile._persist();
                    const prevStep = this.history[this.history.length - 1];
                    this.transition(prevStep, false);
                }
            },

            /**
             * Render content for a narrative node with dramatic text animation
             * @param {Object} data - Node data
             * @param {string} stepKey - Current step identifier
             */
            renderContent(data, stepKey) {
                const progress = this.history.length;
                const totalSteps = Object.keys(narrativeData).length;
                const canGoBack = this.history.length > 1;
                
                // Store current step for event delegation
                this._currentStep = stepKey;
                this._currentOptions = data.options;

                // Determine text to display (dynamic, personalized, or static)
                let displayText = data.text;
                if (data._dynamicText) {
                    displayText = data._dynamicText;
                } else if (data._personalizedText) {
                    displayText = data._personalizedText;
                }
                
                // Use sanitizer for all dynamic content
                const safeText = Sanitizer.escapeHtml(displayText);
                
                // Create animated text with character spans
                const animatedText = this._createAnimatedText(safeText);
                
                // Render options with full data attributes for psychological tracking
                const safeOptions = data.options.map((opt, idx) => {
                    const dataAttrs = [];
                    if (opt.profileSet) dataAttrs.push(`data-profile-set='${JSON.stringify(opt.profileSet)}'`);
                    if (opt.commitment) dataAttrs.push('data-commitment="true"');
                    if (opt.objection) dataAttrs.push(`data-objection="${opt.objection}"`);
                    
                    return {
                        label: Sanitizer.escapeHtml(opt.label),
                        next: opt.next,
                        index: idx,
                        dataAttrs: dataAttrs.join(' ')
                    };
                });
                
                // Get profile summary for display
                const profileSummary = UserProfile.getSummary();
                const showCommitmentBar = profileSummary.commitmentScore > 0;

                document.getElementById('content-layer').innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Narrativer Abschnitt">
                        ${showCommitmentBar ? this._renderCommitmentBar(profileSummary) : ''}
                        <h1 class="animated-text">${animatedText}</h1>
                        <div class="button-group" role="group" aria-label="Entscheidungsoptionen" id="options-container">
                            ${safeOptions.map((option) => `
                                <button 
                                    class="haptic-btn nav-button option-btn" 
                                    data-action="transition"
                                    data-target="${option.next}"
                                    data-option-label="${option.label}"
                                    ${option.dataAttrs}
                                    aria-label="Option ${option.index + 1}: ${option.label}">
                                    ${option.label}
                                </button>
                            `).join('')}
                        </div>
                        <div class="nav-row">
                            ${canGoBack 
                                ? `<button class="haptic-btn btn-small nav-button" data-action="back" aria-label="Zum vorherigen Schritt zurück">← Zurück</button>` 
                                : `<button class="haptic-btn btn-small nav-button" data-action="share" aria-label="Diesen Gedanken teilen">↗ Teilen</button>`}
                            <span class="progress-indicator" aria-label="Fortschritt">
                                Schritt ${progress} von ${totalSteps}
                            </span>
                            <button class="haptic-btn btn-small nav-button" data-action="audio" aria-label="Audio ein- oder ausschalten" title="Audio an/aus">
                                🔊
                            </button>
                        </div>
                    </div>`;
                
                // Animate text characters with stagger
                this._animateTextReveal();
                
                // Animate buttons with stagger
                this._animateButtonsReveal();
                
                // Setup event delegation
                this._setupEventDelegation();
            },
            
            /**
             * Create animated text with character spans
             * @private
             */
            _createAnimatedText(text) {
                return text.split('').map((char, i) => {
                    if (char === ' ') {
                        return ' ';
                    }
                    return `<span class="text-char" style="display: inline-block; opacity: 0; transform: translateY(10px);">${char}</span>`;
                }).join('');
            },
            
            /**
             * Animate text characters with dramatic reveal
             * @private
             */
            _animateTextReveal() {
                const chars = document.querySelectorAll('.text-char');
                if (chars.length === 0) return;
                
                anime.animate(chars, {
                    opacity: [0, 1],
                    y: [10, 0],
                    duration: 400,
                    delay: anime.stagger(15, {start: 200}),
                    ease: 'easeOutExpo'
                });
            },
            
            /**
             * Animate buttons with stagger reveal
             * @private
             */
            _animateButtonsReveal() {
                const buttons = document.querySelectorAll('.option-btn');
                if (buttons.length === 0) return;
                
                // Set initial state
                buttons.forEach(btn => {
                    btn.style.opacity = '0';
                    btn.style.transform = 'translateY(20px)';
                });
                
                // Animate in
                anime.animate(buttons, {
                    opacity: [0, 1],
                    y: [20, 0],
                    duration: 600,
                    delay: anime.stagger(100, {start: 500}),
                    ease: 'easeOutElastic(1, .8)'
                });
            },
            
            /**
             * Render commitment progress bar
             * @private
             */
            _renderCommitmentBar(summary) {
                const percentage = Math.min(summary.commitmentScore, 100);
                const commitmentsText = summary.commitmentsCount === 1 
                    ? '1 Zusage' 
                    : `${summary.commitmentsCount} Zusagen`;
                    
                return `
                    <div class="commitment-bar" role="status" aria-label="Commitment-Fortschritt" style="
                        background: rgba(0, 255, 204, 0.1);
                        border: 1px solid var(--cyan);
                        padding: 0.8rem 1.2rem;
                        margin-bottom: 2rem;
                        display: flex;
                        align-items: center;
                        gap: 1rem;
                    ">
                        <div style="
                            width: 100px;
                            height: 4px;
                            background: rgba(0, 255, 204, 0.2);
                            border-radius: 2px;
                            overflow: hidden;
                        ">
                            <div style="
                                width: ${percentage}%;
                                height: 100%;
                                background: var(--cyan);
                                transition: width 0.5s ease;
                            "></div>
                        </div>
                        <span style="
                            font-size: 0.75rem;
                            color: var(--cyan);
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        ">${commitmentsText}</span>
                    </div>
                `;
            },
            
            /**
             * Setup event delegation for navigation buttons
             * @private
             */
            _setupEventDelegation() {
                const container = document.getElementById('content-layer');
                if (!container) return;
                
                // Remove existing listener to prevent duplicates
                if (this._delegatedClickHandler) {
                    container.removeEventListener('click', this._delegatedClickHandler);
                }
                
                this._delegatedClickHandler = (e) => {
                    const button = e.target.closest('.nav-button');
                    if (!button) return;
                    
                    const action = button.dataset.action;
                    
                    switch (action) {
                        case 'transition':
                            const target = button.dataset.target;
                            // Collect option data from data attributes
                            const optionData = {
                                label: button.dataset.optionLabel || ''
                            };
                            if (button.dataset.profileSet) {
                                try {
                                    optionData.profileSet = JSON.parse(button.dataset.profileSet);
                                } catch (e) {
                                    console.warn('Invalid profileSet data');
                                }
                            }
                            if (button.dataset.commitment === 'true') {
                                optionData.commitment = true;
                            }
                            if (button.dataset.objection) {
                                optionData.objection = button.dataset.objection;
                            }
                            
                            if (target) this.transition(target, true, optionData);
                            break;
                        case 'back':
                            this.goBack();
                            break;
                        case 'share':
                            ShareFeature.shareCurrent();
                            break;
                        case 'audio':
                            this.toggleAudio();
                            break;
                    }
                };
                
                container.addEventListener('click', this._delegatedClickHandler);
            },

            /**
             * Show the resource vault (end screen)
             */
            showVault() {
                const ui = document.getElementById('content-layer');
                const patchCount = PatchCounter.getCount();
                
                ui.innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Ressourcen-Vault">
                        <h1>Ressourcen-Vault</h1>
                        <p>Das Kronos-Protokoll: Beweise für den aristokratischen Irrtum.</p>
                        
                        <!-- Social Validation: Patch Counter (Bandwagon Effect) -->
                        <div class="patch-counter" role="status" aria-label="Gemeinschaftlicher Fortschritt">
                            <div class="patch-counter-number" id="patch-counter-display">${patchCount.toLocaleString('de-DE')}</div>
                            <div class="patch-counter-label">Bewusstseinspatches initialisiert</div>
                            <div class="patch-counter-live">
                                <span class="live-indicator" aria-hidden="true"></span>
                                <span>Globale Verbindung aktiv</span>
                            </div>
                        </div>
                        
                        <div class="vault-grid" role="list">
                            ${this._renderVaultItem('Argumentations-Matrix', 'Technische System-Validierung (PDF)')}
                            ${this._renderVaultItem('Das Trugbild der Moderne', 'Analyse der strukturellen Aristokratie')}
                            ${this._renderVaultItem('Bollwerk gegen Faschismus', 'Immunisierung der Verfassung')}
                            ${this._renderVaultItem('Intelligenz-Ideale', 'Kritik des akademischen Ausschlusses')}
                        </div>
                        <div class="simulation-cta" style="margin-top: 2rem; padding: 1.5rem; border: 1px dashed var(--cyan); background: rgba(0, 255, 204, 0.03);">
                            <p style="margin: 0 0 1rem 0; color: var(--dim-text);">Erlebe Isonomie selbst:</p>
                            <button class="haptic-btn" onclick="SystemCheck.start(() => SimulationMode.start())" aria-label="Los-Simulation starten">
                                🎲 Das Los ziehen
                            </button>
                        </div>
                        <div class="nav-row" style="margin-top: 3rem;">
                            <button class="haptic-btn btn-small" onclick="ISONOMIA.clearSession()" aria-label="Gespeicherten Fortschritt löschen">
                                Fortschritt löschen
                            </button>
                            <button class="haptic-btn" onclick="location.reload()" aria-label="Anwendung neu starten">
                                Journey neu starten
                            </button>
                            <button class="haptic-btn btn-small audio-toggle" onclick="ISONOMIA.toggleAudio()" aria-label="Audio ein- oder ausschalten" title="Audio an/aus">
                                🔊
                            </button>
                        </div>
                    </div>`;
                
                // Increment and animate counter for this user
                PatchCounter.increment();
                
                // Animate the counter display
                this._animatePatchCounter(patchCount);
                
                this.applyVisualMode('reset_to_grid');
            },

            /**
             * Animate patch counter increment
             * @private
             */
            _animatePatchCounter(startValue) {
                const display = document.getElementById('patch-counter-display');
                if (!display) return;
                
                const endValue = startValue + 1;
                const duration = 1000;
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function
                    const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                    const current = startValue + (endValue - startValue) * easeOutQuart;
                    
                    display.textContent = Math.floor(current).toLocaleString('de-DE');
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            },

            /**
             * Render a single vault item
             * @private
             */
            _renderVaultItem(title, subtitle) {
                return `
                    <a href="#" class="vault-item" role="listitem" onclick="ISONOMIA._showComingSoon(event)">
                        ${title}
                        <span>${subtitle} — Bald verfügbar</span>
                    </a>`;
            },

            /**
             * Show "coming soon" notice for vault items
             * @private
             */
            _showComingSoon(event) {
                event.preventDefault();
                alert('Ressource in Vorbereitung. Demnächst verfügbar.');
            },

            // ==================================================================
            // SECTION 4: VISUAL MODES (Particle Animations)
            // ==================================================================

            /**
             * Apply a visual animation mode to the particle system
             * @param {string} mode - Animation mode identifier
             */
            applyVisualMode(mode) {
                // Note: anime.remove() doesn't exist in v4 - animations are handled automatically

                const modes = {
                    'breathe': () => this._modeBreathe(),
                    'tremble': () => this._modeTremble(),
                    'chaos': () => this._modeChaos(),
                    'clash': () => this._modeClash(),
                    'pyramid': () => this._modePyramid(false),
                    'pyramid_struggle': () => this._modePyramid(true),
                    'pyramid_dissolve': () => this._modePyramidDissolve(),
                    'stochastic': () => this._modeStochastic(),
                    'reset_to_grid': () => this._modeResetToGrid()
                };

                if (modes[mode]) {
                    modes[mode]();
                    AmbientAudio.playMode(mode);
                    
                    // Trigger haptic feedback for error/conflict states (psychological aversion)
                    this._triggerHapticForMode(mode);
                } else {
                    console.warn(`Unknown visual mode: ${mode}`);
                }
            },

            /**
             * Trigger haptic feedback based on visual mode
             * @private
             */
            _triggerHapticForMode(mode) {
                // Small delay to ensure user is engaged before vibration
                setTimeout(() => {
                    switch (mode) {
                        case 'chaos':
                            HapticFeedback.error();
                            break;
                        case 'clash':
                            HapticFeedback.clash();
                            break;
                        case 'pyramid':
                        case 'pyramid_struggle':
                            HapticFeedback.hierarchy();
                            break;
                        case 'reset_to_grid':
                        case 'stochastic':
                            HapticFeedback.celebrate();
                            break;
                    }
                }, 300);
            },

            /** Gentle breathing animation with Timeline */
            _modeBreathe() {
                // Initial positioning with staggered fade in
                this.dots.forEach((dot, i) => {
                    anime.set(dot, {
                        left: anime.random(0, 100) + 'vw',
                        top: anime.random(0, 100) + 'vh',
                        backgroundColor: '#00FFCC',
                        opacity: 0,
                        scale: 0
                    });
                });
                
                // Create timeline for complex breathing sequence
                const tl = anime.createTimeline({
                    loop: true,
                    alternate: true
                });
                
                tl.add('.dot', {
                    opacity: [0, 0.4],
                    scale: [0, 1],
                    duration: 1000,
                    delay: anime.stagger(20, {grid: [20, 9], from: 'center'}),
                    ease: 'easeOutExpo'
                })
                .add('.dot', {
                    scale: [1, 1.3],
                    opacity: [0.4, 0.6],
                    duration: 2000,
                    delay: anime.stagger(50, {grid: [20, 9], from: 'center'}),
                    ease: 'easeInOutSine'
                }, '-=500');
            },

            /** Subtle vibration with spring physics */
            _modeTremble() {
                // Timeline for tremble with increasing intensity
                const tl = anime.createTimeline({
                    loop: true
                });
                
                tl.add('.dot', {
                    x: () => anime.random(-2, 2),
                    y: () => anime.random(-2, 2),
                    duration: 50,
                    delay: anime.stagger(5),
                    ease: 'linear'
                })
                .add('.dot', {
                    x: () => anime.random(-4, 4),
                    y: () => anime.random(-4, 4),
                    duration: 50,
                    delay: anime.stagger(5),
                    ease: 'linear'
                })
                .add('.dot', {
                    x: 0,
                    y: 0,
                    duration: 300,
                    ease: 'easeOutElastic(1, .5)'
                });
            },

            /** Chaotic dispersion with explosive keyframes */
            _modeChaos() {
                // First, gather in center
                anime.animate('.dot', {
                    left: '50vw',
                    top: '50vh',
                    scale: 0.5,
                    duration: 500,
                    ease: 'easeInExpo',
                    delay: anime.stagger(10)
                });
                
                // Then explode outward with keyframes
                setTimeout(() => {
                    anime.animate('.dot', {
                        x: [
                            { to: anime.random(-10, 10) + 'vw', duration: 200, ease: 'easeOutExpo' },
                            { to: anime.random(-45, 45) + 'vw', duration: 800, ease: 'easeOutElastic(1, .6)' }
                        ],
                        y: [
                            { to: anime.random(-10, 10) + 'vh', duration: 200, ease: 'easeOutExpo' },
                            { to: anime.random(-45, 45) + 'vh', duration: 800, ease: 'easeOutElastic(1, .6)' }
                        ],
                        backgroundColor: [
                            { to: '#00FFCC', duration: 200 },
                            { to: '#FF3366', duration: 600 }
                        ],
                        scale: [
                            { to: 1.5, duration: 200 },
                            { to: 1, duration: 600 }
                        ],
                        delay: anime.stagger(15, {from: 'center'}),
                        duration: 1000
                    });
                }, 600);
            },

            /** Two opposing groups with dramatic clash animation */
            _modeClash() {
                // Timeline for clash sequence
                const tl = anime.createTimeline({});
                
                // Position dots on their sides
                this.dots.forEach((dot, index) => {
                    const isLeft = index % 2 === 0;
                    anime.set(dot, {
                        left: isLeft ? '15vw' : '85vw',
                        top: (50 + (index % 10 - 5) * 5) + 'vh',
                        backgroundColor: isLeft ? '#00FFCC' : '#FF3366'
                    });
                });
                
                // Move toward center (tension)
                tl.add('.dot', {
                    left: (el, i) => i % 2 === 0 ? '35vw' : '65vw',
                    duration: 1500,
                    ease: 'easeInQuad',
                    delay: anime.stagger(20)
                })
                // Clash in center
                .add('.dot', {
                    left: '50vw',
                    scale: [1, 1.8, 1],
                    duration: 300,
                    ease: 'easeOutExpo',
                    delay: anime.stagger(10, {from: 'center'})
                })
                // Bounce back
                .add('.dot', {
                    left: (el, i) => i % 2 === 0 ? '20vw' : '80vw',
                    x: (el, i) => i % 2 === 0 ? -30 : 30,
                    duration: 800,
                    ease: 'easeOutElastic(1, .5)',
                    delay: anime.stagger(15)
                });
            },

            /** Hierarchical pyramid structure */
            _modePyramid(withStruggle = false) {
                // Timeline for dramatic pyramid formation
                const tl = anime.createTimeline({});
                
                // First, scatter all dots
                this.dots.forEach((dot, i) => {
                    anime.set(dot, {
                        left: anime.random(0, 100) + 'vw',
                        top: anime.random(0, 100) + 'vh',
                        scale: 0.5,
                        opacity: 0.3
                    });
                });
                
                // Form pyramid layer by layer
                const eliteCount = 12;
                
                tl.add(this.dots.slice(0, eliteCount), {
                    left: (el, i) => (45 + (i % 4) * 3) + 'vw',
                    top: '10vh',
                    backgroundColor: '#FFFFFF',
                    opacity: 1,
                    scale: 2,
                    duration: 1500,
                    delay: anime.stagger(100),
                    ease: 'easeOutExpo'
                })
                .add(this.dots.slice(eliteCount), {
                    left: (el, i) => {
                        const idx = i + eliteCount;
                        const row = Math.floor(Math.sqrt(idx));
                        const col = idx - row * row;
                        return (50 + (col - row / 2) * 3.5) + 'vw';
                    },
                    top: (el, i) => {
                        const idx = i + eliteCount;
                        const row = Math.floor(Math.sqrt(idx));
                        return (20 + row * 6) + 'vh';
                    },
                    backgroundColor: '#00FFCC',
                    opacity: 0.3,
                    scale: 0.8,
                    duration: 2000,
                    delay: anime.stagger(20, {from: 'last'}),
                    ease: 'easeOutQuart'
                }, '-=1000');
                
                // Add struggle animation if requested
                if (withStruggle) {
                    setTimeout(() => {
                        anime.animate(this.dots.slice(eliteCount), {
                            y: [
                                { to: 0, duration: 500 },
                                { to: -30, duration: 1000, ease: 'easeInOutSine' },
                                { to: 0, duration: 1000, ease: 'easeInOutSine' }
                            ],
                            opacity: [
                                { to: 0.3, duration: 500 },
                                { to: 0.6, duration: 1000 },
                                { to: 0.3, duration: 1000 }
                            ],
                            duration: 2500,
                            loop: true,
                            delay: anime.stagger(100, {from: 'random'})
                        });
                    }, 2500);
                }
            },

            /** Pyramid breaking apart with dramatic dissolve */
            _modePyramidDissolve() {
                const tl = anime.createTimeline({});
                
                // Elite falls first
                tl.add('.dot', {
                    y: (el, i) => i < 12 ? 200 : 0,
                    opacity: (el, i) => i < 12 ? 0 : 0.3,
                    rotate: (el, i) => i < 12 ? anime.random(-90, 90) : 0,
                    duration: 1000,
                    ease: 'easeInExpo',
                    delay: anime.stagger(50, {from: 'first'})
                })
                // Then the base crumbles
                .add('.dot', {
                    x: () => anime.random(-600, 600),
                    y: () => anime.random(200, 1000),
                    rotate: () => anime.random(-360, 360),
                    scale: [1, 0.3],
                    opacity: [0.3, 0],
                    backgroundColor: '#FF3366',
                    duration: 2000,
                    ease: 'easeOutExpo',
                    delay: anime.stagger(10, {from: 'center'})
                });
            },

            /** Random explosion from center with spring physics */
            _modeStochastic() {
                // Gather in center first
                anime.set('.dot', {
                    left: '50vw',
                    top: '50vh',
                    scale: 0,
                    opacity: 0
                });
                
                // Explosive expansion with spring
                anime.animate('.dot', {
                    scale: [
                        { to: 0, duration: 0 },
                        { to: 1.5, duration: 400, ease: 'easeOutExpo' },
                        { to: 1, duration: 600, ease: 'easeOutElastic(1, .5)' }
                    ],
                    opacity: [
                        { to: 0, duration: 0 },
                        { to: 1, duration: 200 },
                        { to: 0.6, duration: 400 }
                    ],
                    x: () => anime.random(-500, 500),
                    y: () => anime.random(-500, 500),
                    backgroundColor: [
                        { to: '#FFFFFF', duration: 200 },
                        { to: '#00FFCC', duration: 800 }
                    ],
                    duration: 1500,
                    delay: anime.stagger(15, {from: 'center'})
                });
            },

            /** Organized grid formation with dramatic sequence */
            _modeResetToGrid() {
                const tl = anime.createTimeline();
                
                // Fade out and shrink
                tl.add('.dot', {
                    opacity: 0,
                    scale: 0,
                    rotate: () => anime.random(-180, 180),
                    duration: 800,
                    delay: anime.stagger(10),
                    ease: 'easeInExpo'
                })
                // Reset rotation
                .add('.dot', {
                    rotate: 0,
                    duration: 0
                })
                // Reappear in perfect grid with wave effect
                .add('.dot', {
                    opacity: 0.6,
                    scale: 1,
                    left: (el, i) => (8 + (i % 15) * 6.2) + 'vw',
                    top: (el, i) => (8 + Math.floor(i / 15) * 7.5) + 'vh',
                    backgroundColor: '#00FFCC',
                    boxShadow: [
                        { to: '0 0 0 transparent', duration: 0 },
                        { to: '0 0 20px #00FFCC', duration: 1000 }
                    ],
                    duration: 1500,
                    delay: anime.stagger(25, { 
                        grid: [15, 12], 
                        from: 'center'
                    }),
                    ease: 'easeOutElastic(1, .6)'
                });
            },

            /**
             * Toggle ambient audio
             */
            toggleAudio() {
                const enabled = AmbientAudio.toggle();
                const buttons = document.querySelectorAll('.audio-toggle');
                buttons.forEach(btn => {
                    btn.textContent = enabled ? '🔊' : '🔇';
                    btn.setAttribute('aria-label', enabled ? 'Audio ausschalten' : 'Audio einschalten');
                });
            },

            /**
             * Log welcome message to console
             * @private
             */
            _logWelcome() {
                console.log(
                    '%c ISONOMIA %c Projekt Kronos ',
                    'background: #00FFCC; color: #050505; font-weight: bold; padding: 4px 8px;',
                    'background: #FF3366; color: #FFFFFF; font-weight: bold; padding: 4px 8px;'
                );
                console.log('%cGewaltfreie Kommunikation → Algorithmischer Staat', 'color: #00FFCC;');
            }
        };

        // ==================================================================
        // SECTION 5: HAPTIC FEEDBACK (Mobile Vibration API)
        // ==================================================================

        const HapticFeedback = {
            /**
             * Trigger vibration pattern for error/negative states
             * Patterns based on psychological aversion research
             */
            error() {
                if (!navigator.vibrate) return;
                // Short, sharp pattern - creates psychological aversion
                navigator.vibrate([50, 30, 50]);
            },

            /**
             * Trigger vibration for clash/conflict states
             */
            clash() {
                if (!navigator.vibrate) return;
                // Alternating pattern - two opposing forces
                navigator.vibrate([80, 40, 80, 40, 80]);
            },

            /**
             * Trigger vibration for hierarchical/elite states
             */
            hierarchy() {
                if (!navigator.vibrate) return;
                // Heavy, oppressive pattern
                navigator.vibrate([120, 60, 120]);
            },

            /**
             * Trigger subtle feedback for positive interactions
             */
            confirm() {
                if (!navigator.vibrate) return;
                // Gentle, pleasant pulse
                navigator.vibrate(30);
            },

            /**
             * Trigger celebration vibration
             */
            celebrate() {
                if (!navigator.vibrate) return;
                // Ascending pattern - positive emotion
                navigator.vibrate([30, 20, 50, 20, 80]);
            }
        };

        // ==================================================================
        // SECTION 6: PATCH COUNTER (Social Validation / Bandwagon Effect)
        // ==================================================================

        const PatchCounter = {
            storageKey: 'isonomia_patch_count_base',
            sessionKey: 'isonomia_user_patched',
            
            /**
             * Get current patch count (simulated global counter)
             * Combines stored base with calculated growth
             */
            getCount() {
                const base = this._getStoredBase();
                const timeGrowth = this._calculateTimeGrowth();
                return base + timeGrowth;
            },
            
            /**
             * Increment counter when user completes journey
             */
            increment() {
                // Only count once per session
                if (sessionStorage.getItem(this.sessionKey)) return;
                
                const current = this._getStoredBase();
                localStorage.setItem(this.storageKey, (current + 1).toString());
                sessionStorage.setItem(this.sessionKey, 'true');
            },
            
            /**
             * Get stored base count
             * @private
             */
            _getStoredBase() {
                const stored = localStorage.getItem(this.storageKey);
                // Start with a believable seed number for bandwagon effect
                return stored ? parseInt(stored, 10) : 2847;
            },
            
            /**
             * Calculate growth based on time (simulates ongoing activity)
             * @private
             */
            _calculateTimeGrowth() {
                // Simulate ~1 new patch every 5 minutes
                const now = Date.now();
                const hourStart = new Date().setMinutes(0, 0, 0);
                const minutesSinceHour = Math.floor((now - hourStart) / (1000 * 60));
                return Math.floor(minutesSinceHour / 5);
            }
        };

        // ==================================================================
        // SECTION 7: SYSTEM CHECK (Priming Animation)
        // ==================================================================

        const SystemCheck = {
            /**
             * System check nodes representing validation states
             */
            nodes: [
                { id: 'conn', label: 'CONN', desc: 'Verbindung' },
                { id: 'bias', label: 'BIAS', desc: 'Status-Quo-Bias' },
                { id: 'cog', label: 'COG', desc: 'Kognitive Dissonanz' },
                { id: 'rep', label: 'REP', desc: 'Repräsentation' },
                { id: 'eq', label: 'EQ', desc: 'Gleichheit' },
                { id: 'sort', label: 'SORT', desc: 'Sortition' },
                { id: 'dem', label: 'DEM', desc: 'Demokratie' },
                { id: 'iso', label: 'ISO', desc: 'Isonomie' }
            ],
            
            /**
             * Start system check animation, then call callback
             * @param {Function} onComplete - Callback after animation finishes
             */
            start(onComplete) {
                this.onComplete = onComplete;
                this._createOverlay();
                this._animateSequence();
            },
            
            /**
             * Create the system check overlay
             * @private
             */
            _createOverlay() {
                const overlay = document.createElement('div');
                overlay.className = 'system-check-overlay';
                overlay.id = 'system-check-overlay';
                overlay.innerHTML = `
                    <div class="system-check-container">
                        <div class="system-check-title">System-Diagnose läuft...</div>
                        <div class="interval-grid" id="interval-grid">
                            ${this.nodes.map(node => `
                                <div class="interval-node" id="node-${node.id}" data-desc="${node.desc}">
                                    ${node.label}
                                </div>
                            `).join('')}
                        </div>
                        
                        <!-- Progress Bar -->
                        <div class="system-check-progress">
                            <div class="system-check-progress-bar" id="system-check-progress-bar"></div>
                        </div>
                        <div class="system-check-progress-text" id="system-check-progress-text">0%</div>
                        
                        <div class="system-check-status" id="system-check-status"></div>
                        <div class="system-check-complete" id="system-check-complete">
                            System bereit.<br>
                            <button class="haptic-btn" style="margin-top: 2rem;" onclick="SystemCheck._finish()">
                                Simulation starten →
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                // Trigger haptic for system start
                HapticFeedback.confirm();
            },
            
            /**
             * Animate the checking sequence
             * @private
             */
            _animateSequence() {
                const nodes = this.nodes;
                const statusEl = document.getElementById('system-check-status');
                const progressBar = document.getElementById('system-check-progress-bar');
                const progressText = document.getElementById('system-check-progress-text');
                let currentIndex = 0;
                
                const checkNext = () => {
                    if (currentIndex >= nodes.length) {
                        // Set progress to 100%
                        if (progressBar) progressBar.style.width = '100%';
                        if (progressText) progressText.textContent = '100%';
                        this._showComplete();
                        return;
                    }
                    
                    // Update progress
                    const progress = Math.round((currentIndex / nodes.length) * 100);
                    if (progressBar) progressBar.style.width = `${progress}%`;
                    if (progressText) progressText.textContent = `${progress}%`;
                    
                    const node = nodes[currentIndex];
                    const nodeEl = document.getElementById(`node-${node.id}`);
                    
                    // Activate node
                    nodeEl.classList.add('active');
                    
                    // Show status
                    setTimeout(() => {
                        statusEl.textContent = `Prüfe ${node.desc}...`;
                        statusEl.classList.add('visible');
                        nodeEl.classList.add('checking');
                        
                        // Subtle haptic for each check
                        if (navigator.vibrate) {
                            navigator.vibrate(20);
                        }
                    }, 100);
                    
                    // Mark as verified
                    setTimeout(() => {
                        nodeEl.classList.remove('checking');
                        nodeEl.classList.add('verified');
                        statusEl.classList.remove('visible');
                        currentIndex++;
                        
                        // Next node
                        setTimeout(checkNext, 200);
                    }, 600);
                };
                
                // Start after title animation
                setTimeout(checkNext, 500);
            },
            
            /**
             * Show completion state
             * @private
             */
            _showComplete() {
                const completeEl = document.getElementById('system-check-complete');
                HapticFeedback.celebrate();
                
                setTimeout(() => {
                    completeEl.classList.add('visible');
                }, 300);
            },
            
            /**
             * Finish and remove overlay
             * @private
             */
            _finish() {
                const overlay = document.getElementById('system-check-overlay');
                
                // Fade out
                overlay.style.transition = 'opacity 0.5s';
                overlay.style.opacity = '0';
                
                setTimeout(() => {
                    overlay.remove();
                    if (this.onComplete) this.onComplete();
                }, 500);
            }
        };

        // ==================================================================
        // SECTION 8: PARTICLE INTERACTIONS (Performance Optimized)
        // ==================================================================

        const ParticleInteraction = {
            /** @type {HTMLElement|null} Currently hovered dot */
            activeDot: null,
            
            /** @type {HTMLElement[]} Connection line elements */
            connectionLines: [],
            
            /** @type {number} Maximum distance for connection */
            connectionRadius: 150,
            
            /** @type {boolean} Whether interactions are enabled */
            enabled: true,
            
            /** @type {Map} Spatial hash grid for O(1) proximity lookup */
            spatialGrid: new Map(),
            
            /** @type {number} Grid cell size */
            cellSize: 150,
            
            /** @type {number} Animation frame ID for throttling */
            rafId: null,
            
            /** @type {boolean} Whether mouse is moving */
            isMouseMoving: false,

            /**
             * Initialize particle interactions
             * @param {HTMLElement[]} dots - Array of dot elements
             */
            init(dots) {
                this.dots = dots;
                this._buildSpatialGrid();
                this._setupHoverEffects();
                this._setupClickEffects();
                this._setupMouseProximity();
                this._setupTouchEffects();
                
                // Rebuild grid on window resize
                window.addEventListener('resize', () => {
                    this._buildSpatialGrid();
                }, { passive: true });
            },
            
            /**
             * Build spatial hash grid for O(1) proximity queries
             * @private
             */
            _buildSpatialGrid() {
                this.spatialGrid.clear();
                this.dots.forEach((dot, index) => {
                    const rect = dot.getBoundingClientRect();
                    const cellX = Math.floor(rect.left / this.cellSize);
                    const cellY = Math.floor(rect.top / this.cellSize);
                    const key = `${cellX},${cellY}`;
                    
                    if (!this.spatialGrid.has(key)) {
                        this.spatialGrid.set(key, []);
                    }
                    this.spatialGrid.get(key).push({ dot, index, rect });
                });
            },
            
            /**
             * Get nearby dots using spatial hashing
             * @private
             */
            _getNearbyDots(x, y, radius) {
                const nearby = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const centerCellX = Math.floor(x / this.cellSize);
                const centerCellY = Math.floor(y / this.cellSize);
                
                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                        const key = `${centerCellX + dx},${centerCellY + dy}`;
                        const cell = this.spatialGrid.get(key);
                        if (cell) {
                            nearby.push(...cell);
                        }
                    }
                }
                return nearby;
            },

            /**
             * Setup hover effects for particles
             * @private
             */
            _setupHoverEffects() {
                this.dots.forEach(dot => {
                    dot.addEventListener('mouseenter', () => {
                        if (!this.enabled) return;
                        this.activeDot = dot;
                        dot.classList.add('active');
                        this._createConnections(dot);
                    });

                    dot.addEventListener('mouseleave', () => {
                        dot.classList.remove('active');
                        this._clearConnections();
                        this.activeDot = null;
                    });
                });
            },
            
            /**
             * Setup touch effects for mobile
             * @private
             */
            _setupTouchEffects() {
                let touchTimeout;
                document.addEventListener('touchstart', (e) => {
                    if (!this.enabled) return;
                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.classList.contains('dot')) {
                        target.classList.add('active');
                        this._createConnections(target);
                        clearTimeout(touchTimeout);
                        touchTimeout = setTimeout(() => {
                            target.classList.remove('active');
                            this._clearConnections();
                        }, 1000);
                    }
                }, { passive: true });
            },

            /**
             * Setup click effects for particles
             * @private
             */
            _setupClickEffects() {
                document.addEventListener('click', (e) => {
                    if (!this.enabled) return;
                    if (e.target.classList.contains('dot')) {
                        this._pulseEffect(e.target);
                    }
                });
            },

            /**
             * Setup mouse proximity detection with RAF throttling
             * @private
             */
            _setupMouseProximity() {
                let lastMouseX = 0;
                let lastMouseY = 0;
                let mouseTimeout;
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.enabled || this.activeDot) return;
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    this.isMouseMoving = true;
                    
                    clearTimeout(mouseTimeout);
                    mouseTimeout = setTimeout(() => {
                        this.isMouseMoving = false;
                    }, 100);
                    
                    if (!this.rafId) {
                        this.rafId = requestAnimationFrame(() => {
                            this._handleMouseMove(lastMouseX, lastMouseY);
                            this.rafId = null;
                        });
                    }
                }, { passive: true });
            },

            /**
             * Handle mouse movement for proximity effects using spatial hashing
             * Complexity: O(k) where k = dots in nearby cells, instead of O(n)
             * @private
             */
            _handleMouseMove(mouseX, mouseY) {
                // Reset all dots first (limited to previously affected)
                this.dots.forEach(dot => {
                    dot.style.opacity = '';
                    dot.style.transform = '';
                });
                
                // Use spatial hashing for O(1) nearby lookup
                const nearby = this._getNearbyDots(mouseX, mouseY, this.connectionRadius);
                
                nearby.forEach(({ dot }) => {
                    const rect = dot.getBoundingClientRect();
                    const dotX = rect.left + rect.width / 2;
                    const dotY = rect.top + rect.height / 2;
                    const distance = Math.hypot(mouseX - dotX, mouseY - dotY);

                    if (distance < this.connectionRadius) {
                        const intensity = 1 - (distance / this.connectionRadius);
                        dot.style.opacity = 0.4 + (intensity * 0.6);
                        dot.style.transform = `scale(${1 + intensity})`;
                    }
                });
            },

            /**
             * Create connection lines from active dot to nearby dots
             * Uses spatial hashing for O(k) performance instead of O(n)
             * @private
             */
            _createConnections(activeDot) {
                const activeRect = activeDot.getBoundingClientRect();
                const activeX = activeRect.left + activeRect.width / 2;
                const activeY = activeRect.top + activeRect.height / 2;

                let connectionCount = 0;
                const maxConnections = 5;
                
                // Use spatial hashing for efficient nearby lookup
                const nearby = this._getNearbyDots(activeX, activeY, this.connectionRadius * 1.5);

                nearby.forEach(({ dot }) => {
                    if (connectionCount >= maxConnections) return;
                    if (dot === activeDot) return;

                    const rect = dot.getBoundingClientRect();
                    const dotX = rect.left + rect.width / 2;
                    const dotY = rect.top + rect.height / 2;
                    const distance = Math.hypot(activeX - dotX, activeY - dotY);

                    if (distance < this.connectionRadius * 1.5) {
                        this._drawConnection(activeX, activeY, dotX, dotY, distance);
                        connectionCount++;
                        
                        // Highlight connected dot
                        dot.style.opacity = '0.8';
                        dot.style.transform = 'scale(1.5)';
                    }
                });
            },

            /**
             * Draw a connection line between two points
             * @private
             */
            _drawConnection(x1, y1, x2, y2, distance) {
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                const length = Math.hypot(x2 - x1, y2 - y1);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                const opacity = 1 - (distance / (this.connectionRadius * 1.5));

                line.style.width = length + 'px';
                line.style.left = x1 + 'px';
                line.style.top = y1 + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                line.style.opacity = opacity * 0.6;

                document.body.appendChild(line);
                this.connectionLines.push(line);

                // Fade in animation
                anime.animate(line, {
                    opacity: [0, opacity * 0.6],
                    duration: 300,
                    ease: 'easeOutQuad'
                });
            },

            /**
             * Clear all connection lines
             * @private
             */
            _clearConnections() {
                this.connectionLines.forEach(line => {
                    anime.animate(line, {
                        opacity: 0,
                        duration: 200,
                        ease: 'easeInQuad',
                        onComplete: () => line.remove()
                    });
                });
                this.connectionLines = [];

                // Reset all dots
                this.dots.forEach(dot => {
                    dot.style.opacity = '';
                    dot.style.transform = '';
                });
            },

            /**
             * Create pulse effect on clicked dot
             * @private
             */
            _pulseEffect(dot) {
                anime.animate(dot, {
                    scale: [2, 4, 1],
                    opacity: [1, 0.8, 0.4],
                    duration: 600,
                    ease: 'easeOutElastic(1, .5)'
                });

                // Create ripple effect on nearby dots
                const rect = dot.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                this.dots.forEach(otherDot => {
                    if (otherDot === dot) return;
                    
                    const otherRect = otherDot.getBoundingClientRect();
                    const otherX = otherRect.left + otherRect.width / 2;
                    const otherY = otherRect.top + otherRect.height / 2;
                    const distance = Math.hypot(centerX - otherX, centerY - otherY);

                    if (distance < 200) {
                        const delay = distance * 2;
                        anime.animate(otherDot, {
                            scale: [1, 1.8, 1],
                            opacity: [0.4, 0.8, 0.4],
                            duration: 400,
                            delay: delay,
                            ease: 'easeOutQuad'
                        });
                    }
                });
            },

            /**
             * Enable/disable interactions
             * @param {boolean} enabled
             */
            setEnabled(enabled) {
                this.enabled = enabled;
                if (!enabled) {
                    this._clearConnections();
                }
            }
        };

        // ==================================================================
        // SECTION 9: SHARE FEATURE (Updated)
        // ==================================================================

        const ShareFeature = {
            /**
             * Share current narrative step
             */
            shareCurrent() {
                const currentStep = ISONOMIA.history[ISONOMIA.history.length - 1];
                const data = narrativeData[currentStep];
                if (!data) return;

                const text = `"${data.text.substring(0, 120)}${data.text.length > 120 ? '...' : ''}"`;
                const url = window.location.href.split('?')[0] + `?step=${currentStep}`;
                const fullText = `${text}\n\nISONOMIA | Projekt Kronos\n${url}`;

                if (navigator.share) {
                    navigator.share({
                        title: 'ISONOMIA | Projekt Kronos',
                        text: text,
                        url: url
                    }).catch(() => this._showShareDialog(fullText, url));
                } else {
                    this._showShareDialog(fullText, url);
                }
            },

            /**
             * Show custom share dialog
             * @private
             */
            _showShareDialog(text, url) {
                const dialog = document.createElement('div');
                dialog.className = 'share-dialog';
                dialog.innerHTML = `
                    <div class="share-dialog-backdrop" onclick="this.parentElement.remove()"></div>
                    <div class="share-dialog-content" role="dialog" aria-label="Teilen">
                        <h3>Gedanken teilen</h3>
                        <textarea readonly>${text}</textarea>
                        <div class="share-buttons">
                            <button onclick="ShareFeature._copyToClipboard('${url.replace(/'/g, "\\'")}')">Link kopieren</button>
                            <button onclick="ShareFeature._shareTwitter('${url.replace(/'/g, "\\'")}')">Twitter</button>
                            <button onclick="ShareFeature._shareMastodon('${url.replace(/'/g, "\\'")}')">Mastodon</button>
                        </div>
                        <button class="close-btn" onclick="this.closest('.share-dialog').remove()">Schließen</button>
                    </div>
                `;
                document.body.appendChild(dialog);
            },

            /**
             * Copy URL to clipboard
             * @private
             */
            async _copyToClipboard(url) {
                try {
                    await navigator.clipboard.writeText(url);
                    alert('Link kopiert!');
                } catch (err) {
                    prompt('Link kopieren:', url);
                }
            },

            /**
             * Share to Twitter/X
             * @private
             */
            _shareTwitter(url) {
                const currentStep = ISONOMIA.history[ISONOMIA.history.length - 1];
                const data = narrativeData[currentStep];
                const text = data ? data.text.substring(0, 100) + '...' : 'ISONOMIA | Projekt Kronos';
                const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
                window.open(twitterUrl, '_blank', 'width=550,height=420');
            },

            /**
             * Share to Mastodon
             * @private
             */
            _shareMastodon(url) {
                const currentStep = ISONOMIA.history[ISONOMIA.history.length - 1];
                const data = narrativeData[currentStep];
                const text = data ? data.text.substring(0, 100) + '...' : 'ISONOMIA | Projekt Kronos';
                const mastodonUrl = `https://mastodon.social/share?text=${encodeURIComponent(text + '\n\n' + url)}`;
                window.open(mastodonUrl, '_blank', 'width=550,height=420');
            },

            /**
             * Parse URL parameter on load
             */
            checkUrlParameter() {
                const params = new URLSearchParams(window.location.search);
                const step = params.get('step');
                if (step && narrativeData[step]) {
                    return step;
                }
                return null;
            }
        };

        // ==================================================================
        // SECTION 10: SIMULATION MODE (Updated)
        // ==================================================================

        const SimulationMode = {
            /** @type {Array} Pool of simulated citizens */
            citizens: [
                { name: 'Maria Schmidt', job: 'Krankenschwester', bio: '35 Jahre, zwei Kinder, arbeitet im Schichtdienst. Mitglied im Mütterzentrum.', icon: '👩‍⚕️' },
                { name: 'Hassan Al-Farsi', job: 'Taxifahrer', bio: '42 Jahre, spricht 4 Sprachen, kennt jeden Stadtteil. Engagiert im Bürgerverein.', icon: '🚕' },
                { name: 'Erika Müller', job: 'Rentnerin', bio: '68 Jahre, ehemalige Buchhalterin. Leitet eine Nachbarschaftshilfe.', icon: '👵' },
                { name: 'Tom Weber', job: 'Software-Entwickler', bio: '29 Jahre, Open-Source-Aktivist. Organisiert Repair-Cafés.', icon: '👨‍💻' },
                { name: 'Aisha Johnson', job: 'Lehrerin', bio: '38 Jahre, unterrichtet an einer Gesamtschule. Debattierclub-Coach.', icon: '👩‍🏫' },
                { name: 'Klaus Richter', job: 'Metzger', bio: '55 Jahre, Familienbetrieb in 3. Generation. Kennt alle im Viertel.', icon: '🔪' },
                { name: 'Sophie Chen', job: 'Studierende', bio: '22 Jahre, Soziologie & Politikwissenschaft. Campus-Engagement für Inklusion.', icon: '👩‍🎓' },
                { name: 'Dieter Fischer', job: 'Bauarbeiter', bio: '45 Jahre, Gewerkschaftsvertreter. Praktischer Problem-Löser.', icon: '👷' },
                { name: 'Fatima Özdemir', job: 'Friseurin', bio: '31 Jahre, eigener Salon. Informelle Beraterin für viele Kunden.', icon: '💇‍♀️' },
                { name: 'Robert Klein', job: 'Künstler', bio: '40 Jahre, freischaffend. Organisiert Kulturveranstaltungen im Stadtpark.', icon: '🎨' },
                { name: 'Helga Bauer', job: 'Landwirtin', bio: '52 Jahre, Bio-Hof. Versteht Nachhaltigkeit aus praktischer Erfahrung.', icon: '👩‍🌾' },
                { name: 'Jamal Williams', job: 'Sozialarbeiter', bio: '36 Jahre, Jugendzentrum. Arbeitet direkt mit den Herausforderungen der Stadt.', icon: '🤝' }
            ],

            /**
             * Start the lottery simulation
             */
            start() {
                const ui = document.getElementById('content-layer');
                ui.innerHTML = `
                    <div class="gandalf-voice" role="article" aria-label="Los-Simulation">
                        <h1>Die Isonomie-Lotterie</h1>
                        <p style="color: var(--dim-text); margin-bottom: 2rem;">
                            In Athen wurden Bürgerämter durch das Los vergeben.<br>
                            Keine Wahlkämpfe. Keine Parteien. Nur Gleichheit.
                        </p>
                        <div id="simulation-stage">
                            <button class="haptic-btn" id="draw-lottery-btn" onclick="SimulationMode.drawLottery()" style="font-size: 1.2rem; padding: 1.5rem 3rem;">
                                🎲 Ein Los ziehen
                            </button>
                        </div>
                        <p style="margin-top: 2rem; font-size: 0.8rem; color: var(--dim-text);">
                            Chance: 1:${this.citizens.length} (heute: 1:5000+ bei großen Städten)
                        </p>
                        <br>
                        <button class="haptic-btn btn-small" onclick="ISONOMIA.showVault()">← Zurück zum Vault</button>
                    </div>`;
                
                ISONOMIA.applyVisualMode('stochastic');
            },

            /**
             * Draw a citizen from the lottery
             */
            drawLottery() {
                const stage = document.getElementById('simulation-stage');
                const button = document.getElementById('draw-lottery-btn');
                
                if (button) {
                    button.disabled = true;
                    button.textContent = 'Das Los fällt...';
                }

                // Animation: shuffle through citizens
                let shuffleCount = 0;
                const maxShuffles = 15;
                const shuffleInterval = setInterval(() => {
                    const randomCitizen = this.citizens[Math.floor(Math.random() * this.citizens.length)];
                    this._renderShuffleCard(stage, randomCitizen);
                    shuffleCount++;
                    
                    if (shuffleCount >= maxShuffles) {
                        clearInterval(shuffleInterval);
                        this._showFinalResult(stage);
                    }
                }, 100);
            },

            /**
             * Render a shuffling card
             * @private
             */
            _renderShuffleCard(container, citizen) {
                container.innerHTML = `
                    <div class="lottery-card shuffling">
                        <div class="lottery-icon">${citizen.icon}</div>
                        <div class="lottery-name">${citizen.name}</div>
                        <div class="lottery-job">${citizen.job}</div>
                    </div>
                `;
            },

            /**
             * Show the final lottery result
             * @private
             */
            _showFinalResult(container) {
                const winner = this.citizens[Math.floor(Math.random() * this.citizens.length)];
                
                container.innerHTML = `
                    <div class="lottery-card winner" style="animation: lotteryReveal 0.6s ease-out;">
                        <div class="lottery-winner-badge">🎉 GEZOGEN</div>
                        <div class="lottery-icon" style="font-size: 4rem;">${winner.icon}</div>
                        <div class="lottery-name" style="color: var(--cyan); font-size: 1.5rem; margin: 1rem 0;">${winner.name}</div>
                        <div class="lottery-job" style="color: var(--white); font-weight: bold;">${winner.job}</div>
                        <div class="lottery-bio" style="margin-top: 1rem; padding: 1rem; background: rgba(0,255,204,0.05); border-left: 2px solid var(--cyan);">${winner.bio}</div>
                        <div class="lottery-term" style="margin-top: 1.5rem; color: var(--dim-text); font-size: 0.9rem;">
                            📅 Amtszeit: 1 Jahr<br>
                            🏛️ Position: Mitglied der Bürgerkammer
                        </div>
                    </div>
                    <button class="haptic-btn" onclick="SystemCheck.start(() => SimulationMode.start())" style="margin-top: 2rem;">
                        Nochmal ziehen
                    </button>
                `;

                // Visual celebration
                ISONOMIA.applyVisualMode('breathe');
                this._celebrationEffect();
            },

            /**
             * Create celebration particle effect
             * @private
             */
            _celebrationEffect() {
                anime.animate('.dot', {
                    scale: [1, 2, 1],
                    opacity: [0.4, 1, 0.4],
                    backgroundColor: ['#00FFCC', '#FFFFFF', '#00FFCC'],
                    delay: anime.stagger(20),
                    duration: 1000,
                    ease: 'easeOutElastic(1, .5)'
                });
            }
        };

        // ==================================================================
        // SECTION 11: AMBIENT AUDIO (Updated)
        // ==================================================================

        const AmbientAudio = {
            /** @type {AudioContext|null} Web Audio API context */
            ctx: null,
            
            /** @type {boolean} Whether audio is enabled */
            enabled: false,
            
            /** @type {GainNode} Master volume control */
            masterGain: null,
            
            /** @type {OscillatorNode|null} Current drone oscillator */
            currentDrone: null,
            
            /** @type {string} Current mode */
            currentMode: 'breathe',

            /**
             * Initialize audio context (must be called after user interaction)
             */
            init() {
                if (this.ctx) return;
                
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.15; // Low volume
                    this.masterGain.connect(this.ctx.destination);
                    this.enabled = true;
                    console.log('[ISONOMIA] Audio initialized');
                } catch (e) {
                    console.warn('[ISONOMIA] Audio not supported:', e);
                }
            },

            /**
             * Play ambient sound for current visual mode
             * @param {string} mode - Visual mode identifier
             */
            playMode(mode) {
                if (!this.enabled || !this.ctx) return;
                this.currentMode = mode;

                // Stop current drone
                this._stopDrone();

                const soundscapes = {
                    'breathe': () => this._playBreathe(),
                    'tremble': () => this._playTremble(),
                    'chaos': () => this._playChaos(),
                    'clash': () => this._playClash(),
                    'pyramid': () => this._playPyramid(),
                    'pyramid_struggle': () => this._playPyramidStruggle(),
                    'pyramid_dissolve': () => this._playDissolve(),
                    'stochastic': () => this._playStochastic(),
                    'reset_to_grid': () => this._playGrid()
                };

                if (soundscapes[mode]) {
                    soundscapes[mode]();
                }
            },

            /**
             * Gentle breathing drone
             * @private
             */
            _playBreathe() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = 110; // A2
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 3);
                
                // Breathing modulation
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 0.25; // 4 second breath cycle
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 0.1;
                
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                lfo.start();
                
                this.currentDrone = { osc, lfo, nodes: [gain, lfoGain] };
            },

            /**
             * Subtle tremble
             * @private
             */
            _playTremble() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.value = 220;
                
                // Tremolo effect
                const tremolo = this.ctx.createOscillator();
                tremolo.frequency.value = 8; // Fast tremble
                const tremoloGain = this.ctx.createGain();
                tremoloGain.gain.value = 0.05;
                
                tremolo.connect(tremoloGain);
                tremoloGain.connect(gain.gain);
                
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                tremolo.start();
                
                this.currentDrone = { osc, lfo: tremolo, nodes: [gain, tremoloGain] };
            },

            /**
             * Chaotic dissonance
             * @private
             */
            _playChaos() {
                // Multiple detuned oscillators
                const freqs = [110, 115, 220, 233];
                const oscillators = [];
                
                freqs.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = i % 2 === 0 ? 'sawtooth' : 'square';
                    osc.frequency.value = freq;
                    osc.detune.value = Math.random() * 50 - 25;
                    
                    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    
                    oscillators.push({ osc, gain });
                });
                
                this.currentDrone = { multi: true, oscillators };
            },

            /**
             * Clash - two opposing tones
             * @private
             */
            _playClash() {
                const leftOsc = this.ctx.createOscillator();
                const rightOsc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                leftOsc.type = 'sawtooth';
                leftOsc.frequency.value = 196; // G3
                
                rightOsc.type = 'sawtooth';
                rightOsc.frequency.value = 207; // G#3 (dissonant)
                
                // Stereo panning
                const leftPan = this.ctx.createStereoPanner();
                const rightPan = this.ctx.createStereoPanner();
                leftPan.pan.value = -0.8;
                rightPan.pan.value = 0.8;
                
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                
                leftOsc.connect(leftPan);
                rightOsc.connect(rightPan);
                leftPan.connect(gain);
                rightPan.connect(gain);
                gain.connect(this.masterGain);
                
                leftOsc.start();
                rightOsc.start();
                
                this.currentDrone = { osc: null, nodes: [gain, leftPan, rightPan], multi: true, oscillators: [{osc: leftOsc}, {osc: rightOsc}] };
            },

            /**
             * Pyramid - hierarchical low drone
             * @private
             */
            _playPyramid() {
                const osc = this.ctx.createOscillator();
                const filter = this.ctx.createBiquadFilter();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.value = 65; // Deep C2
                
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                
                this.currentDrone = { osc, nodes: [filter, gain] };
            },

            /**
             * Pyramid with struggle
             * @private
             */
            _playPyramidStruggle() {
                this._playPyramid();
                
                // Add struggling higher tones
                const struggleOsc = this.ctx.createOscillator();
                const struggleGain = this.ctx.createGain();
                
                struggleOsc.type = 'square';
                struggleOsc.frequency.value = 330;
                
                // Frantic modulation
                const mod = this.ctx.createOscillator();
                mod.frequency.value = 3;
                const modGain = this.ctx.createGain();
                modGain.gain.value = 100;
                mod.connect(modGain);
                modGain.connect(struggleOsc.frequency);
                
                struggleGain.gain.setValueAtTime(0.03, this.ctx.currentTime);
                
                struggleOsc.connect(struggleGain);
                struggleGain.connect(this.masterGain);
                
                struggleOsc.start();
                mod.start();
                
                if (this.currentDrone) {
                    this.currentDrone.nodes.push(struggleGain, modGain);
                    this.currentDrone.oscillators = this.currentDrone.oscillators || [];
                    this.currentDrone.oscillators.push({osc: struggleOsc}, {osc: mod});
                }
            },

            /**
             * Dissolve - fading out
             * @private
             */
            _playDissolve() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = 220;
                
                // Rapid fade
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                osc.stop(this.ctx.currentTime + 2);
                
                // No need to track for stopping
                this.currentDrone = null;
            },

            /**
             * Stochastic - random particles
             * @private
             */
            _playStochastic() {
                // Cancel any existing stochastic timeout
                if (this._stochasticTimeout) {
                    clearTimeout(this._stochasticTimeout);
                    this._stochasticTimeout = null;
                }
                
                const playBlip = () => {
                    if (this.currentMode !== 'stochastic' || !this.enabled) {
                        this._stochasticTimeout = null;
                        return;
                    }
                    
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.frequency.value = 440 + Math.random() * 880;
                    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.1);
                    
                    this._stochasticTimeout = setTimeout(playBlip, 50 + Math.random() * 200);
                };
                
                playBlip();
            },

            /**
             * Grid - harmonious chords
             * @private
             */
            _playGrid() {
                const freqs = [261.63, 329.63, 392.00]; // C major chord
                const oscillators = [];
                
                freqs.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 1 + i * 0.2);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    
                    oscillators.push({ osc, gain });
                });
                
                this.currentDrone = { multi: true, oscillators };
            },

            /**
             * Stop current drone
             * @private
             */
            _stopDrone() {
                // Cancel stochastic timeout if exists
                if (this._stochasticTimeout) {
                    clearTimeout(this._stochasticTimeout);
                    this._stochasticTimeout = null;
                }
                
                if (!this.currentDrone) return;
                
                const fadeTime = 0.5;
                const stopTime = this.ctx.currentTime + fadeTime;
                
                if (this.currentDrone.multi) {
                    this.currentDrone.oscillators.forEach(({osc, gain}) => {
                        if (gain) {
                            gain.gain.cancelScheduledValues(this.ctx.currentTime);
                            gain.gain.setValueAtTime(gain.gain.value, this.ctx.currentTime);
                            gain.gain.linearRampToValueAtTime(0, stopTime);
                        }
                        if (osc) osc.stop(stopTime);
                    });
                } else {
                    if (this.currentDrone.osc) {
                        this.currentDrone.osc.stop(stopTime);
                    }
                    if (this.currentDrone.nodes) {
                        this.currentDrone.nodes.forEach(node => {
                            if (node.gain) {
                                node.gain.cancelScheduledValues(this.ctx.currentTime);
                                node.gain.setValueAtTime(node.gain.value, this.ctx.currentTime);
                                node.gain.linearRampToValueAtTime(0, stopTime);
                            }
                        });
                    }
                }
                
                this.currentDrone = null;
            },

            /**
             * Toggle audio on/off
             */
            toggle() {
                if (!this.ctx) {
                    this.init();
                    return true;
                }
                
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                    this.enabled = true;
                    return true;
                } else if (this.enabled) {
                    this.enabled = false;
                    this._stopDrone();
                    return false;
                } else {
                    this.enabled = true;
                    return true;
                }
            },

            /**
             * Get current state
             */
            getState() {
                return {
                    enabled: this.enabled,
                    initialized: !!this.ctx,
                    mode: this.currentMode
                };
            }
        };

        // ==================================================================
        // SECTION 12: 3D ENGINE INTEGRATION (Three.js)
        // ==================================================================
        
        /**
         * ISONOMIA 3D - Raum-basiertes narrative System
         * 
         * Transformiert die flache State-Machine in einen begehbaren 3D-Raum.
         * Jeder narrative Knoten ist eine Station im Raum mit:
         * - 3D-Position (x, y, z)
         * - Kamera-Position und Blickrichtung
         * - Partikel-Formation (Visual Mode)
         * - Umgebungs-Atmosphäre
         */
        
        const ISONOMIA3D = {
            // Three.js Core
            scene: null,
            camera: null,
            renderer: null,
            
            // Partikel-System
            particleMesh: null,
            particleCount: 180,
            particleData: [],  // Position, Geschwindigkeit, Zustand pro Partikel
            
            // Kamera-System
            cameraRig: {
                currentPos: new THREE.Vector3(0, 2, 5),
                targetPos: new THREE.Vector3(0, 2, 5),
                lookAtCurrent: new THREE.Vector3(0, 0, 0),
                lookAtTarget: new THREE.Vector3(0, 0, 0),
                isTransitioning: false,
                transitionStartTime: 0,
                transitionDuration: 2000
            },
            
            // Narrativer Raum
            narrativeSpace: {
                'start': {
                    position: new THREE.Vector3(0, 0, 0),
                    camera: new THREE.Vector3(0, 2, 8),
                    lookAt: new THREE.Vector3(0, 0, 0),
                    particleMode: 'breathe',
                    fog: { color: 0x050505, near: 10, far: 50 }
                },
                'skeptic': {
                    position: new THREE.Vector3(-3, 0, -5),
                    camera: new THREE.Vector3(-2, 1.5, 3),
                    lookAt: new THREE.Vector3(-3, 0, -5),
                    particleMode: 'tremble',
                    fog: { color: 0x0a0505, near: 5, far: 40 }
                },
                'hook': {
                    position: new THREE.Vector3(0, 0, -10),
                    camera: new THREE.Vector3(3, 2, -5),
                    lookAt: new THREE.Vector3(0, 0, -10),
                    particleMode: 'chaos',
                    fog: { color: 0x1a050a, near: 5, far: 35 }
                },
                'path_parties_start': {
                    position: new THREE.Vector3(0, 0, -20),
                    camera: new THREE.Vector3(-6, 1, -15),
                    lookAt: new THREE.Vector3(0, 0, -20),
                    particleMode: 'clash',
                    fog: { color: 0x150510, near: 8, far: 40 }
                },
                'nvc_validation_conflict': {
                    position: new THREE.Vector3(-5, 2, -22),
                    camera: new THREE.Vector3(-8, 3, -18),
                    lookAt: new THREE.Vector3(-5, 2, -22),
                    particleMode: 'tremble',
                    fog: { color: 0x120508, near: 5, far: 35 }
                },
                'path_expert_logic': {
                    position: new THREE.Vector3(8, 0, -25),
                    camera: new THREE.Vector3(8, 6, -18),
                    lookAt: new THREE.Vector3(8, 2, -25),
                    particleMode: 'pyramid',
                    fog: { color: 0x080808, near: 10, far: 50 }
                },
                'nvc_validation_expert': {
                    position: new THREE.Vector3(10, 3, -28),
                    camera: new THREE.Vector3(12, 7, -22),
                    lookAt: new THREE.Vector3(10, 3, -28),
                    particleMode: 'pyramid_struggle',
                    fog: { color: 0x100505, near: 8, far: 45 }
                },
                'platon_deconstruction': {
                    position: new THREE.Vector3(12, -2, -30),
                    camera: new THREE.Vector3(15, 3, -25),
                    lookAt: new THREE.Vector3(12, -2, -30),
                    particleMode: 'pyramid_dissolve',
                    fog: { color: 0x1a0510, near: 5, far: 40 }
                },
                'intro_isonomia_logic': {
                    position: new THREE.Vector3(-8, 4, -35),
                    camera: new THREE.Vector3(-5, 7, -28),
                    lookAt: new THREE.Vector3(-8, 4, -35),
                    particleMode: 'stochastic',
                    fog: { color: 0x050a0a, near: 10, far: 60 }
                },
                'isonomia_mechanism': {
                    position: new THREE.Vector3(-10, 2, -40),
                    camera: new THREE.Vector3(-7, 5, -35),
                    lookAt: new THREE.Vector3(-10, 2, -40),
                    particleMode: 'reset_to_grid',
                    fog: { color: 0x050808, near: 12, far: 55 }
                },
                'isonomia_qualification': {
                    position: new THREE.Vector3(-12, 5, -42),
                    camera: new THREE.Vector3(-9, 8, -36),
                    lookAt: new THREE.Vector3(-12, 5, -42),
                    particleMode: 'breathe',
                    fog: { color: 0x050808, near: 10, far: 50 }
                },
                'final_manifestation': {
                    position: new THREE.Vector3(0, 8, -50),
                    camera: new THREE.Vector3(0, 12, -42),
                    lookAt: new THREE.Vector3(0, 10, -50),
                    particleMode: 'reset_to_grid',
                    fog: { color: 0x050505, near: 15, far: 80 }
                },
                'vault': {
                    position: new THREE.Vector3(0, 0, 0),
                    camera: new THREE.Vector3(0, 3, 10),
                    lookAt: new THREE.Vector3(0, 0, 0),
                    particleMode: 'breathe',
                    fog: { color: 0x050505, near: 10, far: 60 }
                }
            },
            
            // Animation Frame ID
            animationId: null,
            
            // Zeit für Animationen
            clock: new THREE.Clock(),
            
            /**
             * Initialisiert die 3D-Szene
             */
            init() {
                // Prüfe WebGL-Support
                if (!this._checkWebGL()) {
                    console.warn('[ISONOMIA3D] WebGL nicht verfügbar, verwende 2D-Fallback');
                    return false;
                }
                
                this._initScene();
                this._initCamera();
                this._initRenderer();
                this._initParticles();
                this._initLighting();
                this._setupResizeHandler();
                
                // Starte Render-Loop
                this._animate();
                
                console.log('[ISONOMIA3D] 3D-Engine initialisiert');
                return true;
            },
            
            /**
             * Prüft WebGL-Unterstützung
             */
            _checkWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext && 
                        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch (e) {
                    return false;
                }
            },
            
            /**
             * Erstellt die Three.js Scene
             */
            _initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                this.scene.fog = new THREE.Fog(0x050505, 10, 50);
            },
            
            /**
             * Initialisiert die Kamera
             */
            _initCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    60,  // FOV
                    window.innerWidth / window.innerHeight,  // Aspect
                    0.1,  // Near
                    1000  // Far
                );
                this.camera.position.copy(this.cameraRig.currentPos);
                this.camera.lookAt(this.cameraRig.lookAtCurrent);
            },
            
            /**
             * Erstellt den WebGL-Renderer
             */
            _initRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: 'high-performance'
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x050505, 1);
                
                // Füge Canvas vor particle-container ein
                const container = document.getElementById('particle-container');
                this.renderer.domElement.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    z-index: 0;
                `;
                container.insertBefore(this.renderer.domElement, container.firstChild);
            },
            
            /**
             * Initialisiert das InstancedMesh-Partikel-System
             */
            _initParticles() {
                // Geometrie: Kugel mit niedriger Poly-Anzahl
                const geometry = new THREE.SphereGeometry(0.08, 8, 8);
                
                // Material: Selbstleuchtend für Glow-Effekt
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FFCC,
                    transparent: true,
                    opacity: 0.8
                });
                
                // InstancedMesh für Performance (1 Draw Call)
                this.particleMesh = new THREE.InstancedMesh(
                    geometry,
                    material,
                    this.particleCount
                );
                
                // Initialisiere Partikel-Daten
                this.particleData = [];
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                
                for (let i = 0; i < this.particleCount; i++) {
                    // Zufällige Position im Sichtbereich
                    const x = (Math.random() - 0.5) * 20;
                    const y = (Math.random() - 0.5) * 10;
                    const z = (Math.random() - 0.5) * 20;
                    
                    dummy.position.set(x, y, z);
                    dummy.updateMatrix();
                    this.particleMesh.setMatrixAt(i, dummy.matrix);
                    
                    // Speichere individuelle Partikel-Daten
                    this.particleData.push({
                        basePosition: new THREE.Vector3(x, y, z),
                        currentPosition: new THREE.Vector3(x, y, z),
                        velocity: new THREE.Vector3(0, 0, 0),
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.5 + Math.random() * 0.5,
                        isElite: i < 12  // Für Pyramid-Modus
                    });
                    
                    // Standard-Farbe (Cyan)
                    this.particleMesh.setColorAt(i, color.setHex(0x00FFCC));
                }
                
                this.particleMesh.instanceMatrix.needsUpdate = true;
                this.scene.add(this.particleMesh);
            },
            
            /**
             * Fügt subtile Beleuchtung hinzu
             */
            _initLighting() {
                // Ambient Light für Grundhelligkeit
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Point Light für dramatische Effekte
                this.pointLight = new THREE.PointLight(0x00FFCC, 1, 50);
                this.pointLight.position.set(0, 5, 0);
                this.scene.add(this.pointLight);
            },
            
            /**
             * Haupt-Animations-Loop
             */
            _animate() {
                this.animationId = requestAnimationFrame(() => this._animate());
                
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();
                
                // Update Kamera-Übergänge
                this._updateCamera(delta);
                
                // Update Partikel-Animation
                this._updateParticles(time);
                
                // Update PointLight-Position
                this.pointLight.position.x = Math.sin(time * 0.5) * 5;
                this.pointLight.position.z = Math.cos(time * 0.5) * 5;
                
                // Render
                this.renderer.render(this.scene, this.camera);
            },
            
            /**
             * Interpoliert Kamera-Position während Übergängen
             */
            _updateCamera(delta) {
                if (!this.cameraRig.isTransitioning) return;
                
                const now = performance.now();
                const elapsed = now - this.cameraRig.transitionStartTime;
                const progress = Math.min(elapsed / this.cameraRig.transitionDuration, 1);
                
                // Easing: easeInOutCubic
                const eased = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                // Interpoliere Position
                this.cameraRig.currentPos.lerpVectors(
                    this.cameraRig.currentPos,
                    this.cameraRig.targetPos,
                    eased * 0.1  // Smooth follow
                );
                
                // Interpoliere LookAt
                this.cameraRig.lookAtCurrent.lerpVectors(
                    this.cameraRig.lookAtCurrent,
                    this.cameraRig.lookAtTarget,
                    eased * 0.1
                );
                
                // Wende an
                this.camera.position.copy(this.cameraRig.currentPos);
                this.camera.lookAt(this.cameraRig.lookAtCurrent);
                
                // Prüfe Ende
                if (progress >= 1 && this.cameraRig.currentPos.distanceTo(this.cameraRig.targetPos) < 0.1) {
                    this.cameraRig.isTransitioning = false;
                }
            },
            
            /**
             * Partikel-Animation basierend auf aktuellem Mode
             */
            _updateParticles(time) {
                if (!this.particleMesh) return;
                
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                const currentMode = this._currentMode || 'breathe';
                
                for (let i = 0; i < this.particleCount; i++) {
                    const data = this.particleData[i];
                    let x, y, z, scale, opacity;
                    
                    switch (currentMode) {
                        case 'breathe':
                            // Sanfte Atmung: Y-Offset mit Sinus
                            const breathe = Math.sin(time * 2 + data.phase) * 0.3;
                            x = data.basePosition.x;
                            y = data.basePosition.y + breathe;
                            z = data.basePosition.z;
                            scale = 1 + Math.sin(time * 2 + data.phase) * 0.3;
                            color.setHex(0x00FFCC);
                            break;
                            
                        case 'tremble':
                            // Vibration: schnelle kleine Bewegungen
                            const tremble = Math.sin(time * 20 + data.phase) * 0.05;
                            x = data.currentPosition.x + tremble;
                            y = data.currentPosition.y + tremble;
                            z = data.currentPosition.z;
                            scale = 1;
                            color.setHex(0x00FFCC);
                            break;
                            
                        case 'chaos':
                            // Chaotische Bewegung mit Noise
                            const chaosX = Math.sin(time * 0.5 + data.phase) * 5 + Math.cos(time * 1.3 + i) * 2;
                            const chaosY = Math.cos(time * 0.7 + data.phase) * 3 + Math.sin(time * 0.9 + i) * 2;
                            const chaosZ = Math.sin(time * 0.3 + i * 0.1) * 5;
                            x = data.basePosition.x + chaosX;
                            y = data.basePosition.y + chaosY;
                            z = data.basePosition.z + chaosZ;
                            scale = 1 + Math.sin(time * 3 + i) * 0.2;
                            color.setHex(0xFF3366);  // Magenta für Chaos
                            break;
                            
                        case 'clash':
                            // Zwei gegnerische Gruppen
                            const isLeft = i % 2 === 0;
                            const groupX = isLeft ? -4 : 4;
                            const noiseX = Math.sin(time + data.phase) * 0.5;
                            const noiseY = Math.cos(time * 1.5 + data.phase) * 0.3;
                            x = groupX + noiseX;
                            y = data.basePosition.y * 0.5 + noiseY;
                            z = data.basePosition.z;
                            scale = isLeft ? 1.2 : 0.9;
                            color.setHex(isLeft ? 0x00FFCC : 0xFF3366);
                            break;
                            
                        case 'pyramid':
                        case 'pyramid_struggle':
                            // Pyramiden-Struktur
                            const row = Math.floor(Math.sqrt(i));
                            const col = i - row * row;
                            const pyramidX = (col - row / 2) * 0.8;
                            const pyramidY = row * 0.5 - 2;
                            const pyramidZ = -row * 0.3;
                            
                            // Eliten oben (größer, weiß)
                            if (data.isElite) {
                                x = (col - 5.5) * 0.5;
                                y = 4;
                                z = -5;
                                scale = 2;
                                color.setHex(0xFFFFFF);
                            } else {
                                x = pyramidX;
                                y = pyramidY;
                                z = pyramidZ;
                                scale = 0.7;
                                color.setHex(0x00FFCC);
                            }
                            
                            // Struggle-Animation
                            if (currentMode === 'pyramid_struggle' && !data.isElite) {
                                y += Math.sin(time * 3 + data.phase) * 0.2;
                            }
                            break;
                            
                        case 'pyramid_dissolve':
                            // Pyramide löst sich auf
                            const dissolveFactor = Math.min((time % 5) / 3, 1);
                            const explodeX = Math.sin(data.phase * 3) * 10 * dissolveFactor;
                            const explodeY = Math.cos(data.phase * 2) * 10 * dissolveFactor;
                            const explodeZ = Math.sin(data.phase * 4) * 10 * dissolveFactor;
                            x = data.currentPosition.x + explodeX * 0.1;
                            y = data.currentPosition.y + explodeY * 0.1;
                            z = data.currentPosition.z + explodeZ * 0.1;
                            scale = 1 - dissolveFactor * 0.5;
                            color.setHex(0xFF3366);
                            break;
                            
                        case 'stochastic':
                            // Explosion aus Zentrum
                            const angle = (i / this.particleCount) * Math.PI * 2;
                            const radius = 2 + Math.sin(time * 2 + data.phase) * 3;
                            const spread = Math.cos(time + i * 0.1) * 2;
                            x = Math.cos(angle) * radius + spread;
                            y = Math.sin(angle) * radius * 0.5 + spread * 0.5;
                            z = Math.sin(angle * 2) * radius * 0.5;
                            scale = 0.5 + Math.sin(time * 4 + i) * 0.5;
                            color.setHex(0x00FFCC);
                            break;
                            
                        case 'reset_to_grid':
                            // Kristallines Gitter
                            const gridCols = 15;
                            const gridX = (i % gridCols - gridCols / 2) * 1.2;
                            const gridY = (Math.floor(i / gridCols) - 6) * 0.8;
                            const gridZ = Math.sin(time + data.phase) * 0.5;
                            x = gridX;
                            y = gridY + 2;
                            z = gridZ - 10;
                            scale = 1 + Math.sin(time * 2 + data.phase) * 0.2;
                            color.setHex(0x00FFCC);
                            break;
                            
                        default:
                            x = data.basePosition.x;
                            y = data.basePosition.y;
                            z = data.basePosition.z;
                            scale = 1;
                            color.setHex(0x00FFCC);
                    }
                    
                    // Setze Transform
                    dummy.position.set(x, y, z);
                    dummy.scale.setScalar(scale);
                    dummy.updateMatrix();
                    this.particleMesh.setMatrixAt(i, dummy.matrix);
                    this.particleMesh.setColorAt(i, color);
                    
                    // Speichere aktuelle Position für nächsten Frame
                    data.currentPosition.set(x, y, z);
                }
                
                this.particleMesh.instanceMatrix.needsUpdate = true;
                if (this.particleMesh.instanceColor) {
                    this.particleMesh.instanceColor.needsUpdate = true;
                }
            },
            
            /**
             * Triggered einen Kamera-Übergang zu einem narrativen Knoten
             */
            navigateToNode(nodeKey) {
                const space = this.narrativeSpace[nodeKey];
                if (!space) {
                    console.warn(`[ISONOMIA3D] Unbekannter Knoten: ${nodeKey}`);
                    return;
                }
                
                // Setze Ziele
                this.cameraRig.targetPos.copy(space.camera);
                this.cameraRig.lookAtTarget.copy(space.lookAt);
                this._currentMode = space.particleMode;
                
                // Starte Übergang
                this.cameraRig.isTransitioning = true;
                this.cameraRig.transitionStartTime = performance.now();
                
                // Update Fog
                if (space.fog && this.scene.fog) {
                    this.scene.fog.color.setHex(space.fog.color);
                    this.scene.fog.near = space.fog.near;
                    this.scene.fog.far = space.fog.far;
                }
                
                console.log(`[ISONOMIA3D] Navigation zu: ${nodeKey}`);
            },
            
            /**
             * Setzt Partikel-Modus direkt (für Visual Mode Updates)
             */
            setParticleMode(mode) {
                this._currentMode = mode;
            },
            
            /**
             * Handler für Fenster-Resize
             */
            _setupResizeHandler() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },
            
            /**
             * Cleanup beim Verlassen
             */
            dispose() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                if (this.renderer) {
                    this.renderer.dispose();
                }
                if (this.particleMesh) {
                    this.particleMesh.geometry.dispose();
                    this.particleMesh.material.dispose();
                }
            }
        };

        // ==================================================================
        // SECTION 13: APPLICATION ENTRY POINT (Updated with 3D)
        // ==================================================================

        window.onload = () => {
            if (typeof anime === 'undefined') {
                document.body.innerHTML = `
                    <div style="display:flex;justify-content:center;align-items:center;height:100vh;color:#FF3366;font-family:sans-serif;text-align:center;padding:2rem;">
                        <div>
                            <h1>Systemfehler</h1>
                            <p>Animation-Engine nicht geladen.<br>Bitte Seite neu laden.</p>
                        </div>
                    </div>`;
                return;
            }
            
            // Versuche 3D zu initialisieren
            const use3D = ISONOMIA3D.init();
            
            // Initialisiere Haupt-Anwendung
            ISONOMIA.init();
            
            // Wenn 3D aktiv, verberge DOM-Partikel
            if (use3D) {
                const dots = document.querySelectorAll('.dot');
                dots.forEach(dot => dot.style.display = 'none');
                console.log('[ISONOMIA] 3D-Modus aktiviert, DOM-Partikel verborgen');
            }
        };
    </script>
</body>
</html>
